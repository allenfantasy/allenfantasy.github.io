<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iFrame 那些事 · A Fantasy Ninja</title><meta name="description" content="iFrame 那些事 - Allen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/allenfantasy" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iFrame 那些事</h1><div class="post-meta"><span class="post-time">2018年7月15日</span><span class="taglist"><a href="/tags/HTML" class="tag">HTML</a></span></div><div class="post-content"><p>基本上稍有一定开发经历的 Web 开发者都多少会和 <code>&lt;iframe&gt;</code> 打过交道，但在最近连续接触了几个相关的需求之后，我却突然意识到，自己对 iFrame 并不是非常的了解，这就是本文的由来。</p>
<a id="more"></a>
<p>在介绍 iFrame 之前，我们首先来了解一下 <strong>浏览上下文</strong>。</p>
<h2 id="浏览上下文（Browsing-Context）"><a href="#浏览上下文（Browsing-Context）" class="headerlink" title="浏览上下文（Browsing Context）"></a>浏览上下文（Browsing Context）</h2><p>根据 <a href="http://w3c.github.io/html/browsers.html#sec-browsing-contexts" target="_blank" rel="noopener">HTML 规范</a>中的定义：</p>
<blockquote>
<p>一个 <strong>浏览上下文</strong> 是一个浏览器向用户展示文档对象的环境。</p>
</blockquote>
<p>浏览上下文包含以下内容：</p>
<ol>
<li>一个 WindowProxy 对象，它包裹了一个当前窗口对象（Window），在浏览器的 JS 环境中我们只能用 <code>window</code> 关键字来获取到其对应的窗口对象。</li>
<li>一份用户的会话历史记录（<em>Session history</em>），记录了该浏览器上下文展示过的所有文档（Document）对象。</li>
<li>记录一个当前活跃的文档（<em>active document</em>），这个文档就是上下文对应的窗口对象所关联的文档对象（<em>associated Document</em>），即当前打开的文档对象。这个文档对象在窗口对象被创建时被设置，且只有在页面导航发生变化时才会变化。我们可以用 <code>document</code> 全局对象拿到当前打开的文档对象。</li>
</ol>
<p>从类型上，有几种不同的浏览上下文：</p>
<ol>
<li>浏览器的一个 tab 或者一个窗口</li>
<li><code>&lt;iframe&gt;</code></li>
<li>在 <code>&lt;frameset&gt;</code> 元素内的一个 <code>&lt;frame&gt;</code></li>
</ol>
<p>其中 <code>&lt;frameset&gt;</code> 的做法已经过时，并已被移出 Web 标准（取而代之的实现方案是 <code>&lt;iframe&gt;</code>）。</p>
<p>如果从结构上来看，浏览上下文是可嵌套的：文档内的某些元素如 <code>&lt;iframe&gt;</code> 可以实例化一个新的浏览上下文，这些元素被称为 <strong>浏览上下文容器（browsing context container）</strong>，而实例化的浏览上下文则被称为是 <strong>嵌套的浏览上下文（nested browsing context）</strong>；而对于某个嵌套的浏览上下文，其容器所在的文档对应的浏览器上下文，则可以被称为 <strong>父浏览上下文（parent browsing context）</strong>，且一定是唯一的。</p>
<p>对于浏览器的 tab 或者窗口来说，不存在比它更高一级的父上下文，所以它们可以被称为 <strong>顶级浏览上下文（top-level browsing context）</strong>。</p>
<p><img src="/images/browsing_context.png" alt=""></p>
<h2 id="iFrame-由来"><a href="#iFrame-由来" class="headerlink" title="iFrame 由来"></a>iFrame 由来</h2><p>我们现在了解了 <strong>浏览上下文</strong> 的概念，也知道 <code>&lt;iframe&gt;</code> 元素可以在一个文档内创建一个 <strong>嵌套的浏览上下文</strong>，但为什么要有 iFrame 的存在呢？这就要回顾一下 Web 早期的发展历程了。</p>
<p>在很久很久之前（咳咳），使用多窗口页面（frames）来创建网站是一种比较流行的手段，人们将一个大的网站拆分成多个 HTML 页面，每个页面独立的放到一个 <code>&lt;frame&gt;</code> 元素中，再通过 <code>&lt;frameset&gt;</code> 元素将这些 frame 元素包含在一起，开发者甚至可以用 <code>cols</code> 或者 <code>rows</code> 属性来控制每个 frame 页面所占据的位置大小，有点像 table 布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 很遗憾 这段 HTML 代码在现代浏览器上已经失效了 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"https://developer.mozilla.org/en/HTML/Element/frameset"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"https://developer.mozilla.org/en/HTML/Element/frame"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样做当然不是闲着蛋疼，而是因为当时有充分的证据证明，将一个网页切分成多个小的页面，在当时下载速度还比较慢的时候，是有利于页面加载的，至少可以保证某些页面的内容先加载好并展示出来。但随着时间推移，网速变快之后，这样的做法就显得没有任何必要了。（当然，到了 2010 年后，类似的做法又重新的被搬出来，有兴趣的同学可以搜索一下 bigpipe）</p>
<p>而到了上世纪90年代末期和21世纪初，Java Applets 和 Flash 技术盛行，允许 Web 开发者向页面中嵌入类似视频和动画的高级内容，当时是通过 <code>&lt;object&gt;</code> 和 <code>&lt;embed&gt;</code> 元素来完成的，并确实达到了一些效果，但后续接连冒出了安全性、可访问性、文件大小等问题，加上移动端浏览器不支持此类插件，于是该方案又渐渐被抛弃。</p>
<p>最终，是 <code>&lt;iframe&gt;</code> 元素，作为 HTML4 的标准，成为了事实上的嵌入页面的通用做法，这极大地方便 Web 开发者，可以在页面上嵌入来自第三方站点的内容，如优酷，Youtube 等：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Youtube: 10 Things I Regret About Node.js - Ryan Dahl - JSConf EU 2018 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">"560"</span> <span class="attr">height</span>=<span class="string">"315"</span> <span class="attr">src</span>=<span class="string">"https://www.youtube.com/embed/M3BM9TB-8yA"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">allow</span>=<span class="string">"autoplay; encrypted-media"</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="iFrame-的特性"><a href="#iFrame-的特性" class="headerlink" title="iFrame 的特性"></a>iFrame 的特性</h2><p>由于 <code>&lt;iframe&gt;</code> 实际上是一个独立的浏览上下文，所以它有以下几个特点：</p>
<ol>
<li>和父文档完全隔离的 CSS 和 JS</li>
<li>同源的 HTTP 文档和其内嵌的 <code>&lt;iframe&gt;</code> 元素可以通过 JS 互相获取到对方的窗口对象，并进行任意的操作。（非同源的窗口间不可以，使用 HTTPS 的协议也不可以）</li>
<li><code>&lt;iframe&gt;</code> 内部发生的页面跳转导航，不会对父浏览上下文（即父窗口）产生任何影响</li>
<li><code>&lt;iframe&gt;</code> 事实上会创建一个新的 Viewport（文章后面会专门讨论）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从顶部文档获取 iFrame 文档:</span></div><div class="line">iframeElement.contentWindow.document</div><div class="line"></div><div class="line"><span class="comment">// 从 iFrame 文档获取父文档</span></div><div class="line"><span class="built_in">window</span>.top.document</div></pre></td></tr></table></figure>
<h2 id="iFrame-的安全性"><a href="#iFrame-的安全性" class="headerlink" title="iFrame 的安全性"></a>iFrame 的安全性</h2><p>由于 iFrame 几乎是当前 HTML 标准唯一可以直接引入第三方页面（或者，被第三方页面引入）的方法。如何保证其中的安全性是一个非常重要的问题。</p>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>假设我们在文档内引入了一个 <code>&lt;iframe&gt;</code> 文档。根据 DOM 提供的 API，理论上在主文档的 JS 中，我们可以通过 <code>iframeElement.contentDocument</code> 或 <code>inframeElement.contentWindow</code> 来获取 iFrame 对应的文档对象或窗口，甚至通过操纵这两个对象的方法获取 <code>&lt;iframe&gt;</code> 内文档的 DOM 元素，并进行任意的操作。</p>
<p>但这样的操作是不能被接受的，因为这意味着任何页面都可以通过这样的方式，利用 JS 操纵另一个网站的页面。浏览器通过<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源策略（Same-origin Policy）</a>来限制这样的行为。</p>
<p>所谓“同源”，是指两个网站的 <code>协议+域名+端口</code> 是完全一致的，只要有一个不一致，则视作两个地址是非同源的。</p>
<p>当一个主页面尝试用以上的 JS 方法访问其嵌套的非同源 <code>&lt;iframe&gt;</code> 时，浏览器会返回以下错误：</p>
<blockquote>
<p>Uncaught DOMException: Failed to read the ‘contentDocument’ property from ‘HTMLIFrameElement’: Blocked a frame with origin “<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>“ from accessing a cross-origin frame.</p>
<p>Uncaught DOMException: Blocked a frame with origin “<a href="https://xxx.example.com" target="_blank" rel="noopener">https://xxx.example.com</a>“ from accessing a cross-origin frame.<br>    at <anonymous>:1:18</anonymous></p>
</blockquote>
<h4 id="（插播）iFrame-与主文档的通信"><a href="#（插播）iFrame-与主文档的通信" class="headerlink" title="（插播）iFrame 与主文档的通信"></a>（插播）iFrame 与主文档的通信</h4><p>最初 NetScape 提出同源策略时，其出发点是保证主文档并不能随意的操纵第三方的网站，但这也的确给开发者带来了一定的困扰。因为同源策略的检查非常严格，甚至不允许两个一级域名相同的文档间互相直接访问（如 <code>a.example.com</code> 和 <code>b.example.com</code>），但在某些场景下，开发者同时拥有两个域名下的页面，且希望两个页面间可以进行数据通信。</p>
<p>于是在早期，人们提出了若干个解决方案：</p>
<ol>
<li>通过在主页面和 <code>&lt;iframe&gt;</code> 中设置 <code>document.domain</code> 为同一个一级域名，来绕过同源策略的限制</li>
<li>利用 <code>location</code> 的特性，不同域的页面，可以写不可读，让父子页面互相写对方的 location 的哈希部分进行通讯：<ol>
<li>新建iframe，使用iframe访问一个非同源的地址（发请求），参数里带上父页面url；</li>
<li>当页面加载完成后，iframe内脚本设置父页面的url并在哈希部分带上数据；</li>
<li>父页面的脚本循环检查哈希值的变化，如果检查到有值就取值并清空哈希值；</li>
</ol>
</li>
</ol>
<p>而当 <code>window.postMessage</code> 出现后，一切都变成了浮云。<code>postMessage</code> <a href="https://caniuse.com/#search=postMessage" target="_blank" rel="noopener">支持 IE8+ 及所有现代浏览器</a>，且使用方式非常简单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 主 HTML: https://a.example.com/index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"child-iframe"</span> <span class="attr">src</span>=<span class="string">"https://b.example.com/index.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> iframeElement = <span class="built_in">document</span>.getElementById(<span class="string">'child-iframe'</span>)</div><div class="line">    iframeElement.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        iframeElement.contentWindow.postMessage(&#123; <span class="attr">data</span>: <span class="number">1</span> &#125;, <span class="string">'*'</span>)</div><div class="line">    &#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 被嵌入的 HTML: https://b.example.com/index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> origin = event.origin</div><div class="line">        <span class="keyword">var</span> data = event.data</div><div class="line">        <span class="comment">// 1. 根据业务逻辑判断 origin 的合法性</span></div><div class="line">        <span class="comment">// 2. 处理 data</span></div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="被引入的困扰"><a href="#被引入的困扰" class="headerlink" title="被引入的困扰"></a>被引入的困扰</h4><p>那么，既然 iFrame 可以允许在一个网页中嵌入任意的一个第三方的页面，那就意味着，我们编写的网页，是完全有可能被任何一个第三方的网站通过 <code>&lt;iframe&gt;</code> 引入的。而这些引入方，很可能带有恶意的攻击目的。</p>
<p><strong>点击劫持（Clickjacking）</strong> 就是一种非常经典的攻击方式，也叫 <em>界面伪装</em>，通过在网页中将部分内容通过隐藏在看似无害的内容（如按钮）下，诱使用户点击。配合 <code>&lt;iframe&gt;</code> 使用的套路非常简单，假设攻击者希望对 Facebook 进行点击劫持：</p>
<ol>
<li>将一个访客诱骗到一个钓鱼页面（方式可以有很多种）</li>
<li>页面本身看上去人畜无害，且带有一些诱导用户点击的内容（比如 <code>点击这里，赚大钱</code>，或者 <code>想寻求一些♂刺激吗？点击这里</code>）</li>
<li>实际上，钓鱼页面将一个 <code>src</code> 指向 Facebook 站点的 <code>&lt;iframe&gt;</code> 嵌入到页面中，且这个 iFrame 元素是透明的，覆盖在诱导用户点击的区域上方（但访客是看不到的）</li>
<li>只要用户尝试去点击，就会事实上点击 <code>&lt;iframe&gt;</code> 中的某个按钮，比如 <code>点赞</code> 等等。</li>
</ol>
<p>就是这么简单的攻击方式，在2009年造成了一次<a href="http://shiflett.org/blog/2009/twitter-dont-click-exploit" target="_blank" rel="noopener">小轰动</a>：在 Twitter 上突然有大量的人开始转发一条 Twiiter：</p>
<blockquote>
<p>Don’t Click: <a href="http://tinyurl.com/amgzs6" target="_blank" rel="noopener">http://tinyurl.com/amgzs6</a></p>
</blockquote>
<p>当访客点入到这个页面时，会发现这个页面里只有简单的一个按钮，上面写着 <code>Don&#39;t Click!</code>，出于好奇心，多数的访客都会尝试点一下这个按钮，而当按钮被点下去的瞬间，用户所使用的 Twitter 账号便会转发相同的一条推。</p>
<p>读者可以戳下<a href="https://javascript.info/article/clickjacking/clickjacking/" target="_blank" rel="noopener">这个例子</a>，查看页面元素感受下具体的攻击方式。</p>
<p>幸亏，浏览器为我们提供了相关机制来避免自己的站点被第三方随意嵌入。通过在页面的返回报头中设置 <code>X-Frame-Options</code>，我们可以控制自己的页面被引入的限制：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X-Frame-Options: DENY           <span class="comment"># 不允许任何站点引用</span></div><div class="line">X-Frame-Options: SAMEORIGIN     <span class="comment"># 仅允许同源站点引用</span></div><div class="line">X-Frame-Options: ALLOW-FROM https://example.com <span class="comment"># 允许某个站点引用</span></div></pre></td></tr></table></figure>
<p>比如说 <code>https://google.com</code> 就设置了同源引用的策略：</p>
<p><img src="/images/google_x_frame_options.png" alt=""></p>
<h2 id="几种使用姿势"><a href="#几种使用姿势" class="headerlink" title="几种使用姿势"></a>几种使用姿势</h2><p>尽管在设计之初，iFrame 可能只是扮演一个嵌入第三方内容的角色，但在 Web 开发的实际发展历程中，有很多功能是凭借 iFrame 实现的。</p>
<h4 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h4><p>相信很多人有使用过类似 Codepen 或者 JSFiddle 一类的在线编辑器。这类编辑器通常由两部分组成，一部分支持用户在编辑框中编写代码，另一部分实时展示用户写入代码所对应的页面。这个 “实时展示” 的部分就是采用了 <code>&lt;iframe&gt;</code> 元素，其中包裹的 HTML 页面及效果正是使用了用户编写的代码。</p>
<p>读者也许会问，用户在编辑框里编写的 HTML，CSS 和 JS 代码是如何作用于 <code>&lt;iframe&gt;</code> 的？以下以 Codepen 为例子，介绍基本的实现流程。</p>
<p><strong><em>实时更新 HTML 和 JS 代码</em></strong></p>
<p>若用户修改 HTML 或 JS 编辑框内的代码，则拼接出一段 HTML 字符串，并发起一个 POST 请求。POST 请求中还带有一个随机生成的 key：</p>
<figure><img src="/images/codepen_step_1.png"><figcaption>用户输入的 HTML 和 JS 代码都被包含在请求的 <code>html</code> 字符串中</figcaption></figure>

<p>在延迟大约半秒之后 <code>&lt;iframe&gt;</code> 元素的 <code>src</code> 值被修改为对应 key 的一个 URL 地址：</p>
<figure><img src="/images/codepen_step_2.png"><figcaption>注意 iFrame 元素的 <code>id</code> 属性，和上图请求中的 key 参数一样</figcaption></figure>

<p>此处一个合理的猜测是：服务端在接受到 POST 请求后，根据请求中的 key 值生成了一个新的文件目录，同时在该目录下新建一个名为 <code>index.html</code> 的 HTML 文件。这样 <code>&lt;iframe&gt;</code> 在刷新后，所访问的页面就正好是 POST 请求中带上的 HTML 文本。</p>
<p><strong><em>实时更新 CSS 代码</em></strong></p>
<p>若用户修改的是 CSS 代码，页面不会发起类似上述的请求，而是通过 <code>window.postMessage</code> 的方式，同 <code>&lt;iframe&gt;</code> 元素进行跨域通信。以下是 Codepen 的实现代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CSSReload = &#123;</div><div class="line">    <span class="attr">head</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>._storeHead(),</div><div class="line">        <span class="keyword">this</span>._listenToPostMessages()</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_storeHead</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_shouldHandleMessage</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> e.origin.match(<span class="regexp">/codepen/</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_listenToPostMessages</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 监听主窗口（即 Codepen 主页面）中用 window.postMessage 发出的事件</span></div><div class="line">        <span class="keyword">var</span> e = <span class="keyword">this</span>;</div><div class="line">        <span class="built_in">window</span>[<span class="keyword">this</span>._eventMethod()](<span class="keyword">this</span>._messageEvent(), <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 判断是否处理事件</span></div><div class="line">                <span class="keyword">if</span> (!e._shouldHandleMessage(t))</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                <span class="keyword">var</span> s = <span class="built_in">JSON</span>.parse(t.data);</div><div class="line">                <span class="string">"string"</span> == <span class="keyword">typeof</span> s.css &amp;&amp; e._refreshCSS(s)</div><div class="line">            &#125; <span class="keyword">catch</span> (e) &#123;&#125;</div><div class="line">        &#125;, !<span class="number">1</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_messageEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"attachEvent"</span> === <span class="keyword">this</span>._eventMethod() ? <span class="string">"onmessage"</span> : <span class="string">"message"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_eventMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.addEventListener ? <span class="string">"addEventListener"</span> : <span class="string">"attachEvent"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_refreshCSS</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="comment">// 删除 iFrame 窗口文档中原有的 &lt;style&gt; 样式</span></div><div class="line">        <span class="comment">// 插入新的 &lt;style&gt; 样式</span></div><div class="line">        <span class="keyword">var</span> t = <span class="keyword">this</span>._findPrevCPStyle()</div><div class="line">          , s = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</div><div class="line">        s.type = <span class="string">"text/css"</span>,</div><div class="line">        s.className = <span class="string">"cp-pen-styles"</span>,</div><div class="line">        s.styleSheet ? s.styleSheet.cssText = e.css : s.appendChild(<span class="built_in">document</span>.createTextNode(e.css)),</div><div class="line">        <span class="keyword">this</span>.head.appendChild(s),</div><div class="line">        t &amp;&amp; t.parentNode.removeChild(t),</div><div class="line">        <span class="string">"prefixfree"</span> === e.css_prefix &amp;&amp; StyleFix.process()</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_findPrevCPStyle</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"style"</span>), t = e.length - <span class="number">1</span>; t &gt;= <span class="number">0</span>; t--)</div><div class="line">            <span class="keyword">if</span> (<span class="string">"cp-pen-styles"</span> === e[t].className)</div><div class="line">                <span class="keyword">return</span> e[t];</div><div class="line">        <span class="keyword">return</span> !<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">CSSReload.init();</div></pre></td></tr></table></figure>
<p>可能读者会问，既然 <code>&lt;iframe&gt;</code> 窗口和主窗口都是位于同一个主域名（<code>codepen.io</code>）下，为什么不可以尝试用设置 <code>document.domain</code> 的方式，让主窗口可以直接通过 JS 操作 iFrame 呢？理论上这可能是可行的，但由于 Codepen 是全站使用 HTTPS 的（作为一个成熟的网站，你当然 <a href="https://github.com/jasonGeng88/blog/blob/master/201705/https.md" target="_blank" rel="noopener">应该</a> <a href="https://zhuanlan.zhihu.com/p/29022279" target="_blank" rel="noopener">使用</a> <a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS</a>），浏览器会禁止主窗口和 <code>&lt;iframe&gt;</code> 之间任何可能的 JS 相互调用。</p>
<h4 id="解决跨域请求问题"><a href="#解决跨域请求问题" class="headerlink" title="解决跨域请求问题"></a>解决跨域请求问题</h4><p>这个估计也是很多人初识 iFrame（或者说，实战 iFrame）的实际场景了，由于过程实在是太 hack，以及确实除了 hack 的技巧本身外并没有任何工程价值，所以我做出了一个艰难的决定：</p>
<blockquote>
<p>我不详细讨论这个问题了。</p>
</blockquote>
<p>毕竟在跨域请求方案上，早就有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">CORS</a> 和 <a href="https://zh.wikipedia.org/zh/JSONP" target="_blank" rel="noopener">JSONP</a> 了，不去使用这种成熟方案，而来纠结 iFrame 的奇技淫巧的，恕我直言都真的是浪费自己的青春…</p>
<p>有兴趣的读者可以看 SegmentFault 上的 <a href="https://segmentfault.com/a/1190000014223524#articleHeader4" target="_blank" rel="noopener">这篇文章</a>，总结的很全面了（话说 SegmentFault 是做的越来越不错了，果然好东西都要靠积累，做时间的朋友啊…）</p>
<p>或者也可以看另一篇博客：<a href="https://wangningbo93.github.io/2017/06/16/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8D%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">浅谈几种跨域的方法</a></p>
<h4 id="Comet-中的永久帧"><a href="#Comet-中的永久帧" class="headerlink" title="Comet 中的永久帧"></a>Comet 中的永久帧</h4><p><strong>Comet</strong> 一词最早是由 Alex Russell（Dojo 库的作者）在 2006 年的一篇博客 <em><a href="http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/" target="_blank" rel="noopener">Comet: Low Latency Data for the Browser</a></em>  中首先提出，描述从服务端向浏览器“推送”数据的一系列手段，包括协议和具体技术实现。</p>
<p>如果从今天的角度来回看”向服务器推送数据“这个诉求，很容易就想到 WebSocket，对吧？但事物是处于不断发展的阶段的…WebSocket 协议在 2011 年才成为标准，浏览器厂商也是在 2010~2011 年之间先后推出了支持该协议的版本。但需求，是一定要 <strong>通过各种手段</strong> 完成的，Comet 就是各种手段的一种统称，也被称为 “Ajax Push”, “Reverse Ajax”, “HTTP Server Push” 等等。</p>
<p>Comet 的实现有若干种具体的手段：</p>
<ol>
<li>长轮询（Long polling）</li>
<li>永久帧（Forever Frame）</li>
<li>XHR 流（XMLHttpRequest Streaming）</li>
</ol>
<p>这里要说的是永久帧的实现。所谓“永久帧”，是指在当前文档内创建一个 <code>&lt;iframe&gt;</code> 元素，其文档所指向的地址会返回一个 HTTP 1.1 的 <a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">trunked 编码</a> 文档。根据 trunked 编码文档的特性，服务器可以将整个文档分成多个部分发送给浏览器端。</p>
<p>通过这种方式，我们可以将 <code>&lt;iframe&gt;</code> 的文档看做是一个不断增加内容的文档，那么只需要在增量文档中生成 <code>&lt;script&gt;</code> 标签调用预定义的回调函数即可。</p>
<p>具体的实现为，首先定义一个生成永久帧的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreverFrame</span> (<span class="params">url, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</div><div class="line">  <span class="keyword">var</span> randomName = <span class="string">'callback_'</span> + (<span class="built_in">Math</span>.random() + <span class="string">''</span>).substring(<span class="number">2</span>)</div><div class="line">  iframe.style.display = <span class="string">'none'</span></div><div class="line">  iframe.src = url + <span class="string">'?callback=parent.'</span> + randomName</div><div class="line">  <span class="built_in">window</span>[randomName] = callback</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用该函数后，生成的 <code>&lt;iframe&gt;</code> 所对应的文档的返回内容为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">parent.callback_1310442051852272(<span class="string">'hello world'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">parent.callback_1310442051852272(<span class="string">'hello mars'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 不断的增加中... --&gt;</span></div></pre></td></tr></table></figure>
<p>原理上，只要 <code>&lt;iframe&gt;</code> 元素对应的 trunked 编码的文档一直在输出内容，它就可以是被视作是”永久“的，且可以保证服务端持续地向浏览器输出内容。</p>
<p>但这里也有一个明显的弊端：在 IE 和 Firefox 下，采用这样的方案会让浏览器的进度条一直显示加载中，且 IE 的 tab 图标会不断的转动，表示正在进行加载。 Google 通过采用类型为 <code>htmlfile</code> 的 ActiveXObject 的技巧来解决了这个问题。<a href="https://infrequently.org/2006/02/what-else-is-burried-down-in-the-depths-of-googles-amazing-javascript/" target="_blank" rel="noopener">传送门</a></p>
<p>关于长轮询和 XHR 流的实现，这里不做赘述，有兴趣了解详情的可以阅读 <a href="http://imweb.io/topic/565abde9823633e31839fc0e" target="_blank" rel="noopener">Comet - 服务器推送解决方案</a></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除了以上几个例子，iFrame 还可以实现无刷新文件上传，浏览器多页面间的通信，或者是音乐播放器（同一浏览器多个tab共享一个播放器）等功能，具体可以看知乎上的 <a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">这个回答</a></p>
<h2 id="Viewport-的小麻烦"><a href="#Viewport-的小麻烦" class="headerlink" title="Viewport 的小麻烦"></a>Viewport 的小麻烦</h2><p>当页面被嵌入在 <code>&lt;iframe&gt;</code> 时，页面上的某些元素的定位规则会受到相应的影响。在解释具体的影响之前，首先我们要解释一下包含块（containing block）的概念。</p>
<h4 id="containing-block"><a href="#containing-block" class="headerlink" title="containing block"></a><code>containing block</code></h4><p>对于一个元素来说，它的大小和位置通常受这个元素的 <strong>包含块</strong> 所影响。比如说，如果该元素的 <code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code> 属性的值是百分比的话，那么在计算这些值的实际大小时，将使用包含块的内容区域的宽度或者宽度来作为计算参考；如果该元素是绝对定位的元素（即 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code>），则元素的偏移属性（<code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>）的值将相对于包含块进行计算，从而直接影响元素所处的位置。</p>
<p>浏览器通过元素的 <code>position</code> 属性值，有不同地指定元素的包含块的策略，具体可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block" target="_blank" rel="noopener">MDN 的文档</a></p>
<h4 id="lt-iframe-gt-gt-Viewport"><a href="#lt-iframe-gt-gt-Viewport" class="headerlink" title="&lt;iframe&gt; =&gt; Viewport"></a><code>&lt;iframe&gt;</code> =&gt; Viewport</h4><p>我们需要说明的是：<code>&lt;iframe&gt;</code> 元素事实上创建了一个新的 Viewport。根据 <a href="https://www.w3.org/TR/CSS21/visudet.html#containing-block-details" target="_blank" rel="noopener">CSS2.1 的规范</a>：</p>
<blockquote>
<p>The containing block in which the root element lives is a rectangle called the <strong>initial containing block</strong>. For continuous media, it has the dimensions of the viewport and is anchored at the canvas origin…</p>
</blockquote>
<p>从这段说明中我们可以得到两个结论：</p>
<ol>
<li>文档的根元素（<code>&lt;html&gt;</code>）就是该文档的初始化包含块（initial containing block）</li>
<li>同时这个元素关联一个 Viewport</li>
</ol>
<p>而 <a href="https://www.w3.org/TR/CSS21/visuren.html#viewport" target="_blank" rel="noopener">关于 Viewport 的规范</a> 则有：</p>
<blockquote>
<p>Useragents for continuous media generally offer users a <strong>viewport</strong> (a window or other viewing area on the screen) through which users consult a document. User agents may change the document’s layout when the viewport is resized (see the initial containing block)</p>
</blockquote>
<p>我们可以简单的将 Viewport 理解为用户查看文档的一个窗口。而对于 <code>&lt;iframe&gt;</code> 这样的嵌入文档，根据规范的说法，这事实上创建了一个新的 Viewport，且由于出现了一个新的文档对象，自然有其独立的初始化包含块（initial containing block）。</p>
<p>P.S：关于 Viewport 的详细介绍，可以查看学弟 @Mactavish 写的 <a href="https://macsalvation.net/2018/05/23/dive-into-viewport/" target="_blank" rel="noopener">这篇文章</a></p>
<p>有了这样的理论基础，我们来看看两个特殊的元素定位问题。</p>
<h4 id="position-fixed"><a href="#position-fixed" class="headerlink" title="position: fixed"></a><code>position: fixed</code></h4><p>相信很多写过自定义弹窗或者 Modal 组件的同学，都会使用 <code>position:fixed</code> 配合相应的偏移属性来实现相对于可视窗口的绝对居中效果。</p>
<p>但如果弹窗的元素是在一个 <code>&lt;iframe&gt;</code> 中，而该 <code>&lt;iframe&gt;</code> 元素又恰好只占用了父文档其中一部分的空间，那么实际上这个弹窗的居中效果是相对于 <code>&lt;iframe&gt;</code> 元素的，比如以下的这个例子，虽然黄色区块已经被设置成了 <code>position: fixed</code>，但显然其显示的位置不会在当前整个页面的正中央。</p>
<p></p><p data-height="320" data-theme-id="0" data-slug-hash="XBpqqv" data-default-tab="css,result" data-user="allenfantasy1018" data-embed-version="2" data-pen-title="XBpqqv" class="codepen">See the Pen <a href="https://codepen.io/allenfantasy1018/pen/XBpqqv/" target="_blank" rel="noopener">XBpqqv</a> by Zeqiu Wu (<a href="https://codepen.io/allenfantasy1018" target="_blank" rel="noopener">@allenfantasy1018</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>（当然，像上述例子的情况实际上是一个双重嵌套 iframe，读者可以打开 devtool 自己查看）</p>
<p>当然，这样的设定是浏览器有意为之的，所以如果确实有必要希望弹窗的位置在整个浏览器窗口的正中间，开发者需要使用 JS 的手段实现，具体做法可以参考 Andy Langton 的 <a href="https://andylangton.co.uk/blog/development/get-viewportwindow-size-width-and-height-javascript" target="_blank" rel="noopener">这篇博客</a></p>
<h4 id="Viewport-percentage-length"><a href="#Viewport-percentage-length" class="headerlink" title="Viewport-percentage length"></a>Viewport-percentage length</h4><p>顾名思义，<strong>Viewport-percentage length</strong> 指和当前 Viewport 相关的长度单位，如 <code>vw</code>, <code>vh</code>, <code>vmin</code>, <code>vmax</code>。根据 <a href="https://www.w3.org/TR/css-values/#viewport-relative-lengths" target="_blank" rel="noopener">CSS 规范</a> 的说法：</p>
<blockquote>
<p>The <em>viewport-percentage lengths</em> are relative to the size of the <strong>initial containing block</strong>. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>
</blockquote>
<p>呵！原来 <code>vh</code> 和 <code>vw</code> 的计算参考系并不是当前浏览器的窗口大小，而是初始化包含块的高度和宽度，那么问题来了：由于 <code>&lt;iframe&gt;</code> 的独立文档会有单独的初始化包含块（就是其文档的 <code>&lt;html&gt;</code> 元素），也就是说：</p>
<p>在 <code>&lt;iframe&gt;</code> 文档中的元素，其 <code>vw</code> 和 <code>vh</code> 等长度单位的计算是相对于 <code>&lt;iframe&gt;</code> 元素的。<a href="https://stackoverflow.com/questions/34057239/css-vh-units-inside-an-iframe/44634369#44634369" target="_blank" rel="noopener">StackOverflow</a> 上也有人就这个问题做了详细的解答。</p>
<h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><p>嗯！这就是所有关于 <code>&lt;iframe&gt;</code> 要讨论的内容了，让我们来简单的回顾一下：</p>
<ul>
<li>一个 iFrame 对应一个独立的浏览上下文（Browsing Context）</li>
<li>iFrame 是出于嵌套第三方页面以丰富页面内容展示的需要而出现的，但围绕它可以实现许多特殊的功能</li>
<li>浏览器通过同源策略避免 iFrame 和主页面间的互相直接调用，但可以利用 <code>window.postMessage</code> 来让 iFrame 和主页面间进行通讯</li>
<li>可以通过 <code>X-Frame-Options</code> 控制页面被嵌套的策略</li>
<li>iFrame 页面元素的样式需要注意相对于 Viewport 的处理</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Browsing_context" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Glossary/Browsing_context</a></li>
<li><a href="https://html.spec.whatwg.org/multipage/browsers.html#windows" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/browsers.html#windows</a></li>
<li><a href="http://w3c.github.io/html/browsers.html#sec-browsing-contexts" target="_blank" rel="noopener">http://w3c.github.io/html/browsers.html#sec-browsing-contexts</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dn705664(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dn705664(v=vs.85).aspx</a></li>
<li><a href="http://netsekure.org/2015/12/06/chromium-internals-documents-windows-browsing-contexts/" target="_blank" rel="noopener">http://netsekure.org/2015/12/06/chromium-internals-documents-windows-browsing-contexts/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frameset" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frameset</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies</a></li>
<li><a href="https://en.wikipedia.org/wiki/HTML_element" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HTML_element</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sandbox_(computer_security)</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security</a></li>
<li><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/WebSocket</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/HSTS" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Glossary/HSTS</a></li>
<li><a href="https://javascript.info/clickjacking" target="_blank" rel="noopener">https://javascript.info/clickjacking</a></li>
<li><a href="https://blog.mozilla.org/security/2013/12/12/on-the-x-frame-options-security-header/" target="_blank" rel="noopener">https://blog.mozilla.org/security/2013/12/12/on-the-x-frame-options-security-header/</a></li>
<li><a href="https://heycam.github.io/webidl/" target="_blank" rel="noopener">https://heycam.github.io/webidl/</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/#N10101" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/wa-lo-comet/#N10101</a></li>
<li><a href="http://imweb.io/topic/565abde9823633e31839fc0e" target="_blank" rel="noopener">http://imweb.io/topic/565abde9823633e31839fc0e</a></li>
<li><a href="https://segmentfault.com/a/1190000014223524" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014223524</a></li>
<li><a href="http://www.fedlab.tech/archives/395.html" target="_blank" rel="noopener">http://www.fedlab.tech/archives/395.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Comet_(programming\)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comet_(programming)</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2018/07/21/what-i-am-thinking-before-asking-questions/" class="prev">上一篇</a><a href="/2018/05/25/cssconf-note-scalable-comp/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
    this.page.url = 'http://afantasy.ninja/2018/07/15/dive-into-iframe/';
    // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = '2018/07/15/dive-into-iframe/';
    // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://afantasy-ninja.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the<a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><script id="dsq-count-scr" src="//afantasy-ninja.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2018 <a href="http://afantasy.ninja">Allen</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://s22.cnzz.com/z_stat.php?id=1261988857&amp;web_id=1261988857"></script><script>document.querySelector('[title="站长统计"]').style.display = 'none'</script></body></html>