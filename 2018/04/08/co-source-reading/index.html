<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> co 源码分析 · A Fantasy Ninja</title><meta name="description" content="co 源码分析 - Allen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/allenfantasy" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">co 源码分析</h1><div class="post-meta"><span class="post-time">2018年4月8日</span><span class="taglist"><a href="/tags/JavaScript" class="tag">JavaScript</a></span></div><div class="post-content"><p>心血来潮看了下 co 的代码，两百来行并不算多，简单的做个分析。</p>
<a id="more"></a>
<h3 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h3><p>对于没时间看详解的同学，只需要知道这个事实：</p>
<blockquote>
<p>co 遍历执行一个 generator 函数，并返回了一个 Promise 对象，在 generator 函数执行结束后返回的 Promise 对象的状态将变成 <code>resolved</code>。</p>
</blockquote>
<p>以及：</p>
<blockquote>
<p>Promise 链中，当链中反复在 <code>.then()</code> 方法中返回新的 Promise 对象，且最外围的 Promise 的状态一直保持在 <code>pending</code> 时，会造成内存泄漏的问题。</p>
</blockquote>
<p>又及：</p>
<blockquote>
<p>没事不要乱看规范…真的够烧脑的…2333</p>
</blockquote>
<h3 id="brief"><a href="#brief" class="headerlink" title="brief"></a>brief</h3><p>实际上 co 的代码早已不是寥寥几行了（可能一开始是），但通篇下来其实也就是两百多行的代码，但功能上已经非常完备了。</p>
<p>co 具体做的事情：</p>
<ol>
<li>接受一个 generator 作为输入，输出一个 Promise 对象</li>
<li>遍历整个 generator（即不断的调用 next）<ul>
<li>在遍历结束时（即 next 返回的对象 <code>done: false</code>）进行 resolve，resolve 所持有的值是最后一个 next 输出的 <code>value</code></li>
<li>在遍历过程中出现错误则 reject</li>
</ul>
</li>
<li>仅支持 generator 函数中 yield 非空对象（不支持 primitive types 如 number, string 等），具体查看 co 文档中 <a href="https://github.com/tj/co#yieldables" target="_blank" rel="noopener">Yieldables</a> 部分</li>
</ol>
<p>来看看核心代码（省去了一些无关的注释，实际核心代码只有几十行）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// co.wrap 的实现（这个我们待会再说）</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  </div><div class="line">  <span class="comment">// 一开始就返回一个 Promise 对象</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果输入是一个 GeneratorFunction，则先得到其执行后的 Generator 对象</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">    <span class="comment">// 如果 gen 不是一个 Generator，则 Promise 的状态变成 fulfilled，并将 gen 作为返回值</span></div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"></div><div class="line">    <span class="comment">// 启动遍历 Generator 的过程</span></div><div class="line">    onFulfilled();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 获取 Generator 中下一个值</span></div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="comment">// 在执行过程中出现任何错误, 都直接让外围 Promise 的状态变成 rejected</span></div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 退出 Generator, 并让外围的 Promise 的状态变成 rejected</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.throw(err);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这个是 co 中最关键的函数</span></div><div class="line">    <span class="comment">// 接收一个 Generator 遍历出来的值 &#123; value, done &#125;</span></div><div class="line">    <span class="comment">// 并将 value 作为下一个 .next() 方法的输入</span></div><div class="line">    <span class="comment">// 这里造成的效果是, yield 语句后面跟着的值(即 value)会成为上一个 yield 语句的返回值</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">      <span class="comment">// 封装成 Promise</span></div><div class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">      <span class="comment">// 继续进行 Generator 的遍历</span></div><div class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">      </div><div class="line">      <span class="comment">// 如果 value 的值的类型不是 Function/Promise/Generator/GeneratorFunction/Array/Object 的话</span></div><div class="line">      <span class="comment">// 则中断整个 Generator 并让 Promise 状态为 rejected</span></div><div class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将输入封装成 Promise</span></div><div class="line"><span class="comment">// 如果输入类型不符, 则返回原类型(返回值肯定不是一个 Promise)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//=== 以下省略 thunkToPromise, arrayToPromise, objectToPromise 的实现</span></div></pre></td></tr></table></figure>
<p>co 的实现的流程：</p>
<ol>
<li>整个函数返回一个 Promise 对象</li>
<li>将调用 <code>Generator.next</code> 的操作封装在一个函数 onFulfilled 中</li>
<li>将每次 <code>next</code> 返回的值封装成一个新的 Promise 对象，并在其状态变成 <code>fulfilled</code> 时调用 onFulfilled，让 Generator 函数继续执行</li>
<li>当本次 <code>next</code> 返回的 <code>done: true</code> 时，将要返回的 Promise 状态变为 <code>fulfilled</code>，将当前的 value 的值作为 Promise 所持有的值</li>
<li>在出现以下情况时，将要返回的 Promise 的状态变为 <code>rejected</code>：<ol>
<li>Generator 函数执行过程中抛出任何错误</li>
<li>某个 <code>yield</code> 语句中如果有 Promise 对象，而该 Promise 对象的状态为 <code>rejected</code></li>
<li>某个 <code>yield</code> 语句中的值的类型不是 Function/Promise/Generator/GeneratorFunction/Array/Object</li>
</ol>
</li>
</ol>
<p><strong>TODO</strong> 这里的 5.3 是一个令我很不解的地方，为什么要对 yield 关键字后面跟着的值的类型做要求呢？</p>
<p>然后我们再来看 <code>co.wrap</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Wrap the given generator `fn` into a</div><div class="line"> * function that returns a promise.</div><div class="line"> * This is a separate function so that</div><div class="line"> * every `co()` call doesn't create a new,</div><div class="line"> * unnecessary closure.</div><div class="line"> *</div><div class="line"> * @param &#123;GeneratorFunction&#125; fn</div><div class="line"> * @return &#123;Function&#125;</div><div class="line"> * @api public</div><div class="line"> */</div><div class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  createPromise.__generatorFunction__ = fn;</div><div class="line">  <span class="keyword">return</span> createPromise;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>co.wrap</code> 做的事情是：接受一个 <code>[GeneratorFunction]</code> 函数对象，返回一个 “临时函数” —— 这个 “临时函数” 可以在任何时间被执行并返回一个 Promise：</p>
<blockquote>
<p>  Convert a generator into a regular function that returns a <code>Promise</code>.</p>
</blockquote>
<p>这看上去似乎有些令人摸不着头脑，但正是这个方法构成了 <code>koa</code> 1.x 中处理 middleware 的基础。有兴趣的同学可以看这里的代码：</p>
<ol>
<li><code>koa-compose</code> 中的 compose 方法: <a href="https://github.com/koajs/compose/blob/master/index.js" target="_blank" rel="noopener">https://github.com/koajs/compose/blob/master/index.js</a></li>
<li><code>co.wrap</code> in <code>app.callback</code> in <code>application.js</code> <a href="https://github.com/koajs/koa/blob/v1.x/lib/application.js#L127" target="_blank" rel="noopener">https://github.com/koajs/koa/blob/v1.x/lib/application.js#L127</a></li>
</ol>
<h3 id="Promise-memory-leak"><a href="#Promise-memory-leak" class="headerlink" title="Promise memory leak?"></a>Promise memory leak?</h3><p>在阅读源码过程中，我发现了一段很有趣的注释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="comment">//...省略代码</span></div><div class="line">  </div><div class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></div><div class="line">  <span class="comment">// which leads to memory leak errors.</span></div><div class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></div><div class="line"></div><div class="line">  <span class="comment">//...省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是我查看了一下<a href="https://github.com/tj/co/issues/180" target="_blank" rel="noopener">这个 issue</a>，提出 issue 的人认为 co 在某些情况下可能会造成内存泄漏，而具体使用的情况与 Promise 有关。</p>
<p>这个 issue 已经<a href="https://github.com/tj/co/issues/180#issuecomment-68094905" target="_blank" rel="noopener">被修复</a>，具体做法是使用一个 Promise 实例，在所有需要变更状态的情况下都调用该实例所对应的 <code>resolve</code> 和 <code>reject</code> 方法。但我产生了一个新的疑问，就是为什么这样改就可以修复 co 的内存泄漏问题呢？于是我决定继续研究这个 issue。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span> (<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="comment">// blah...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">     <span class="comment">// 在后续的代码中直接调用 resolve 和 reject 方法</span></div><div class="line">     <span class="comment">// 不采用 Promise.resolve, Promise.reject</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个 issue 中，首先有人提出了一段测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        setTimeout(resolve, <span class="number">1</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; ++i) &#123;</div><div class="line">        <span class="keyword">yield</span> sleep();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> === <span class="number">0</span>) &#123;</div><div class="line">            global.gc();</div><div class="line">            <span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'finished'</span>)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'caught error: '</span>, err.stack);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行这段代码可以观察到明显的内存泄漏的情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123; rss: 17420288, heapTotal: 9620736, heapUsed: 3590768 &#125;</div><div class="line">&#123; rss: 44822528, heapTotal: 49288192, heapUsed: 12972200 &#125;</div><div class="line">&#123; rss: 70955008, heapTotal: 58575616, heapUsed: 21688912 &#125;</div><div class="line">&#123; rss: 80048128, heapTotal: 66831104, heapUsed: 30531560 &#125;</div><div class="line">&#123; rss: 89157632, heapTotal: 76118528, heapUsed: 39490184 &#125;</div><div class="line">&#123; rss: 98275328, heapTotal: 85405952, heapUsed: 48445040 &#125;</div><div class="line">&#123; rss: 107368448, heapTotal: 93661440, heapUsed: 57410024 &#125;</div><div class="line">&#123; rss: 116477952, heapTotal: 102948864, heapUsed: 66365712 &#125;</div><div class="line">&#123; rss: 125591552, heapTotal: 112236288, heapUsed: 75330040 &#125;</div><div class="line">&#123; rss: 134684672, heapTotal: 120491776, heapUsed: 84285144 &#125;</div><div class="line">&#123; rss: 143798272, heapTotal: 129779200, heapUsed: 93250072 &#125;</div><div class="line">&#123; rss: 152907776, heapTotal: 139066624, heapUsed: 102205152 &#125;</div><div class="line">&#123; rss: 162000896, heapTotal: 147322112, heapUsed: 111170352 &#125;</div><div class="line">&#123; rss: 171114496, heapTotal: 156609536, heapUsed: 120125032 &#125;</div></pre></td></tr></table></figure>
<p>而 @fengmk2 利用 <code>heapdump</code> 将内存泄漏的原因 <a href="https://github.com/tj/co/issues/180#issuecomment-68022246" target="_blank" rel="noopener">锁定在了 Promise 上</a>，项目维护者 @jonathanong 也提出了一个和 co 无关的<a href="https://github.com/tj/co/issues/180#issuecomment-68094905" target="_blank" rel="noopener">测试用例</a>来说明 Promise 的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">next()</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">    i++</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">100000</span> === <span class="number">0</span>) &#123;</div><div class="line">      global.gc();</div><div class="line">      <span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line">    &#125;</div><div class="line">    setImmediate(resolve)</div><div class="line">  &#125;).then(next)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123; rss: 142749696, heapTotal: 128759296, heapUsed: 93098624 &#125;</div><div class="line">&#123; rss: 234614784, heapTotal: 218537728, heapUsed: 182771736 &#125;</div><div class="line">&#123; rss: 325664768, heapTotal: 308316160, heapUsed: 272393200 &#125;</div><div class="line">&#123; rss: 416694272, heapTotal: 397062656, heapUsed: 361990640 &#125;</div><div class="line">&#123; rss: 507744256, heapTotal: 486841088, heapUsed: 451476544 &#125;</div><div class="line">&#123; rss: 598794240, heapTotal: 576619520, heapUsed: 541064768 &#125;</div><div class="line">&#123; rss: 688660480, heapTotal: 666397952, heapUsed: 630666888 &#125;</div><div class="line">&#123; rss: 779710464, heapTotal: 756176384, heapUsed: 720264424 &#125;</div><div class="line">&#123; rss: 870760448, heapTotal: 845954816, heapUsed: 809866824 &#125;</div><div class="line">&#123; rss: 961794048, heapTotal: 934701312, heapUsed: 899464696 &#125;</div><div class="line">&#123; rss: 1052844032, heapTotal: 1024479744, heapUsed: 989066688 &#125;</div><div class="line">&#123; rss: 1143898112, heapTotal: 1114258176, heapUsed: 1078667208 &#125;</div><div class="line">&#123; rss: 1234948096, heapTotal: 1204036608, heapUsed: 1168269624 &#125;</div><div class="line">&#123; rss: 1325998080, heapTotal: 1293815040, heapUsed: 1257867232 &#125;</div><div class="line">&#123; rss: 1417052160, heapTotal: 1383593472, heapUsed: 1347469472 &#125;</div></pre></td></tr></table></figure>
<p>在这个 issue 得到修复之后，后续的讨论集中到了 Promise 实现的问题上…</p>
<p>首先是 co 的维护者 @jonathanong 在 Promise A+ 规范上提了 issue: <a href="https://github.com/promises-aplus/promises-spec/issues/179" target="_blank" rel="noopener">chain of never resolved promises create memory leaks</a>，随后贺老 @hax 也提出了<a href="https://github.com/promises-aplus/promises-spec/issues/183" target="_blank" rel="noopener">对规范的疑问</a>，认为控制内存泄漏和控制 Promise 执行顺序之间是无法同时满足的。</p>
<p>在第一个 issue 中，bluebird 的作者 @petkaantonov <a href="https://github.com/promises-aplus/promises-spec/issues/179#issuecomment-68209678" target="_blank" rel="noopener">提到</a>:</p>
<blockquote>
<p>  Well the whole 2.3.2 needs to be redone.</p>
<p>  As far as I can tell we both fixed the memory leak in our implementation by turning <code>promise</code> into a proxy for <code>x</code>: any operation performed on <code>promise</code> will be redirected to <code>x</code>. Any operation already performed on <code>promise</code> are immediately redirected to <code>x</code> (which is possible because both must still be pending at this point).</p>
<p>  This is different from what the spec currently says, <code>promise</code> is now never pending, fulfilled or rejected, it doesn’t have its own state at all. If it had, that means <code>x</code> would need to inform <code>promise</code> when it changed state so that <code>promise</code> can change its state and that means <code>x</code> holding reference to <code>promise</code> which leads to the original leak.</p>
</blockquote>
<p>简单翻译一下：</p>
<blockquote>
<p>  （Promise A+ 规范中的）整个 2.3.2 都需要重新设计。</p>
<p>  据我所知我们（译者注：指的是 <code>then</code> 和 <code>bluebird</code> 的作者）都在我们各自的实现中将 <code>promise</code> 变成了 <code>x</code> 的一个 proxy: 任何对 <code>promise</code> 的操作都会重定向到 <code>x</code>。任何已经在 <code>promise</code> 上进行的操作（译者注：根据 Promise 的规范，<code>promise</code> 必须等待 <code>x</code> 的状态确定之后才知道自己的状态，所以对 <code>promise</code> 的操作如 <code>then</code> 等都必须要等待 <code>x</code> 的状态确定之后才可以调用，所以这里有一个 “延迟” 的情况）会立刻重定向到 <code>x</code> 上（这是可能的，因为在这时两个 promise 对象的状态都是 pending 的。</p>
<p>  这和当前规范中的说法不一致，<code>promise</code> 现在（的状态）永远不会是 pending, fulfilled 或者是 rejected，它根本就没有自己的状态。如果它有的话，那就意味着 <code>x</code> 必须在状态改变时通知 <code>promise</code> ，这样 <code>promise</code> 才可以修改它自身的状态，这就意味着 <code>x</code> 必须要保留对 <code>promise</code> 的引用，这样就导致了最初的（内存）泄漏。</p>
</blockquote>
<p>@petkaantonov 提出：<a href="https://github.com/then/promise/pull/67" target="_blank" rel="noopener">then</a> 和 <a href="https://github.com/petkaantonov/bluebird/commit/8c1edaf0a77a6d46a7527b2873e456d3ff62fab8" target="_blank" rel="noopener">bluebird</a> 的实现都规避了内存泄漏的问题，但实际的做法与 Promise A+ 规范有冲突。</p>
<p>为了彻底理解上述说法，我们需要研究一下 Promise A+ 规范。</p>
<p><strong>Promise A+ spec, 2.3.2:</strong></p>
<p><em><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+ 标准</a></em> 中对于 <code>then</code> 方法有以下规定：</p>
<blockquote>
<p>…<br>2.2.7 <code>then</code> must return a promise [3.3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise2 = promise1.then(onFulfilled, onRejected);</div></pre></td></tr></table></figure></p>
<p>  2.2.7.1 If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code><br>  …<br>  …<br>  2.3 The Promise Resolution Procedure<br>  The <strong>promise resolution procedure</strong> is an abstract operation taking as input a promise and a value, which we donate as <code>[[Resolve]](promise, x)</code>. If <code>x</code> is a thenable, it attempts to make <code>promise</code> adopt the state of <code>x</code>, under the assumption that <code>x</code> behaves at least somewhat like a promise. Otherwise, it fulfills <code>promise</code> with the value <code>x</code>.<br>  …<br>  2.3.2 If <code>x</code> is a promise, adopt its state [3.4]:<br>  2.3.2.1 If <code>x</code> is pending, <code>promise</code> must remain pending until <code>x</code> is fulfilled or rejected.<br>  2.3.2.2 If/when <code>x</code> is fulfilled, fulfill <code>promise</code> with the same value.<br>  2.3.2.3 If/when <code>x</code> is rejected, reject <code>promise</code> with the same reason.<br>  …..</p>
</blockquote>
<p>这里我尝试翻译一下：</p>
<blockquote>
<p>  …</p>
<p>  2.2.7 <code>then</code> 必须返回一个 Promise 对象 [3.3]</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise2 = promise1.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<blockquote>
<p>  2.2.7.1 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 x，则运行下面的 <strong>Promise 解析过程</strong>: <code>[[Resolve]](promise2, x)</code></p>
<p>  …</p>
<p>  …</p>
<p>  2.3 Promise 解析过程</p>
<p>  <strong>Promise 解析过程</strong> 是一个抽象的操作，其需输入一个 Promise 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 是一个 Thenable（注：持有 <code>then</code> 方法的对象），解析过程尝试去让 <code>promise</code> 接受 <code>x</code> 的状态，基于以下假设：<code>x</code> 的表现至少有某些部分像是一个 Promise；否则，解析过程将让 <code>promise</code> 的值变成 <code>fulfilled</code> 且采用 x 的值。</p>
<p>  …</p>
<p>  2.3.2 如果 <code>x</code> 是一个 Promise，则使 <code>promise</code> 接受 <code>x</code> 的状态 [3.4]</p>
<p>  2.3.2.1 如果 <code>x</code> 状态为 <code>pending</code>，则 <code>promise</code> 也将保持为 <code>pending</code> 直到 <code>x</code> 状态变成 <code>fulfilled</code> 或者是 <code>rejected</code></p>
<p>  2.3.2.2 如果/当 <code>x</code> 状态为 <code>fulfilled</code>，则 <code>promise</code> 状态也为 <code>fulfilled</code> 且持有的值与 <code>x</code> 相同</p>
<p>  2.3.2.3 如果/当 <code>x</code> 状态为 <code>rejected</code>，则 <code>promise</code> 状态也为 <code>rejected</code> 且理由(reason) 与 <code>x</code> 相同</p>
</blockquote>
<p>我们再来重新看 bluebird 作者的原话，就不难理解 Promise A+ 规范的问题是什么了：</p>
<blockquote>
<p>  这和当前规范中的说法不一致，<code>promise</code> 现在（的状态）永远不会是 pending, fulfilled 或者是 rejected，它根本就没有自己的状态。如果它有的话，那就意味着 <code>x</code> 必须在状态改变时通知 <code>promise</code> ，这样 <code>promise</code> 才可以修改它自身的状态，<strong>这就意味着 <code>x</code> 必须要保留对 <code>promise</code> 的引用，这样就导致了最初的（内存）泄漏。</strong></p>
</blockquote>
<h4 id="所以，co-是怎么修复内存泄露的？"><a href="#所以，co-是怎么修复内存泄露的？" class="headerlink" title="所以，co 是怎么修复内存泄露的？"></a>所以，co 是怎么修复内存泄露的？</h4><p>回到最初提出的关于 co 的问题，通过 <a href="https://github.com/tj/co/pull/182/files" target="_blank" rel="noopener">diff</a> 我们可以看到，修复的关键在于修改 <code>onFulfilled</code> 和 <code>onRejected</code> 两个方法，让它们不要返回一个新的 Promise，这样就不会触发 Promise 解析过程，也就规避掉了刚才提到的内存泄漏的问题。</p>
<h4 id="Promise-Order"><a href="#Promise-Order" class="headerlink" title="Promise Order ??"></a>Promise Order ??</h4><p>在 <a href="https://github.com/promises-aplus/promises-spec/issues/179#issuecomment-68213192" target="_blank" rel="noopener">promise A+ 规范的 issue</a> 中，@petkaantonov 提出了一个很有趣的例子，然而我没有看懂…我们来看这段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resolveA</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// resolveA = resolve</span></div><div class="line">  resolveA = <span class="built_in">arguments</span>[<span class="number">0</span>]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">a.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'first'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> resolveB</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// resolveB = resolve</span></div><div class="line">  resolveB = <span class="built_in">arguments</span>[<span class="number">0</span>]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">b.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'second'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">resolveA(b)</div><div class="line"></div><div class="line">b.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'third'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">resolveB()</div></pre></td></tr></table></figure>
<p>这段代码的输出顺序应该是？</p>
<p>bluebird 作者 <code>@petanntonov</code> 的结论是:</p>
<blockquote>
<p>遵循规范实践的版本(before fix) 和 Q 的实践中, 以上代码的顺序是 second, third, first<br>而 bluebird 修复 memory leak 问题之后的执行顺序是 second, first, third</p>
</blockquote>
<p>然而我想了很久也不是特别明白这里的处理方式…</p>
<h4 id="原生-Promise-实现"><a href="#原生-Promise-实现" class="headerlink" title="原生 Promise 实现?"></a>原生 Promise 实现?</h4><p>我们现在知道，在 Node 及浏览器未能支持 Promise 规范的情况下，根据 Promise A+ 标准实现的第三方 Promise 库，可能会出现内存泄漏。使用 co 的 issue#180 中的<a href="https://github.com/tj/co/issues/180#issue-52777951" target="_blank" rel="noopener">测试代码</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        setTimeout(resolve, <span class="number">1</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; ++i) &#123;</div><div class="line">        <span class="keyword">yield</span> sleep();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> === <span class="number">0</span>) &#123;</div><div class="line">            global.gc();</div><div class="line">            <span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'finished'</span>)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'caught error: '</span>, err.stack);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 Node v8.5.0 环境下测试（执行时需要启用 gc 的选项：<code>node —expose-gc test.js</code>）结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123; rss: 22249472, heapTotal: 10485760, heapUsed: 4095864, external: 13316 &#125;</div><div class="line">&#123; rss: 28135424, heapTotal: 11010048, heapUsed: 4547568, external: 8224 &#125;</div><div class="line">&#123; rss: 28520448, heapTotal: 11010048, heapUsed: 4573504, external: 8224 &#125;</div><div class="line">&#123; rss: 28835840, heapTotal: 11010048, heapUsed: 4540072, external: 8224 &#125;</div><div class="line">&#123; rss: 28966912, heapTotal: 11010048, heapUsed: 4547504, external: 8224 &#125;</div><div class="line">&#123; rss: 29106176, heapTotal: 11534336, heapUsed: 4543120, external: 8224 &#125;</div><div class="line">&#123; rss: 29138944, heapTotal: 11534336, heapUsed: 4550552, external: 8224 &#125;</div><div class="line">&#123; rss: 29282304, heapTotal: 11534336, heapUsed: 4545632, external: 8224 &#125;</div><div class="line">&#123; rss: 29351936, heapTotal: 11534336, heapUsed: 4553064, external: 8224 &#125;</div></pre></td></tr></table></figure>
<p>测试代码使用了 <code>process.memoryUsage()</code> 方法来获得当前 Node 环境下内存使用情况：</p>
<ul>
<li><code>heapTotal</code> 和 <code>heapUsed</code> 指的是 V8 的内存使用情况，其中 <code>heapUsed</code> 指程序执行过程中实际使用的内存</li>
<li><code>external</code> 指 V8 管理的 JS 对象所绑定的 C++ 对象所使用的内存大小</li>
<li><code>rss</code>（Resident Set Size，驻留集）指的是主内存设备（main memory device）所占用的内存空间，其中包括了堆，代码片段和栈调用。</li>
</ul>
<p>可以看到 <code>heapUsed</code> 并没有明显的增长（从第二行日志开始一直维持在 455w 左右波动，并没有明显的递增趋势），那是否意味着 Node 中 Promise 的实现没有问题呢？</p>
<p>由于代码中使用了 co，所以我们需要排除掉 co 的影响，于是使用第二个测试例子，这个例子没有用到 co，是一个纯 Promise 的测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">next()</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">    i++</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">100000</span> === <span class="number">0</span>) &#123;</div><div class="line">      global.gc();</div><div class="line">      <span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line">    &#125;</div><div class="line">    setImmediate(resolve)</div><div class="line">  &#125;).then(next)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码的思路很清楚，就是通过递归的方式，实现一个 Promise 链：每一个新建的 Promise 对象的 <code>.then</code> 调用中，回调函数里总是会返回一个新的 Promise，这就重现了 Promise A+ 规范中 2.2.7 和 2.3.2 的情况：</p>
<blockquote>
<p>  2.2.7 <code>then</code> must return a Promise [3.3]</p>
<p>  2.2.7.1 If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code></p>
<p>  2.3.2 If <code>x</code> is a promise, adopt its state [3.4]:</p>
</blockquote>
<p>其运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123; rss: 94011392, heapTotal: 79167488, heapUsed: 44926712, external: 8224 &#125;</div><div class="line">&#123; rss: 132673536, heapTotal: 119013376, heapUsed: 86040960, external: 8224 &#125;</div><div class="line">&#123; rss: 181956608, heapTotal: 164102144, heapUsed: 126798032, external: 8224 &#125;</div><div class="line">&#123; rss: 220876800, heapTotal: 202899456, heapUsed: 167640600, external: 8224 &#125;</div><div class="line">&#123; rss: 257863680, heapTotal: 243793920, heapUsed: 208447880, external: 8224 &#125;</div><div class="line">&#123; rss: 303140864, heapTotal: 285212672, heapUsed: 249248816, external: 8224 &#125;</div><div class="line">&#123; rss: 344813568, heapTotal: 326631424, heapUsed: 290051784, external: 8224 &#125;</div><div class="line">&#123; rss: 386400256, heapTotal: 368050176, heapUsed: 330850536, external: 8224 &#125;</div><div class="line">&#123; rss: 432185344, heapTotal: 413663232, heapUsed: 371600120, external: 8224 &#125;</div><div class="line">&#123; rss: 470716416, heapTotal: 451936256, heapUsed: 412433776, external: 8224 &#125;</div><div class="line">&#123; rss: 511557632, heapTotal: 492830720, heapUsed: 453250368, external: 8224 &#125;</div></pre></td></tr></table></figure>
<p>看来，似乎目前 Node v8.5.0 版本内对 Promise 的实现仍然会存在这个问题。嗯，看来编码中要注意了……</p>
<h3 id="更多研究"><a href="#更多研究" class="headerlink" title="更多研究"></a>更多研究</h3><p>哼哧哼哧写完之后才发现，早有人很详细的研究了这个问题，惭愧哪……</p>
<ul>
<li>Maya 大神写的关于 Promise 链的详细研究（太长了，暂时看不动）：<a href="https://github.com/xieranmaya/blog/issues/5" target="_blank" rel="noopener">https://github.com/xieranmaya/blog/issues/5</a></li>
<li>关于 Promise 内存泄漏的问题 by 腾讯 AlloyTeam <a href="http://www.alloyteam.com/2015/05/memory-leak-caused-by-promise/" target="_blank" rel="noopener">http://www.alloyteam.com/2015/05/memory-leak-caused-by-promise/</a></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://github.com/tj/co" target="_blank" rel="noopener">tj/co, The ultimate generator based flow-control goodness for node.js</a></li>
<li><a href="https://github.com/tj/co/issues/180#issuecomment-68094905" target="_blank" rel="noopener">Aggressive Memory Leak, tj/co</a></li>
<li><a href="https://github.com/promises-aplus/promises-spec/issues/179" target="_blank" rel="noopener">chain of never resolved promises create memory leaks, promises-aplus/promises-spec</a></li>
<li><a href="https://github.com/promises-aplus/promises-spec/issues/183" target="_blank" rel="noopener">Which behavior is correct? </a></li>
<li><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+</a></li>
<li><a href="https://segmentfault.com/a/1190000002452115" target="_blank" rel="noopener">Promise A+ 规范中文翻译</a></li>
<li><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">「翻译」Promises/A+ 规范</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator 函数的语法, ECMAScript6 入门 by 阮一峰</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2018/05/11/translation-the-tc39-process/" class="prev">上一篇</a><a href="/2018/01/13/speculative-parsing-async-defer-perload/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
    this.page.url = 'http://afantasy.ninja/2018/04/08/co-source-reading/';
    // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = '2018/04/08/co-source-reading/';
    // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://afantasy-ninja.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the<a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><script id="dsq-count-scr" src="//afantasy-ninja.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="http://afantasy.ninja">Allen</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://s22.cnzz.com/z_stat.php?id=1261988857&amp;web_id=1261988857"></script><script>document.querySelector('[title="站长统计"]').style.display = 'none'</script></body></html>