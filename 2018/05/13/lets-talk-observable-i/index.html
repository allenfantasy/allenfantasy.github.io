<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 谈谈 Observable（上） · A Fantasy Ninja</title><meta name="description" content="谈谈 Observable（上） - Allen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/allenfantasy" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">谈谈 Observable（上）</h1><div class="post-meta"><span class="post-time">2018年5月13日</span><span class="taglist"><a href="/tags/JavaScript" class="tag">JavaScript</a></span></div><div class="post-content"><p>因为工作中的某个 ng2 的项目中使用到了 Observable（具体地说，是 ng2 http 模块中的请求方法的返回结果正是 Observable），所以做一些简单的学习，在此记录。</p>
<p>由于篇幅太大，本篇先讲述 Observable 的基本概念，<del>（如果有时间的话）就继续写更复杂一些的内容</del></p>
<a id="more"></a>
<h3 id="什么是-Observable"><a href="#什么是-Observable" class="headerlink" title="什么是 Observable"></a>什么是 Observable</h3><h4 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h4><p>简单的说：</p>
<blockquote>
<p>Observable 是一个可被订阅的对象，该对象将随着时间推移发送有限或无限个值供其订阅者消费。</p>
</blockquote>
<p>在这个说法中 Observable 有两个特征：</p>
<ol>
<li>它是可被订阅的 (Pub/Sub)</li>
<li>它的值是一个有限/无限的队列</li>
</ol>
<p>以下将分别说明这两点。</p>
<h4 id="对比-EventEmitter"><a href="#对比-EventEmitter" class="headerlink" title="对比 EventEmitter"></a>对比 EventEmitter</h4><p>提到订阅，我们自然会想起经典的 Pub/Sub 模式（也有叫观察者模式），在 JS 中的实现就是 <code>EventEmitter</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in Node.js v9.x</span></div><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="keyword">let</span> ev = <span class="keyword">new</span> EventEmitter()</div><div class="line">ev.on(<span class="string">'foo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`I got you, <span class="subst">$&#123;msg&#125;</span>!`</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">ev.on(<span class="string">'foo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`I got you too, <span class="subst">$&#123;msg&#125;</span>!`</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 在后续代码的任何位置:</span></div><div class="line">ev.emit(<span class="string">'foo'</span>, <span class="string">'a monster'</span>)</div></pre></td></tr></table></figure>
<p>在上述的代码片段中，我们创建了一个 EventEmitter 对象，并向该对象注册了一个事件和对应的监听函数。在后续的程序代码中，我们可以在任何位置，让 EventEmitter 对象触发（<code>emit</code>）一个事件，从而唤醒该事件关联的监听函数（可以是多个）。浏览器中的 DOM 元素也实现了类似 EventEmitter 的特性。</p>
<p>和 EventEmitter 一样，Observable 可以实现基本的发布订阅：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Observable <span class="keyword">from</span> <span class="string">'rxjs'</span></div><div class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> Observable(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  observer.next(<span class="number">1</span>)</div><div class="line">  observer.next(<span class="number">2</span>)</div><div class="line">&#125;)</div><div class="line">source.subscribe(<span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">console</span>.log(number))</div></pre></td></tr></table></figure>
<p>而在实际的需求中，我们可能要处理一个 <strong>队列的事件触发</strong>，且队列可能不是有限的（如 IM 消息，弹幕，用户在页面上的操作），我们需要从代码组织层面上提供更加方便的处理方式，这就引出了 Observable。</p>
<p>比如我们用 Observable 处理 WebSocket 数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Observable <span class="keyword">from</span> <span class="string">'rxjs'</span></div><div class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://someurl'</span>)</div><div class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> Observable(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  socket.addEventListener(<span class="string">'message'</span>, e =&gt; &#123;</div><div class="line">    observer.next(e) </div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> socket.close()</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 打印 WebSocket 发送过来的数据</span></div><div class="line"><span class="comment">// 假设接收的数据都为数字, 对其中所有的偶数X输出 "this number is X"</span></div><div class="line"><span class="keyword">let</span> sub = source</div><div class="line">  .filter(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span>)</div><div class="line">  .map(<span class="function"><span class="params">number</span> =&gt;</span> <span class="string">`this number is <span class="subst">$&#123;number&#125;</span>`</span>).subscribe(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 事实上可以对 message 做任何的处理</span></div><div class="line">    <span class="built_in">console</span>.log(message)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 在代码的任意位置</span></div><div class="line">sub.unsubscribe()</div></pre></td></tr></table></figure>
<p>在例子中我们新建并监听一个 WebSocket 连接，并将收到的信息进行处理。将监听逻辑封装成一个 Observable，让我们可以在后续使用 <code>.map()</code> 等操作符，来对收到的数据进行处理，并最后用 <code>subscribe()</code> 完成订阅。</p>
<h4 id="Stage-1-提案"><a href="#Stage-1-提案" class="headerlink" title="Stage-1 提案"></a>Stage-1 提案</h4><p>Observable 目前是 ECMAScript 的新提案 (<a href="https://github.com/tc39/proposal-observable" target="_blank" rel="noopener">Stage-1</a>)。在 ECMAScript 的提案中，Observable 的定义如下：</p>
<blockquote>
<p>The <strong>Observable</strong> type can be used to model push-based data sources such as DOM events, timer intervals, and sockets. In addition, observables are:</p>
<ul>
<li><em>Compositional</em>: Observables can be composed with higher-order combinators</li>
<li><em>Lazy</em>: Observables do not start emitting data until an <strong>observer</strong> has subscribed.</li>
</ul>
</blockquote>
<p>简单翻译如下：</p>
<blockquote>
<p><strong>Observable</strong> 类型可以用于表示基于推送的数据源模型，例如 DOM 事件，计时器，或者 socket。此外，Observable 还具有（以下特征）：</p>
<ul>
<li><em>可组合的</em>: Observable 可以使用高阶的连接符进行拼接组合</li>
<li><em>惰性</em>: Observable 仅当一个 <strong>observer</strong> 订阅时才会开始发送数据。</li>
</ul>
</blockquote>
<p>文章的后续会解释这两个属性，在这里读者可以先跳过概念部分，或者大概有个印象就可以了。</p>
<p>当前对 Observable 比较流行的实现有 <a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener">RxJS</a>, <a href="https://baconjs.github.io/" target="_blank" rel="noopener">Bacon.js</a>, <a href="https://github.com/zenparsing/zen-observable" target="_blank" rel="noopener">zen-observable</a> 等。接下来本文将基于 RxJS 中的实现来介绍 Observable 的基本概念。</p>
<h3 id="创建和订阅"><a href="#创建和订阅" class="headerlink" title="创建和订阅"></a>创建和订阅</h3><p>有别于固定长度的数组，Observable 的值是随时间发送的一连串的值，像水流一样，所以也有说法称 Observable 是一个流（Stream），为了更好的直观理解所谓的 “流”，首先我们来了解 Observable 的一种表示方法：<em>Marble Diagram</em>。</p>
<h4 id="Marble-Diagram"><a href="#Marble-Diagram" class="headerlink" title="Marble Diagram"></a>Marble Diagram</h4><p>Marble Diagram 由两个部分组成：<strong>timeline</strong> 和 <strong>item</strong>。timeline 表示时间轴，item 表示在时间轴上触发的元素（类型可以是任意的）。下图表示一个事件流先后触发（emit）了三个 item，最后成功结束，出现错误的符号为叉：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*brbCs4smjZfqitE0kHSHTQ.png" alt=""></p>
<p>我们也可以用类似 ASCII 的绘画方式来表达 Marble Diagram：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 - 表示一小段时间(可以理解为一个时间单位，如秒)，串起来表示一个时间轴，若某个时间中有发送值的话则用具体的值代替</span></div><div class="line">--<span class="number">-3</span>----<span class="number">-2</span>----<span class="number">-1</span>---<span class="number">-0</span>---</div><div class="line"></div><div class="line"><span class="comment">// 小括号代表着 Observable 是同步送值</span></div><div class="line">---(<span class="number">123</span>)----<span class="number">-2</span>----<span class="number">-1</span>---<span class="number">-0</span>---</div><div class="line">  </div><div class="line"><span class="comment">// X 表示有错误发生</span></div><div class="line">-----------------------X</div><div class="line"></div><div class="line"><span class="comment">// | 表示 Observable 结束</span></div><div class="line">-----------------------|</div></pre></td></tr></table></figure>
<p>接下来我们将了解 RxJS 中 Observable 相关的 API，其中将会用 Marble Diagram 的 ASCII 绘画来表示 Observable。如果有不太明白的地方，可以使用 <a href="https://rxviz.com/" target="_blank" rel="noopener">RxViz</a> 将代码实际运行一下，观察其 Marble Diagram 的具体形态。</p>
<h4 id="创建和订阅-1"><a href="#创建和订阅-1" class="headerlink" title="创建和订阅"></a>创建和订阅</h4><p>在上文中我们知道可以用 <code>Observable</code> 构造函数直接初始化一个 Observable 实例；RxJS 还提供了相同效果的静态方法 <code>Observable.create</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> observable = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  observer.next(<span class="string">'Jerry'</span>)</div><div class="line">  observer.next(<span class="string">'Anna'</span>)</div><div class="line">  observer.complete()</div><div class="line">  observer.next(<span class="string">'xxx'</span>) <span class="comment">// don't work</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在创建了 Observable 之后，可以通过 <code>subscribe</code> 方法订阅该 Observable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(&#123;</div><div class="line">  next (value) &#123;</div><div class="line">    <span class="comment">// 处理 Observable 发出的值</span></div><div class="line">  &#125;,</div><div class="line">  error (err) &#123;</div><div class="line">    <span class="comment">// 当 Observable 出错时执行</span></div><div class="line">  &#125;,</div><div class="line">  complete () &#123;</div><div class="line">    <span class="comment">// 当 Observable 正常结束时执行（状态为 completed）</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 另一种语法:</span></div><div class="line">observable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// next 方法</span></div><div class="line">&#125;, err =&gt; &#123;</div><div class="line">  <span class="comment">// err 方法</span></div><div class="line">&#125;, () =&gt; &#123;</div><div class="line">  <span class="comment">// complete 方法</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如上述代码所示，调用 <code>subscribe</code> 方法时我们传入了一个对象，该对象我们可以称为 <strong>观察者（Observer）</strong>。</p>
<p>观察者具有三个方法，每当 Observable 发生事件时便会呼叫观察者相对应的方法：</p>
<ul>
<li><code>next</code>: 每当 Observable 发送新的值，触发该方法</li>
<li><code>complete</code>: 当 Observable 不再获得新的值时，complete 方法就会被触发，该方法被触发后，next 方法将不会再起作用。</li>
<li><code>error</code>: 每当 Observable 内发生错误时，error 方法被触发。</li>
</ul>
<p>可以查看另一个 <a href="https://gist.github.com/allenfantasy/340d1237180440a20551a532dd632ff6#file-basic-js-L10" target="_blank" rel="noopener">观察者的例子</a></p>
<p>和 EventEmitter 不同，Observable 在内部没有一个订阅者清单，订阅 Observable 的行为实际上是执行一个函数，这个函数接收一个 <strong>Observer 对象</strong> 并在函数体内触发 Observer 对象的方法（next, complete, error），也就是说，对于某个 Observable，其在构建时传入的回调函数，必须要在该 Observable 被订阅之后，才会调用执行。可以看一下这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ob = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.warn(<span class="string">'now we start calling observer'</span>)</div><div class="line">  observer.next(<span class="number">1</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 必须要订阅之后才会执行</span></div><div class="line">ob.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.warn(<span class="string">'1st subscribe'</span>, value)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// another subscribe</span></div><div class="line">ob.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.warn(<span class="string">'2nd subscribe'</span>, value)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//=== output:</span></div><div class="line"><span class="comment">// now we start calling observer</span></div><div class="line"><span class="comment">// 1st subscribe 1</span></div><div class="line"><span class="comment">// now we start calling observer                                </span></div><div class="line"><span class="comment">// 2nd subscribe 1</span></div></pre></td></tr></table></figure>
<p>执行这段代码我们会发现，Observable 构造方法的回调函数实际上被调用了两次，这是因为这个 Observable 有两个订阅者，且回调函数是在 subscribe 时才被触发的。 如果我们将代码片段中 <code>subscribe</code> 的语句注释掉，执行时不会有任何输出。</p>
<p>在 RxJS 中，<code>subscribe</code> 方法会返回一个类型为 <code>Subscription</code> 的对象，可以用对象的 <code>unsubscribe</code> 方法可以停止对 observable 对象的监听（订阅）。</p>
<h3 id="Creation-Operator"><a href="#Creation-Operator" class="headerlink" title="Creation Operator"></a>Creation Operator</h3><p>除了用 <code>Observable.create</code> 方法之外，RxJS 还提供了很多便捷的创建 Observable 的 API，我们统称为 <em>creation operator</em>，其中包括：</p>
<ul>
<li><code>of</code>: <code>of(1,2,3,4)</code></li>
<li><code>from</code>: <code>from([1,2,3,4])</code></li>
<li><code>fromEvent</code></li>
<li><code>fromPromise</code></li>
<li><code>never</code>: 永远不会结束但什么都不做的</li>
<li><code>empty</code>: 空的且立刻结束的</li>
<li><code>throw</code>: 抛出错误</li>
<li><code>interval</code></li>
<li><code>timer</code></li>
</ul>
<p>利用这些 operator 我们可以快速实现一些常见的功能，如点击监听事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>)</div><div class="line"></div><div class="line">Rx.Observable.fromEvent(el, <span class="string">'click'</span>).subscribe(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// handle click events...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>或者是数数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每秒钟在控制台输出一个数字, 从0开始每次+1</span></div><div class="line">Rx.Observable.interval(<span class="number">1000</span>).subscribe(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(number)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 等1秒后送出0, 然后每隔5秒送出一个值(1,2,3,4..)</span></div><div class="line">Rx.Observable.timer(<span class="number">1000</span>, <span class="number">5000</span>).subscribe(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(number)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="Transform-Operator"><a href="#Transform-Operator" class="headerlink" title="Transform Operator"></a>Transform Operator</h3><p>前面提到，Observable 可以发送有限个或无限个值，我们可以将一定时间内 Observable 发出的值看做是一个数组，那么对这些值我们可以应用数组的所有方法如 <code>map()</code>, <code>filter()</code>, <code>pluck()</code> 等。事实上 Observable 确实提供了一系列的操作符（operator），允许我们链式调用。</p>
<p>Observable 本质上就是表示随时间发展而不断发送的一系列的值（流），我们可以像对待数组一样去对 Observable 进行操作，这样的操作方式，我们称为 Transform Operator。Transform Operator 可以分为几类（我的理解）：</p>
<ol>
<li>处理单个流的:<ul>
<li>简单的队列映射: <code>map</code>, <code>pluck</code>, <code>filter</code>, <code>scan</code>, <code>reduce</code>, <code>take</code>, <code>first</code>, <code>distinctUntilChanged</code> …</li>
<li>和时序有关的: <code>debounce</code>, <code>debounceTime</code>, <code>throttle</code>, <code>throttleTime</code></li>
</ul>
</li>
<li>处理多个流之间关系的: <code>merge</code>, <code>concat</code>, <code>combineLatest</code>, <code>zip</code>, <code>withLatestFrom</code></li>
<li>降维的(源 observable 所释放的每个值又是一个 observable): <code>concatAll</code>, <code>megeAll</code>, <code>combineAll</code>, <code>switch</code></li>
<li>映射+降维(源 observable 通过映射生成一个二维的 observable, 然后再降维): <code>concatMap</code>, <code>mergeMap</code>, <code>switchMap</code></li>
<li>其他: <code>catch</code>, <code>every</code>, <code>defaultEmpty</code>, <code>sequenceEqual</code>, <code>delay</code> 等</li>
</ol>
<p>分类方法还有一种是按照 <a href="http://rxmarbles.com/" target="_blank" rel="noopener">RxJS Marbles</a> 中的分类。有兴趣的读者也可以查看。</p>
<p>在介绍具体的 operator 之前，首先我们先看 operator 的运作方式。</p>
<h5 id="operators-运作方式"><a href="#operators-运作方式" class="headerlink" title="operators 运作方式"></a>operators 运作方式</h5><p>和数组的 operators 相比，Observable 的 operators 有两个特点：</p>
<ul>
<li>延迟运算：只有在 observable 被订阅时，operators 才开始对元素进行运算</li>
<li><p>渐进式取值：</p>
<blockquote>
<p>每次的运算是一个元素运算到底，而不是将全部元素运算完再返回</p>
</blockquote>
</li>
</ul>
<p>数组的取值方式：</p>
<p><img src="http://i.giphy.com/l0HlPZeB9OvFu7QwE.gif" alt=""></p>
<p>Observable 的取值方式：</p>
<p><img src="http://i.giphy.com/3o6ZtqrBfUyHvMDQ2c.gif" alt=""></p>
<p>为了理解方便，以下介绍 operator 时会使用 ASCII Marble Diagram。</p>
<h5 id="处理单个流"><a href="#处理单个流" class="headerlink" title="处理单个流"></a>处理单个流</h5><p><strong><code>map</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> source = Rx.Observable.interval(<span class="number">1000</span>)</div><div class="line"><span class="keyword">let</span> newest = source.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</div><div class="line"></div><div class="line">source: ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---...</div><div class="line">         map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</div><div class="line">newest: ---<span class="number">-2</span>---<span class="number">-3</span>---<span class="number">-4</span>---<span class="number">-5</span>---...</div></pre></td></tr></table></figure>
<p><strong><code>take</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> example = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>)</div><div class="line"><span class="comment">// TODO subscribe it ..</span></div><div class="line"></div><div class="line">source: ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---...</div><div class="line">         take(<span class="number">3</span>)</div><div class="line">newest: ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>|</div></pre></td></tr></table></figure>
<p><strong><code>distinctUntilChanged</code></strong></p>
<p>如果要发送的元素和最后一次发送的元素相同，则过滤掉该元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> source = Rx.Observable.from([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>])</div><div class="line"><span class="keyword">let</span> example = source.distinctUntilChanged()</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value) &#125;,</div><div class="line">  <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span>, err) &#125;,</div><div class="line">  <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>) &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Result:</span></div><div class="line"><span class="comment">// a</span></div><div class="line"><span class="comment">// b</span></div><div class="line"><span class="comment">// c</span></div><div class="line"><span class="comment">// b</span></div><div class="line"><span class="comment">// complete</span></div></pre></td></tr></table></figure>
<h5 id="处理多个流之间的关系"><a href="#处理多个流之间的关系" class="headerlink" title="处理多个流之间的关系"></a>处理多个流之间的关系</h5><p><strong><code>merge</code></strong></p>
<p>合并 observable，在时序上两个 observable 同时执行，但当两个 observable 同时触发元素时，被 merge 的 observable 所触发的元素在后面。</p>
<p><code>merge</code> 的逻辑有点像 OR，就是当两个 observable 其中一个被触发时都可以被处理。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> source = Rx.Observable.interval(<span class="number">500</span>).take(<span class="number">3</span>)</div><div class="line"><span class="keyword">let</span> source2 = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">6</span>)</div><div class="line"><span class="keyword">let</span> example = source.merge(source2)</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</div><div class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</div><div class="line">    <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">/* Marble Diagram</span></div><div class="line">source : ----0----1----2|</div><div class="line">source2: --0-1---2--3--4--5|</div><div class="line">            merge()</div><div class="line">example: --0-(01)--21-3--(24)--5|</div><div class="line">*/</div></pre></td></tr></table></figure>
<p><strong><code>concat</code></strong></p>
<p><code>concat</code> 可以把多个 observable 合并成一个：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.of(<span class="number">3</span>)</div><div class="line"><span class="keyword">var</span> source3 = Rx.Observable.of(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line"><span class="keyword">var</span> example = source.concat(source2, source3);</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</div><div class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</div><div class="line">    <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="comment">// 5</span></div><div class="line"><span class="comment">// 6</span></div><div class="line"><span class="comment">// complete</span></div><div class="line"></div><div class="line"><span class="comment">/* Marble Diagram</span></div><div class="line">source : ----0----1----2|</div><div class="line">source2: (3)|</div><div class="line">source3: (456)|</div><div class="line">            concat()</div><div class="line">example: ----0----1----2(3456)|</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="降维操作"><a href="#降维操作" class="headerlink" title="降维操作"></a>降维操作</h5><p>和数组类似，Observable 也可能出现类似二维数组这样的 “高维” 情况，即 Observable 中所发出的每项元素又是一个单独 Observable。RxJS 提供了一系列的 API 允许我们将其转换为普通的 “一维 Observable”。</p>
<p><strong><code>concatAll</code></strong></p>
<p>比如对应数组中 <code>concat</code> 操作，RxJS 也有 <code>concatAll</code> operator，会将所有的 Observable “拼接” 起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obs1 = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">5</span>) <span class="comment">// 0, 1, 2, 3, 4</span></div><div class="line"><span class="keyword">let</span> obs2 = Rx.Observable.interval(<span class="number">500</span>).take(<span class="number">2</span>)</div><div class="line"><span class="keyword">let</span> obs3 = Rx.Observable.interval(<span class="number">2000</span>).take(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> source = Rx.Observable.of(obs1, obs2, obs3)</div><div class="line"></div><div class="line"><span class="keyword">let</span> example = source.concatAll()</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">    next (value) =&gt; &#123; <span class="built_in">console</span>.log(value) &#125;,</div><div class="line">    error (err) =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err) &#125;,</div><div class="line">    complete () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>) &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">/* Marble Diagram</span></div><div class="line"></div><div class="line">obs1  : ----0----1----2----3----4|</div><div class="line">obs2  : --0--1|</div><div class="line">obs3  : --------0| </div><div class="line">source: (o1,                           o2,        o3)</div><div class="line">          \                             \          \</div><div class="line">           ----0----1----2----3----4|    --0--1|    --------0|</div><div class="line">           </div><div class="line">                       concatAll()</div><div class="line">                       </div><div class="line">example: ----0----1----2----3----4--0--1--------0|</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">let</span> source = Rx.Observable.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).map(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> req = <span class="keyword">await</span> fetch(<span class="string">`/search?<span class="subst">$&#123;number&#125;</span>`</span>)</div><div class="line">  <span class="keyword">return</span> Rx.Observable.fromPromise(httpReq1)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>观察上面的 Marble Diagram，我们可以发现，<code>concatAll</code> 将 source 中的三个 Observable 按顺序拼接起来依次输出。</p>
<p><strong><code>switch</code></strong></p>
<p>swtich 总是会将返回的 Observable 的 “控制权” 交给原 Observable 中 <strong>最近返回</strong> 的一个 Observable。</p>
<p>尝试理解下这个例子：</p>
<iframe style="width:100%;height:400px;" src="https://stackblitz.com/edit/observable-switch?embed=1"></iframe>

<p>再看看这个例子对应的 <a href="https://rxviz.com/v/7Jag5mwo" target="_blank" rel="noopener">Marble Diagram</a>：</p>
<svg width="562" height="167" style="display: block; font-size: 14px; font-family: Arial, sans-serif; dominant-baseline: central; text-anchor: middle; cursor: default; user-select: none;"><line x1="21" y1="37" x2="21" y2="89" stroke="#767676" stroke-width="1" stroke-dasharray="3,3"/><line x1="153.8031" y1="37" x2="153.8031" y2="141" stroke="#767676" stroke-width="1" stroke-dasharray="3,3"/><g transform="translate(0, 11)"><!-- react-empty: 11 --><g transform="translate(21, 0)"><line x1="0" y1="26" x2="531" y2="26" stroke-width="2" stroke="#000000" style="shape-rendering: crispEdges;"/><path transform="translate(531, 21)" d="M0 0 L10 5 L0 10 z" fill="#000000" style="transition: fill 0.2s ease-in-out;"/><!-- react-empty: 16 --><g><g style="transform: translate(0px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="0" stroke="#000000" fill="#767676"/></g><g style="transform: translate(132.803px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="0" stroke="#000000" fill="#767676"/></g></g><!-- react-empty: 20 --></g></g><g transform="translate(0, 63)"><!-- react-empty: 22 --><g transform="translate(21, 0)"><line x1="0" y1="26" x2="531" y2="26" stroke-width="2" stroke="#767676" style="shape-rendering: crispEdges;"/><path transform="translate(531, 21)" d="M0 0 L10 5 L0 10 z" fill="#767676" style="transition: fill 0.2s ease-in-out;"/><!-- react-empty: 27 --><g><g style="transform: translate(53.2062px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">0</text></g><g style="transform: translate(106.625px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">1</text></g><g style="transform: translate(159.831px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">2</text></g><g style="transform: translate(213.25px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">3</text></g><g style="transform: translate(266.403px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">4</text></g><g style="transform: translate(319.821px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">5</text></g><g style="transform: translate(372.974px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">6</text></g><g style="transform: translate(426.287px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">7</text></g><g style="transform: translate(479.546px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">8</text></g></g><!-- react-empty: 29 --></g></g><g transform="translate(0, 115)"><!-- react-empty: 41 --><g transform="translate(21, 0)"><line x1="132.8031" y1="26" x2="531" y2="26" stroke-width="2" stroke="rgba(118, 118, 118, 0.2)" style="shape-rendering: crispEdges;"/><line x1="132.8031" y1="26" x2="319.662" y2="26" stroke-width="2" stroke="#767676" style="shape-rendering: crispEdges;"/><path transform="translate(531, 21)" d="M0 0 L10 5 L0 10 z" fill="rgba(118, 118, 118, 0.2)" style="transition: fill 0.2s ease-in-out;"/><line x1="319.662" y1="3.5" x2="319.662" y2="48.5" stroke-width="2" stroke="#767676" style="opacity: 1; transition: opacity 0.5s ease-in-out;"/><g><g style="transform: translate(170.132px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">0</text></g><g style="transform: translate(207.568px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">1</text></g><g style="transform: translate(244.844px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">2</text></g><g style="transform: translate(282.226px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">3</text></g><g style="transform: translate(319.45px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">4</text></g></g><!-- react-empty: 48 --></g></g><g style="text-anchor: start; dominant-baseline: text-before-edge;"/></svg>

<h5 id="映射-降维"><a href="#映射-降维" class="headerlink" title="映射+降维"></a>映射+降维</h5><p>为了更加方便操作，RxJS 还提供了一些复合 operator，可以同时完成映射（成一个 Observable）和降维的操作。</p>
<p><strong><code>switchMap</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="comment">// map + switch</span></div><div class="line"><span class="keyword">var</span> example = source.switchMap(</div><div class="line">  <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">100</span>).take(<span class="number">3</span>)</div><div class="line">);</div><div class="line">                </div><div class="line">example.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</div><div class="line">  <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</div><div class="line">  <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">/** Marble Diagram</span></div><div class="line">source : -----------c--c------------------...</div><div class="line">        concatMap(c =&gt; Rx.Observable.interval(100).take(3))</div><div class="line">example: -------------0-1-2-0-1-2---------...</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="其他-operator"><a href="#其他-operator" class="headerlink" title="其他 operator"></a>其他 operator</h5><p><strong><code>catch</code></strong></p>
<p><code>catch</code> 可以处理 observable 处理过程中出现的异常，可以通过返回一个新的 observable 来发送新的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> source = Rx.Observable.from([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="number">2</span>, <span class="string">'...'</span>])</div><div class="line">    .zip(Rx.Observable.interval(<span class="number">500</span>), (x, y) =&gt; x)</div><div class="line"></div><div class="line"><span class="keyword">let</span> example = source</div><div class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</div><div class="line">                .catch(<span class="function"><span class="params">error</span> =&gt;</span> Rx.Observable.of(<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>))</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value) &#125;,</div><div class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err) &#125;,</div><div class="line">    <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>) &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这段代码对应的 Marble Diagram 是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">source : ----a----b----c----d----2|</div><div class="line">        map(x =&gt; x.toUpperCase())</div><div class="line">         ----a----b----c----d----X|</div><div class="line">        catch(error =&gt; Rx.Observable.of(&apos;h&apos;))</div><div class="line">example: ----a----b----c----d----h----e----l----l---o|</div></pre></td></tr></table></figure>
<p>可以在 <code>catch</code> 的回调函数中，通过返回一个空的 observable（如：<code>Rx.Observable.empty()</code>）来让原有的 observable 结束。</p>
<h3 id="Practical-Example"><a href="#Practical-Example" class="headerlink" title="Practical Example"></a>Practical Example</h3><p>为了让读者更加直观理解 Observable 的具体使用，来几个例子：这里要鸣谢 “30天精通 RxJS” 教程的作者 @jerryhong，以下例子均出自他的教程。</p>
<ul>
<li><a href="https://jsfiddle.net/c5azpk87/" target="_blank" rel="noopener">拖拽方块</a></li>
<li><a href="https://jsfiddle.net/s6323859/ochbtpk5/3/" target="_blank" rel="noopener">类似 Youku 的滚动视频窗口+可拖拽效果</a></li>
<li><a href="https://jsfiddle.net/s6323859/yf02gt9j/1/" target="_blank" rel="noopener">简单加减</a></li>
<li><a href="https://jsbin.com/quvajux/1/edit?js,console,output" target="_blank" rel="noopener">AutoComplete</a>: 使用了 <code>debounceTime</code>, <code>switchMap</code>, <code>filter</code>, <code>map</code>, <code>fromEvent</code></li>
</ul>
<h3 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h3><p>在了解了 RxJS 和实践了几个例子之后，我们对 Observable 有一个基本的认识：</p>
<ul>
<li>从编程思想上来说，Observable 可以说是 <code>Reactive Programming</code> 和 <code>Functional Programming</code> 两种思想的结合，关于两种思想读者可以自行查阅。</li>
<li>从内容上看，Observable 实现了随时间变化的队列数据的发布订阅。</li>
<li>从使用场景上看，Observable 适合处理需要结合多个事件源（如：DOM事件）的复杂逻辑（应用适合的 operator），也适合处理弹幕，IM 聊天等无限数据流的需求。ng2 中大量的使用了 Observable 来管理其内部的 UI 状态。在下篇中我会提到这部分的内容 <del>（挖了个坑，逃</del></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://medium.com/@jshvarts/read-marble-diagrams-like-a-pro-3d72934d3ef5" target="_blank" rel="noopener">Understanding Marble Diagrams for Reactive Streams</a> 注: 文章中使用的还是 Rx 4.x 的语法</li>
<li><a href="http://rxmarbles.com/" target="_blank" rel="noopener">RxMarbles</a></li>
<li><a href="https://ithelp.ithome.com.tw/users/20103367/ironman/1199" target="_blank" rel="noopener">30天精通 RxJS</a></li>
<li><a href="http://reactivex.io/rxjs/" target="_blank" rel="noopener">rxjs document</a></li>
<li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/switchmap.html" target="_blank" rel="noopener">https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/switchmap.html</a></li>
<li><a href="https://medium.com/@w.dave.w/becoming-more-reactive-with-rxjs-flatmap-and-switchmap-ccd3fb7b67fa" target="_blank" rel="noopener">Becoming more reactive with RxJS flatMap and switchMap</a></li>
<li><a href="https://angular.io/guide/observables" target="_blank" rel="noopener">https://angular.io/guide/observables</a></li>
<li><a href="https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3" target="_blank" rel="noopener">https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3</a></li>
<li><a href="https://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.html" target="_blank" rel="noopener">https://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.html</a></li>
<li><a href="https://gist.github.com/btroncone/a6e4347326749f938510#projecting-data" target="_blank" rel="noopener">Comprehensive Introduction to @ngrx/store</a></li>
<li><a href="https://github.com/ngrx/store" target="_blank" rel="noopener">@ngrx/store</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2018/05/25/cssconf-note-scalable-comp/" class="prev">上一篇</a><a href="/2018/05/11/translation-the-tc39-process/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
    this.page.url = 'http://afantasy.ninja/2018/05/13/lets-talk-observable-i/';
    // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = '2018/05/13/lets-talk-observable-i/';
    // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://afantasy-ninja.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the<a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><script id="dsq-count-scr" src="//afantasy-ninja.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2020 <a href="http://afantasy.ninja">Allen</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://s22.cnzz.com/z_stat.php?id=1261988857&amp;web_id=1261988857"></script><script>document.querySelector('[title="站长统计"]').style.display = 'none'</script></body></html>