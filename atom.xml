<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Fantasy Ninja</title>
  <subtitle>Records of ventures and codes.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://afantasy.ninja/"/>
  <updated>2019-09-01T14:25:35.144Z</updated>
  <id>http://afantasy.ninja/</id>
  
  <author>
    <name>Allen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析 git 数据管理</title>
    <link href="http://afantasy.ninja/2019/09/01/brief-talk-about-git-data/"/>
    <id>http://afantasy.ninja/2019/09/01/brief-talk-about-git-data/</id>
    <published>2019-09-01T14:25:00.000Z</published>
    <updated>2019-09-01T14:25:35.144Z</updated>
    
    <content type="html"><![CDATA[<p>两个月前，团队来了个新的实习生。我们让他协助开发一个 Java 服务。第二天发生了一个鬼故事：</p>
<blockquote>
<p><em>实习生花了1个小时来下载 git 工作仓库</em></p>
</blockquote>
<a id="more"></a>
<p>好不容易下载到本地，可见的代码本身只有几十 M 的大小，但在命令行中查看仓库时，发现在 <code>.git</code> 目录中有一个名为 <code>xxxx.pack</code> 的文件，大小竟然有 1.6G。</p>
<p>这时我和实习生都懵逼了：</p>
<blockquote>
<p>为什么这个文件会这么大？这个文件是干嘛的？</p>
</blockquote>
<p>我突然发现，自己每天都在使用的 git，其实背后隐藏了大量自己不了解的细节。这篇文章的出发点，就是对其中自己不求甚解的部分，做一个充分的解读。</p>
<h2 id="Pre-requisite"><a href="#Pre-requisite" class="headerlink" title="Pre-requisite"></a>Pre-requisite</h2><p>为了便于理解，在阅读这篇文章前，你需要对 git 有基本的使用经验。如果没有的话，可以先从廖雪峰的 <a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">git 教程</a> 开始。</p>
<p>读者也可以看下 <a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">图解 git</a>，可以对 git 基本操作有更直观的认识。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>版本控制的本质</li>
<li>git 文件管理<ul>
<li>三个文件区域</li>
<li>文件的四种状态</li>
<li>git 数据库</li>
</ul>
</li>
<li>分支的秘密<ul>
<li>从分叉到分支</li>
<li>HEAD</li>
<li>ref, refs! {WIP}</li>
<li>分支的合并</li>
</ul>
</li>
<li>回到 .pack 文件 – git 优化</li>
</ul>
<h2 id="版本控制的本质"><a href="#版本控制的本质" class="headerlink" title="版本控制的本质"></a>版本控制的本质</h2><p>想象一下，我们正在开发一个项目：没有 git，没有 SVN，没有任何可用工具。<strong>我们如何保证：可以保留这个项目不同的版本，当某一个版本出了问题时，可以回到上一个版本呢？</strong></p>
<p>这里的 <strong>版本</strong>，可以理解为：当前项目中的 <strong>所有文件的副本</strong> 的集合。比如：</p>
<blockquote>
<ol>
<li>今天早上10点，某同事 A 向项目中添加了 <code>list.js</code>，加了10行代码</li>
<li>下午3点，某同事 A 发现 <code>list.js</code> 里有 bug，于是修改了其中的3行代码</li>
<li>晚上8点，某同事 B 添加了一个新功能，又给 <code>list.js</code> 增加了20行代码</li>
</ol>
</blockquote>
<p>以上的每一个操作之后，我们都得到了1个关于 <code>list.js</code> 在这个仓库中的副本。所谓版本控制，无非就是控制某个文件夹中所有的文件（包括嵌套文件夹里的文件）的副本，并允许我们随意地调用这些副本的数据。</p>
<p>所以回到没有版本控制工具的时候，最简单的方法当然是：<code>Ctrl-C</code> + <code>Ctrl-V</code> —— 当我们需要保留其中一个「版本」时，我们可以先将整个项目文件夹的代码，复制出来，然后取个名字 <em>v1</em>，甚至再压缩打包一下变成 <em>v1.zip</em>，然后存起来。这样不断重复，对每一个值得保存的修改，我们都给它执行这样的操作，得到 <em>v2, v3, v4, …</em></p>
<p>这样，当我们发布了一个新版本时，如果它有问题，我们可以很快的恢复到上一个版本；每个文件在每个版本的副本，都被保留下来了。</p>
<p><strong>这当然是一种有效的做法，但它确实又是一个低效的做法：</strong></p>
<ul>
<li>道理上来说，我们只要保存每个新的「版本」中被修改过的文件就行了，不需要所有的文件都复制一遍</li>
<li>复制粘贴重命名的操作，重复繁琐，且容易出错（万一搞错版本号，那就糟糕了）</li>
<li>如果有多个人一起工作怎么办呢？怎么约定所谓的「版本号」呢？</li>
<li>如果两个人都希望发布一个新版本，但两个人修改的代码是同一个位置又怎么办呢？</li>
<li>…</li>
</ul>
<p>带着这些问题，我们来审视一个版本控制工具，它必须要能够解决以下几个问题：</p>
<ol>
<li>它可以在每个版本中 “保存” 每个文件的副本（特别是，修改过的文件）</li>
<li>它可以保证「版本号」的唯一性</li>
<li>当有多个人一起协作时，它可以通过某些规则，解决不同人对同一个文件的修改的合并问题</li>
<li>…</li>
</ol>
<p>接下来我们将看看 git 是如何分别解决这些问题的。</p>
<h2 id="git-文件管理"><a href="#git-文件管理" class="headerlink" title="git 文件管理"></a>git 文件管理</h2><p>在详细介绍 git 文件管理之前，希望大家可以把一句话先牢牢记下来：</p>
<blockquote>
<p><em>git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照</em><br><br><br><em>git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照</em><br><br><br><em>git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照</em></p>
</blockquote>
<p>当我们在 git 仓库中提交更新，或者保存项目状态时，git 会对当时的全部文件制作副本（也可以称为“快照”），并为每份快照都提供一个独立的索引。如果有些文件没有被更新，那么 git 不会对其生成新的副本，而是在提交记录中保留指向之前存储的文件的链接。</p>
<h3 id="三个文件区域"><a href="#三个文件区域" class="headerlink" title="三个文件区域"></a>三个文件区域</h3><p>git 项目中有三个文件区域的概念：</p>
<ul>
<li>首先，git 会将所有的代码副本和项目元数据（提交历史，目录结构），都存放在一个 <code>.git</code> 的目录中。我们称这个目录为「版本库」；</li>
<li>此外，当前的工作目录，直接可见的部分，我们称为「工作区」；</li>
<li>最后，为了方便记录我们对文件的修改，git 还提供了一个「暂存区」（<code>staging area</code>），临时寄放我们新增的或者修改过的文件，相当于一个等候区。</li>
</ul>
<p>一般我们会在「工作区」中新增或者修改某些文件，然后执行 <code>git add</code> —— 这时被添加的文件的快照将被放入到「暂存区」，直到我们通过 <code>commit</code> 指令提交这些变更，永久地存入到「版本库」中。</p>
<p>如果我们希望可以在「工作区」中查看某个版本的数据，我们可以通过 <code>checkout</code> 指令，从「版本库」中调档，把某个版本的数据调取出来。</p>
<p><img src="https://git-scm.com/book/en/v2/images/areas.png" alt=""></p>
<h3 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h3><p>虽然 git 有三个文件区域，但实际上在项目中的文件，理论上可以有4种不同状态：</p>
<ul>
<li><code>untracked</code> - git 还没有「跟踪」该文件</li>
<li><code>unmodified</code> - 当前文件和最近提交记录的文件的状态，是完全一致的</li>
<li><code>modified</code> - 当前文件和最近提交记录的文件相比，做了一定的修改</li>
<li><code>staged</code> - 文件做了修改，且这些修改被暂存起来了。</li>
</ul>
<p>每个状态以及更改文件状态的 git 操作，如下图所示。</p>
<p><img src="https://git-scm.com/book/en/v2/images/lifecycle.png" alt=""></p>
<p>注：对于某些我们不希望 git 去管的文件，我们可以在它位于 <code>untracked</code> 状态时，通过 <code>.gitignore</code> 中的规则，让 git 忽略它们的存在。</p>
<p>这基本是绝大部分 git 教程会告诉我们的东西。但这里请大家思考两个问题：</p>
<ol>
<li><strong>git 通过什么判断我的某个文件是否为 <code>untracked</code> ？所谓「跟踪」又是什么意思呢？</strong></li>
<li><strong>说 <code>.git</code> 目录代表了 git 的「版本库」，那具体的代码副本是如何存放的呢？</strong></li>
</ol>
<p>这就要从 git 的核心：git 数据库说起。</p>
<h3 id="git-数据库"><a href="#git-数据库" class="headerlink" title="git 数据库"></a>git 数据库</h3><p><strong>git 的核心部分是一个简单的 key-value 数据库：</strong> </p>
<ol>
<li>你可以向数据库插入任意类型的内容，它会返回一个键值，通过键值可以在任意时刻再次查询该内容。</li>
<li>这些数据都是存储在 <code>.git/objects</code> 目录里的，以文件的形式存放。</li>
<li><code>key</code> 的值是一个 <em>40位的 SHA-1 hash</em>，hash 的前2个字符用于命名子目录，余下的38个字符用作文件名</li>
</ol>
<p>在 git 数据库中，有4种不同类型的对象：</p>
<ul>
<li>blob - 记录单个文件的数据</li>
<li>tree - 对应记录文件夹节点的数据</li>
<li>commit - 记录一次提交记录</li>
<li>tag - 记录一个 tag</li>
</ul>
<p>我们在下一节会提到它们的具体形态和数据结构，但目前我们先不纠结这个，只需要知道有这几样东西就可以了。</p>
<p>让我们通过一个实际的例子，进行日常的 git 操作，然后查看 git 的原始数据存放情况。</p>
<h4 id="举一个栗子"><a href="#举一个栗子" class="headerlink" title="举一个栗子"></a>举一个栗子</h4><p>首先我们创建一个空的文件夹，作为我们的项目地址，并用 <code>git init</code> 将它初始化：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir git-demo</div><div class="line">$ <span class="built_in">cd</span> git-demo</div><div class="line">$ git init   <span class="comment"># 这就创建好了</span></div></pre></td></tr></table></figure>
<p>目前项目空空如也。但实际上 git 仓库已经就绪，我们可以看下 <code>.git</code> 目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">$ tree .git  <span class="comment">### 以下是输出结果</span></div><div class="line">.git</div><div class="line">├── HEAD</div><div class="line">├── config</div><div class="line">├── description</div><div class="line">├── hooks</div><div class="line">│   ├── applypatch-msg.sample</div><div class="line">│   ├── commit-msg.sample</div><div class="line">│   ├── post-update.sample</div><div class="line">│   ├── pre-applypatch.sample</div><div class="line">│   ├── pre-commit.sample</div><div class="line">│   ├── pre-push.sample</div><div class="line">│   ├── pre-rebase.sample</div><div class="line">│   ├── pre-receive.sample</div><div class="line">│   ├── prepare-commit-msg.sample</div><div class="line">│   └── update.sample</div><div class="line">├── info</div><div class="line">│   └── exclude</div><div class="line">├── objects</div><div class="line">│   ├── info</div><div class="line">│   └── pack</div><div class="line">└── refs</div><div class="line">    ├── heads</div><div class="line">    └── tags</div><div class="line"></div><div class="line">8 directories, 14 files</div></pre></td></tr></table></figure>
<p>这里我们先抛开别的文件，只看 <code>objects</code> 目录。不难看出，它现在只有 <code>info</code> 和 <code>pack</code> 两个文件（我们稍后再提到他们）</p>
<p>我们尝试给文件夹里添加点东西：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mkdir src</div><div class="line">$ touch Readme.md src/index.js</div><div class="line">$ <span class="built_in">echo</span> <span class="string">'this is some readme text huh'</span> &gt; Readme.md</div></pre></td></tr></table></figure>
<p>然后我们再查看 <code>.git/objects</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ tree .git/objects</div><div class="line">.git/objects/</div><div class="line">├── info</div><div class="line">└── pack</div><div class="line"></div><div class="line">2 directories, 0 files</div></pre></td></tr></table></figure>
<p>呵…并没有任何变化。那如果我们把其中一个文件放到「暂存区」呢：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git add Readme.md</div><div class="line">$ tree .git/objects</div><div class="line">.git/objects/</div><div class="line">├── ed</div><div class="line">│   └── afe27e250ef26f694b25afce81bdaf96f44eb0</div><div class="line">├── info</div><div class="line">└── pack</div><div class="line"></div><div class="line">3 directories, 1 file</div></pre></td></tr></table></figure>
<p>哦豁 —— 在 <code>.git/objects</code> 下多了一个文件夹 <code>ed</code>，文件夹下又带有一个名为 <code>afe27e250ef26f694b25afce81bdaf96f44eb0</code> 的文件，串在一起 <code>edafe27e250ef26f694b25afce81bdaf96f44eb0</code> 刚好是40个字符，这就是 git 对这个文件生成的 SHA-1 hash。</p>
<p>我们可以用 <code>git cat-file</code> 来瞧瞧这个文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git cat-file -p edafe27e250ef26f694b25afce81bdaf96f44eb0 <span class="comment"># -p 输出 git 对象的内容</span></div><div class="line">this is some readme text huh</div><div class="line"></div><div class="line">$ git cat-file -t edafe27e250ef26f694b25afce81bdaf96f44eb0 <span class="comment"># -t 输出 git 对象的类型</span></div><div class="line">blob</div></pre></td></tr></table></figure>
<p>所以在我们添加一个文件到「暂存区」时，git 会对应地创建一个 <code>blob</code> 类型的对象（文件），且这个文件的路径是由一个 40 位的 SHA-1 hash 指定的。</p>
<p>接下来我们提交这个位于「暂存区」的文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">'add readme'</span></div><div class="line">[master (root-commit) 4245348] add readme</div><div class="line"> 1 file changed, 1 insertion(+)</div><div class="line"> create mode 100644 Readme.md</div><div class="line"></div><div class="line">$ tree .git/objects</div><div class="line">.git/objects</div><div class="line">├── 12</div><div class="line">│   └── 0c03e073cdf409403224c406fdfb022a63e750</div><div class="line">├── 49</div><div class="line">│   └── 0e706c59461270e6f3c0d47356ac84e8c0bc1b</div><div class="line">├── ed</div><div class="line">│   └── afe27e250ef26f694b25afce81bdaf96f44eb0</div><div class="line">├── info</div><div class="line">└── pack</div><div class="line"></div><div class="line">5 directories, 3 files</div></pre></td></tr></table></figure>
<p>这次提交后，我们发现，除了原本的 <code>edafe...</code> 外，<code>objects</code> 里面又多了两个文件：<code>49/0e7...</code> 和 <code>12/0c0...</code>；同样我们可以分别查看这两个文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git cat-file -t 120c03e073cdf409403224c406fdfb022a63e750</div><div class="line">commit</div><div class="line"></div><div class="line">$ git cat-file -p 120c03e073cdf409403224c406fdfb022a63e750 </div><div class="line">tree 490e706c59461270e6f3c0d47356ac84e8c0bc1b</div><div class="line">author Zeqiu Wu &lt;allenwu1018@gmail.com&gt; 1567341827 +0800</div><div class="line">committer Zeqiu Wu &lt;allenwu1018@gmail.com&gt; 1567341827 +0800</div><div class="line"></div><div class="line">add readme</div></pre></td></tr></table></figure>
<p>不难看出，这第一个文件对应的是一个 <code>commit</code> 类型的对象；对象中的数据记录了这个 commit 的作者和提交者，还有 commit msg；此外，还包含了一行记录：<code>tree 490e706c59461270e6f3c0d47356ac84e8c0bc1b</code>，这里的 SHA-1 hash 恰好是另一个文件的 SHA-1 hash：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git cat-file -t 490e706c59461270e6f3c0d47356ac84e8c0bc1b</div><div class="line">tree</div><div class="line"></div><div class="line">$ git cat-file -p 490e706c59461270e6f3c0d47356ac84e8c0bc1b</div><div class="line">100644 blob edafe27e250ef26f694b25afce81bdaf96f44eb0	Readme.md</div></pre></td></tr></table></figure>
<p>而第二个文件则是一个 <code>tree</code> 类型的对象。它的内容包含了 <code>Readme.md</code> 这个文件的名称，对应的 git blob 对象的 SHA-1 hash 和文件模式（100644）。</p>
<p>这时我们的几个 git 对象之间的关系是这样的：</p>
<p><img src="../images/commit-1.png" alt=""></p>
<p>随后我们在 <code>src/index.js</code> 中编写一段代码，并提交：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'this is index.js'</span>)</div><div class="line"><span class="comment">// TODO</span></div></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add src/index.js</div><div class="line">$ git commit -m <span class="string">'init project index'</span></div></pre></td></tr></table></figure>
<p>这时候我们再看 <code>.git/objects</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ tree .git/objects</div><div class="line">.git/objects</div><div class="line">├── 12</div><div class="line">│   └── 0c03e073cdf409403224c406fdfb022a63e750</div><div class="line">├── 49</div><div class="line">│   └── 0e706c59461270e6f3c0d47356ac84e8c0bc1b</div><div class="line">├── 8f</div><div class="line">│   └── d15dbfbba5fd5b981de38f5177c8029693f4fb</div><div class="line">├── bd</div><div class="line">│   └── acba00da0ef745a2bdfdee7844ecc97db19cb0</div><div class="line">├── e0</div><div class="line">│   └── 5e71a0142e288df830343f06c2e9549511b159</div><div class="line">├── ed</div><div class="line">│   └── afe27e250ef26f694b25afce81bdaf96f44eb0</div><div class="line">├── ff</div><div class="line">│   └── cee3ab51c6a5903bc8a9ca9378a5672e44ea36</div><div class="line">├── info</div><div class="line">└── pack</div><div class="line"></div><div class="line">9 directories, 7 files</div></pre></td></tr></table></figure>
<p>唔，有点多哈。我们先排除掉上一次提交中涉及的3个 git 对象：<code>120c0...</code>, <code>490e7...</code> 和 <code>edafe...</code>。那么我们就还有4个对象。逐一分析可以得到：</p>
<ul>
<li><code>8fd15...</code> - <code>commit</code> 对象，内容为：<ul>
<li><strong>tree</strong> <code>e05e7...</code></li>
<li><strong>parent</strong> <code>120c0...</code></li>
<li><strong>author</strong> <code>Zeqiu Wu</code></li>
<li><strong>committer</strong> <code>Zeqiu Wu</code></li>
<li><strong>commit 信息</strong> <code>init project index</code></li>
</ul>
</li>
<li><code>bdacb...</code> - <code>blob</code> 对象，内容为刚才我们写入的三行 JS 脚本</li>
<li><code>e05e7...</code> - <code>tree</code> 对象，内容为：<ul>
<li><code>100644</code> <code>blob</code> <code>edafe...</code> <code>Readme.md</code></li>
<li><code>040000</code> <code>tree</code> <code>ffcee...</code> <code>src</code></li>
</ul>
</li>
<li><code>ffcee...</code> - <code>tree</code> 对象，内容为：<ul>
<li><code>100644</code> <code>blob</code> <code>bdacb...</code> <code>index.js</code></li>
</ul>
</li>
</ul>
<p>用图来表示会更直观一些：</p>
<p><img src="../images/commit-2.jpg" alt=""></p>
<p>第二个 commit 的图中，包含了很多信息。</p>
<p>首先，相比于上一个图，不难留意到 <code>490e7...</code> 这个 tree 对象的内容中，除了包含对 blob 对象的引用外，还包含对另一个 tree 对象的引用：<code>ffcee...</code>，且引用中注明了 <code>src</code> 这个文件夹名称。</p>
<p>从概念上讲，从项目顶层目录开始，git 储存的实际数据结构有点像这样：</p>
<p><img src="https://git-scm.com/book/en/v2/images/data-model-1.png" alt=""></p>
<p>在最顶端总会有一个 <code>tree</code> 对象；如顶层目录下还有别的文件夹，则就文件夹本身会有一个额外的 <code>tree</code> 对象记录。</p>
<p>另外，在上一个 commit 中出现的 <code>Readme.md</code> 仍然出现在图中，只是这次是一个名为 <code>490e7...</code> 的 tree 对象记录了 <code>Readme.md</code> 的 blob 对象的 hash。</p>
<p>此外，还需要注意的是 <code>a1a6b...</code> 这个 commit 对象，除了包含 tree 引用，提交者信息和 commit 日志外，还附带了一个 <code>parent</code> 信息，正好是上一个 commit 的 SHA-1 hash <code>56319...</code></p>
<p>如果我们将 <code>.git/objects</code> 里所有的对象都放到一个图中，就会是这样的：</p>
<p><img src="../images/all-git-objects.jpg" alt=""></p>
<p>其中的对象间的关系，大家可以尝试自己体会 :p</p>
<h3 id="git-对象小结"><a href="#git-对象小结" class="headerlink" title="git 对象小结"></a>git 对象小结</h3><p>从上一节的例子中，我们可以得到一些基本的结论：</p>
<ul>
<li>git 通过在「版本库」（即 <code>.git/objects</code>）中创建一个路径唯一的文件来记录（或者叫”跟踪“）一个 git 对象。这个文件的路径由一个长度为 40 的 SHA-1 hash 分拆组成。</li>
<li>我们知道有三种 git 对象：blob, tree, commit（有兴趣的读者可以自行研究 tag 对象）</li>
<li>blob 对象对应某个文件在某个时间点上的内容。</li>
<li>commit 和 tree 对象的数据中会包含对 tree 或 blob 对象的指针</li>
<li>tree 对象可以视作代表 “文件夹” —— tree 对象的指向关系，本质上就是对应文件夹关系的一颗树</li>
<li><p>从第二个开始的所有 commit 对象，都会包含指向其上一个 commit 的指针</p>
<p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt=""></p>
</li>
</ul>
<h2 id="分支的秘密"><a href="#分支的秘密" class="headerlink" title="分支的秘密"></a>分支的秘密</h2><p>基于 git 的对象理论，我们来尝试剖析 git 分支的具体形态，以及对分支的各种操作。</p>
<h3 id="从分叉到分支"><a href="#从分叉到分支" class="headerlink" title="从分叉到分支"></a>从分叉到分支</h3><p>从上一节中，我们知道除了第一个 commit 外，每个 commit 都会包含对上一个的指针。那么假如某个 git 项目一直只有一个人在开发，那么这个 git 项目的 commit 记录就会组成1条简单的直线。</p>
<p>但如果是两个人在开发，必然会出现并行工作的情况（总不能 A 先眼巴巴等着 B 开发完再开发吧），在提交历史上我们就会出现分叉。</p>
<p>git 提供了「分支」的概念来支持用户进行分叉操作。<strong>git 的分支本质上只是指向 commit 对象的可变指针</strong>，让我们来详细说明这一点：</p>
<p>在我们新建一个仓库并完成提交（或者从远程同步一个仓库到本地）时，都会发现当前已经存在一个叫做 <code>master</code> 的分支。这是因为 git 默认会创建一个名为 <code>master</code> 的指针，并指向最近一次的 commit 对象。在每次 commit 后，<code>master</code> 指针会跟着移动，指向新生成的 commit 对象。这时候的状态如下图：</p>
<p><img src="../images/branch-1.jpg" alt=""></p>
<p>我们可以创建一个新的分支：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch testing <span class="comment"># 在当前提交对象上创建一个新的指针</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注：git branch 操作中，git 实际上会运行一个 update-ref 指令，有兴趣的同学可以进一步研究。</p>
</blockquote>
<p>于是我们得到这样一个状态：</p>
<p><img src="https://git-scm.com/book/en/v2/images/two-branches.png" alt=""></p>
<p>这里的 <code>master</code> 和 <code>testing</code> 都指向了同一个 commit 对象，且本质上这两个分支（指针）是平等的（<code>master</code> 只不过是 git 默认分支的名字）。问题来了，如果接下来我们要做一个新的提交，是两个分支都跟着移动么？还是只有 <code>master</code>？什么时候 <code>testing</code> 会跟着往前走呢？</p>
<p>这就取决于：<strong>当前我们使用哪一个指针</strong>，或者说：<strong>当前我们在哪个分支上</strong></p>
<p>那接下来的问题就是：git 如何知道当前在哪一个分支上呢？</p>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>答案是 git 使用了名为 <code>HEAD</code> 的特殊指针。git 仓库的 <strong>当前文件</strong> 的状态，总是对应 <code>HEAD</code> 指针所指向的提交对象对应的快照。</p>
<p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt=""></p>
<p>通过 <code>git status</code> 我们可以看到当前我们还是在 <code>master</code> 分支上（尽管我们已经创建了 <code>testing</code> 分支），然后我们可以查看下各个分支指向的对象，这和上面的图例结果是吻合的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">log</span> --oneline --decorate</div><div class="line">f30ab (HEAD, master, testing) add feature <span class="comment">#32 - ability to add new</span></div><div class="line">34ac2 fixed bug <span class="comment">#1328 - stack overflow under certain conditions</span></div><div class="line">98ca9 initial commit of my project</div></pre></td></tr></table></figure>
<p>我们可以通过 <code>checkout</code> 指令让 <code>HEAD</code> 指针从指向 <code>master</code> 改成指向 <code>testing</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout testing</div><div class="line">Switched to branch <span class="string">'testing'</span></div></pre></td></tr></table></figure>
<p>这时 <code>HEAD</code> 指向 <code>testing</code> 分支。</p>
<p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt=""></p>
<blockquote>
<p>注意, 这里不要和 SVN 的 checkout 搞混了, 它们完全不同</p>
</blockquote>
<p>这时如果我们再做一个新的 commit，则 <code>testing</code> 分支（指针）将跟着往前，指向新的 commit，同时 <code>HEAD</code> 也会自觉地跟着新的 commit：</p>
<p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt=""></p>
<p>然后我们可以再让 <code>HEAD</code> 指向 <code>master</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">'master'</span></div></pre></td></tr></table></figure>
<p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" alt=""></p>
<p>最后我们又做一个 commit，让分叉出现，哦豁！</p>
<p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" alt=""></p>
<h3 id="refs-refs"><a href="#refs-refs" class="headerlink" title="refs, refs!"></a>refs, refs!</h3><p>我们现在知道 HEAD 是一个指向当前分支（即一系列 commit 链条上的最后一个）的指针，也知道 <code>master</code> 和 <code>testing</code> 也是指向最后一个 commit 的指针。那它们具体的存在形式是怎样的呢？</p>
<p>我们先从 HEAD 开始研究。让我们再看一次 <code>.git</code> 文件夹的结构：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.git</div><div class="line">├── HEAD</div><div class="line">├── config</div><div class="line">├── description</div><div class="line">├── hooks (若干个 git hook 文件, 此处省略)</div><div class="line">├── info (暂时省略)</div><div class="line">├── objects (git 原始对象存放地点, 省略)</div><div class="line">└── refs</div><div class="line">    ├── heads</div><div class="line">    └── tags</div></pre></td></tr></table></figure>
<p>我们留意到恰好有一个名为 HEAD 的文件。查看它的内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat .git/HEAD</div><div class="line">ref: refs/heads/master</div></pre></td></tr></table></figure>
<p>我们发现 HEAD 文件中提到了 <code>refs/heads/master</code>。让我们来试下切换分支到 testing，更改 HEAD 的指向：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout testing</div><div class="line">$ cat .git/HEAD</div><div class="line">ref: refs/heads/testing</div></pre></td></tr></table></figure>
<p>观察 <code>refs/heads</code> 目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ ls .git/refs/head/</div><div class="line">master  testing</div><div class="line"></div><div class="line">$ cat .git/refs/head/master</div><div class="line">a1a6b4ff321bb2c058632a231fce0e56ab2ab3f3</div><div class="line"></div><div class="line">$ cat .git/refs/head/testing</div><div class="line">a1a6b4ff321bb2c058632a231fce0e56ab2ab3f3</div></pre></td></tr></table></figure>
<p>如果这时我们希望再创建一个新的分支 <code>feat-abc</code>，可以利用上文提及的 <code>git branch</code> 指令。这时候 git 会创建一个新的指针 abc，这个 abc 指向的最后一个 commit 和 testing 一样：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git branch abc</div><div class="line"></div><div class="line">$ ls .git/refs/head</div><div class="line">master  testing  abc</div><div class="line"></div><div class="line">$ cat .git/refs/head/abc <span class="comment"># 注意观察输出的 SHA-1 值, 和上一段例子中 refs/head/testing 一样</span></div><div class="line">a1a6b4ff321bb2c058632a231fce0e56ab2ab3f3</div><div class="line"></div><div class="line">$ git checkout abc <span class="comment"># 切换当前分支到 abc, 即让 HEAD 的值为 refs/head/abc</span></div></pre></td></tr></table></figure>
<p>如果这时候我们再完成一个新的 commit，则当前的分支应用 abc 所指向的 commit 的值自然会发生改变。这就是我们日常开发中的过程了。</p>
<p>可以发现：<code>.git/refs/head</code> 下存放的文件，就是对应着各个现有的分支；且这些文件的内容就是其指向的 commit 的 SHA-1 hash 值。</p>
<p><strong>像 HEAD 和 refs/head/abc 这样的文件，在 git 中可以统称为引用（references, 或缩写为 refs）</strong></p>
<p>引用可以分为几种：HEAD 引用，分支引用，标签引用（tag reference）和远程引用。这里我们不对标签引用做过多的解释（有兴趣的同学可以自行查阅资料），仅对其他几种进行讨论。</p>
<h4 id="HEAD-引用"><a href="#HEAD-引用" class="headerlink" title="HEAD 引用"></a>HEAD 引用</h4><p>在上文例子中提到的 <code>.git/HEAD</code> 就是 HEAD 引用。它是一个符号引用（symbolic reference），指向目前所在的分支。</p>
<p>所谓符号引用是指它本身不包含一个 SHA-1 hash，而是指向了其他的分支引用。如之前的例子所示，如果执行 <code>git checkout testing</code>，git 会将 HEAD 的值设为 <code>ref: refs/heads/testing</code></p>
<blockquote>
<p>注：其实 HEAD 也不是必须指向别的引用，它也是可以像普通引用一样包含一个具体的 commit SHA-1 hash，这样的 HEAD 被称为 detached HEAD</p>
<p>注2：checkout 指令底层所依赖的命令为 symbolic-ref，有兴趣的同学也可以进一步研究。</p>
</blockquote>
<h4 id="分支引用"><a href="#分支引用" class="headerlink" title="分支引用"></a>分支引用</h4><p>在上文例子中提到的 <code>.git/refs/xxx</code> 就是所谓的「分支引用」，它们的主要作用是让我们能够用可理解的代号，来指向某一个特殊的 commit，且允许我们在这个 commit 的基础上进行新的开发（提交 commit）</p>
<h4 id="远程引用"><a href="#远程引用" class="headerlink" title="远程引用"></a>远程引用</h4><p>在开发中我们经常做的第一件事情，就是从某个可访问的地址获取某个项目的已有代码，这个可访问的地址被称为远程仓库。「远程引用」正是指向远程仓库某个分支的引用。</p>
<p>「远程引用」是只读的，它帮助我们记录已知的远程仓库上，各个分支和标签的状态。当然，如果实际上远程仓库发生了变化，本地的「远程引用」不会自动地跟踪；同样，本地也不可以直接修改「远程应用」所指向的分支。当我们做任何网络通信操作时，它会自动移动。它就像是你上次连接到远程仓库时，那些分支所处状态的书签。我们称「远程引用」所指向的远程仓库中的分支为「远程跟踪分支」。</p>
<p>我们可以通过 <code>git ls-remote (remote)</code> 或者 <code>git ls -r</code> 来显式获取远程引用的完整列表，也可以直接查看 <code>refs/remotes</code> 下的文件，比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ls .git/refs/remotes <span class="comment"># 列举所有已知的远程仓库 </span></div><div class="line">origin</div><div class="line">$ ls .git/refs/remotes/origin <span class="comment"># 列举 origin 下已知的引用(分支)</span></div><div class="line">master feat-abc</div><div class="line">$ cat .git/refs/remotes/origin/master <span class="comment"># 查看远程仓库 origin 下 master 分支指向的 commit</span></div><div class="line">....</div></pre></td></tr></table></figure>
<p>由于 git 本地不会自动跟踪远程仓库的任何变化，所以我们需要显式地更新远程仓库的状态。我们可以通过 <code>git fetch</code> 来更新远程仓库上各个分支的最新状态。这里本质上是将远程仓库上各个分支的最新代码变更拉取到本地。</p>
<p>由于它实际上确实是一个本地可访问的分支，所以我们也可以将它合并到本地的某个分支上，比如当前我们位于 <code>master</code> 分支，希望将名为 origin 的远程仓库上最新的 master 分支 合并进来；那么我们可以：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master       <span class="comment"># 切换到 master 分支</span></div><div class="line">$ git fetch origin          <span class="comment"># 更新 origin 下的所有分支</span></div><div class="line">$ git merge origin/master   <span class="comment"># 合并操作</span></div></pre></td></tr></table></figure>
<p>更简单的方法是：我们在 <code>master</code> 分支上直接执行 <code>git pull origin master</code>，git 会自动识别去哪个服务器上抓取合并：<code>git pull origin master</code> =&gt; <code>git fetch origin</code> + <code>git merge origin/master</code></p>
<p>因为这样的操作非常高频，所以 git 允许我们创建所谓的 <strong>跟踪分支（tracking-branch）</strong> 来简化同步代码的操作：我们只需要从一个「远程跟踪分支」中 checkout 出一个新的分支，git 就会认为这个新的分支 “跟踪” 了远程仓库中对应的分支：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout origin/abc</div><div class="line">$ git checkout -b abc</div><div class="line"><span class="comment">## 或者可以这样</span></div><div class="line">$ git checkout --track origin/abc <span class="comment"># 在本地创建一个同名的 abc 分支, 作为 "跟踪分支"</span></div></pre></td></tr></table></figure>
<p>在「跟踪分支」上，我们可以直接用 <code>git pull</code> 而不需要指定对应的远程仓库和分支名称；像大家常见的 <code>git clone</code> 操作，实际上就会将 <code>master</code> 分支设置为 <code>origin/master</code> 分支的「跟踪分支」。</p>
<p>刚才我们简单提到了分支间的 merge 操作，接下来我们来详细分析 git 分支间的合并操作。</p>
<h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>在真实的开发中，我们使用分支，是为了可以将新功能或者模块的开发，拆分到一个独立的环境中，这样我们可以不断地 commit 保存一些过程中的小功能点，而不需要担心这些 commit 会影响到整个系统可用的部分（通常来说，指 master）</p>
<p>让我们来看下这个图：</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt=""></p>
<p>我们可以想象有这样的事情：</p>
<ul>
<li>我们准备开发一个新功能，从 <code>master</code> 分支上建立了一个分支 <code>iss53</code>，并让 HEAD 指向这个分支（其实就是 <code>checkout</code>）</li>
<li>然后我们在 <code>iss53</code> 上做了一个 commit <code>C3</code></li>
<li>随后老板 <del>（很生气地）</del> 告诉我们，线上有一个 bug，要尽快修复它；于是我们切换回 <code>master</code> 分支，然后在 <code>master</code> 分支上重新建立一个叫做 <code>hotfix</code> 的分支，然后在上面做了一个 <code>C4</code> 的 commit，应该可以修复这个紧急问题。</li>
</ul>
<p>好了，接下来该干嘛？—— 我们应该想办法把 <code>hotfix</code> 上的内容合并到原来的 <code>master</code> 分支上。</p>
<p>这时我们就可以用上 <code>git merge</code> 这个功能了：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git checkout master <span class="comment"># 让 HEAD 指向 master</span></div><div class="line">$ git merge hotfix    <span class="comment"># 将 hotfix 的内容合并到 master 分支上</span></div><div class="line">Updating f42c576..3a0874c</div><div class="line">Fast-forward</div><div class="line"> index.html | 2 ++</div><div class="line"> 1 file changed, 2 insertions(+)</div></pre></td></tr></table></figure>
<p>这样的合并属于「快进」（fast-forward）—— 由于 <code>master</code> 分支指向的提交是当前 <code>hotfix</code> 的提交的直接上游，所以 git 只是简单的将 <code>master</code> 的指针向前移动。</p>
<blockquote>
<p>换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做「快进」（fast-forward）。</p>
</blockquote>
<p>完成合并后，我们可以发布这个修复，然后可以回去继续开发新功能了；这时候 <code>master</code> 和 <code>hotfix</code> 都指向同一个 commit 对象。而 <code>iss53</code> 并没有变化。</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt=""></p>
<p>我们可以清理掉不需要的 <code>hotfix</code> 分支，然后继续干活：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git branch <span class="_">-d</span> hotfix <span class="comment"># 删除分支</span></div><div class="line">Deleted branch hotfix (3a0874c).</div><div class="line"></div><div class="line">$ git checkout iss53</div><div class="line">Switched to branch <span class="string">"iss53"</span></div><div class="line"></div><div class="line"><span class="comment"># ... do some work</span></div><div class="line">$ git commit <span class="_">-a</span> <span class="string">'finished issue 53'</span></div><div class="line">[iss53 ad82d7a] finished issue 53</div><div class="line">1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure>
<p>这时候分支的情况：</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt=""></p>
<p>开发好了 —— 现在我们需要把 <code>iss53</code> 这个分支合并回 <code>master</code> 分支。但这时两个分支之间产生了分叉。这时 git 会使用两个分支的最近的 commit <code>C4</code> 和 <code>C5</code>，连同两个分支的公共祖先 <code>C2</code> 一起做一个三方合并：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">'master'</span></div><div class="line">$ git merge iss53</div><div class="line">Merge made by the <span class="string">'recursive'</span> strategy.</div><div class="line">index.html |    1 +</div><div class="line">1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure>
<p>合并结束后，git 会用三方合并的结果创建一个新的 commit 记录下来。这个 commit 被称为 <code>merge commit</code>，它的特别之处在于它有不止一个父 commit：</p>
<p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt=""></p>
<p>这样工作就结束了，所有的修复，连同功能代码都被加到了 master 里面，是时候下班了~~</p>
<h4 id="Merge-Conflict"><a href="#Merge-Conflict" class="headerlink" title="Merge Conflict"></a>Merge Conflict</h4><p>但事情并没有这么顺利，在一些情况下，我们会遇到无法处理合并的情况。比如说，假设刚才我们在 <code>iss53</code> 和 <code>hotfix</code> 的修改中，同时涉及了一个文件的同一处，当合并的时候就会产生一个冲突（conflict）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git merge iss53</div><div class="line">Auto-merging index.html</div><div class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> index.html</div><div class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</div></pre></td></tr></table></figure>
<blockquote>
<p>原则上，git 会尽量自动合并两个分支对一个文件的修改。</p>
</blockquote>
<p>当产生一个冲突时，git 不会自动生成一个 merge commit，而是会暂停下来，等待你去解决合并产生的冲突。可以用 <code>git status</code> 来查看：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">You have unmerged paths.</div><div class="line">  (fix conflicts and run <span class="string">"git commit"</span>)</div><div class="line"></div><div class="line">Unmerged paths:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to mark resolution)</div><div class="line"></div><div class="line">    both modified:      index.html</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure>
<p>这时需要我们手动去解决代码冲突。出现冲突的文件会包含一些特殊区段，类似这样：</p>
<p><img src="../images/git-merge-conflict-example.jpg" alt=""></p>
<p>git 将冲突的双方对该文件的修改，都保留在界面上，用 <code>=========</code> 来分割两部分。我们可以根据实际需要，选择其中的某个部分，或者自行合并内容。很多编辑器（如 VSCode）和 IDE（如 WebStorm）对处理冲突提供了很好的支持，也可以选择借助它们来处理。</p>
<blockquote>
<p>这里最好的方式是拉上另一个分支的同伴（如果有多人协作的话）一起审查这个 conflict，这样可以避免单方面操作对某部分的代码造成意料之外的伤害。</p>
</blockquote>
<p>当解决了所有冲突的文件后，我们可以运行 <code>git status</code> 确认这一事实：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">All conflicts fixed but you are still merging.</div><div class="line">  (use <span class="string">"git commit"</span> to conclude merge)</div><div class="line"></div><div class="line">Changes to be committed:</div><div class="line"></div><div class="line">    modified:   index.html</div></pre></td></tr></table></figure>
<p>如果没有问题，则可以用 <code>git commit</code> 来完成最终的 merge commit。</p>
<blockquote>
<p>另一种情况是：我们发现实在是太难处理了，这时可以直接用 <code>git merge --abort</code> 取消这次合并的尝试 —— 这等于我们从来没有做过合并。然后我们叫一个老司机来协助解决这个问题。</p>
</blockquote>
<h2 id="回到-pack-的问题"><a href="#回到-pack-的问题" class="headerlink" title="回到 pack 的问题"></a>回到 pack 的问题</h2><p>说了这么多，让我们回到文章开头的问题：</p>
<blockquote>
<p><code>xxx.pack</code> 文件是什么东西? 为什么它会这么大?</p>
</blockquote>
<p>接下来我们逐个回答。</p>
<h3 id="Packfile"><a href="#Packfile" class="headerlink" title="Packfile"></a>Packfile</h3><p>为了解释 packfile 的作用，我们基于 <a href="#举一个栗子">举一个栗子</a> 中的 git 仓库，做一些操作：</p>
<p>首先我们向仓库提交一个体积较大的源文件。这里我们选取 <a href="https://vuejs.org" target="_blank" rel="noopener">vue.js</a> 源代码中 vdom 的核心代码 <a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/patch.js" target="_blank" rel="noopener"><code>patch.js</code></a>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ curl https://raw.githubusercontent.com/vuejs/vue/dev/src/core/vdom/patch.js &gt; src/patch.js</div><div class="line">$ git add src/patch.js</div><div class="line">$ git commit -m <span class="string">'added patch.js'</span></div></pre></td></tr></table></figure>
<p>观察 git 对 <code>patch.js</code> 的记录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git cat-file -p master^&#123;tree&#125; <span class="comment"># 查看当前 commit 记录下引用的 git 对象节点列表</span></div><div class="line">100644 blob edafe27e250ef26f694b25afce81bdaf96f44eb0	Readme.md</div><div class="line">040000 tree 8c6b7113372ebc4882180bff942b0ab02439aacc	src</div><div class="line"></div><div class="line">$ git cat-file -p 8c6b7113372ebc4882180bff942b0ab02439aacc <span class="comment"># 查看 src/ 下所有文件的 git 对象信息</span></div><div class="line">100644 blob bdacba00da0ef745a2bdfdee7844ecc97db19cb0	index.js</div><div class="line">100644 blob 2052df913b3f240f0407673b775a554d964<span class="built_in">cd</span>15a	patch.js</div><div class="line"></div><div class="line">$ git cat-file <span class="_">-s</span> 2052df913b3f240f0407673b775a554d964<span class="built_in">cd</span>15a <span class="comment"># patch.js 大小大概是 26.5kb</span></div><div class="line">26565</div></pre></td></tr></table></figure>
<p>现在我们稍微对 <code>patch.js</code> 做一些修改：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">'// appending one testing line'</span> &gt;&gt; src/patch.js</div><div class="line">$ git commit -am <span class="string">'modified patch.js'</span></div><div class="line">[master b823eae] modified patch.js</div><div class="line"> 1 file changed, 1 insertion(+)</div></pre></td></tr></table></figure>
<p>重新观察 <code>patch.js</code>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git cat-file -p master^&#123;tree&#125;</div><div class="line">100644 blob edafe27e250ef26f694b25afce81bdaf96f44eb0	Readme.md</div><div class="line">040000 tree ce9de001b849100b9405720c93fb5e54eac178dc	src</div><div class="line"></div><div class="line">$ git cat-file -p ce9de001b849100b9405720c93fb5e54eac178dc</div><div class="line">100644 blob bdacba00da0ef745a2bdfdee7844ecc97db19cb0	index.js</div><div class="line">100644 blob aa79e3510892b6213cdd6f84aa321f00abb6eb70	patch.js</div></pre></td></tr></table></figure>
<p>可以看到，<code>patch.js</code> 对应一个全新的 git blob 对象；也就是说，即便我们只是对文件做了1行的修改，git 也会重新生成一个新的文件的“副本”：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git cat-file <span class="_">-s</span> aa79e3510892b6213cdd6f84aa321f00abb6eb70 <span class="comment"># patch.js 大小几乎没有发生变化, 但这个 git 对象已经是一个全新的了</span></div><div class="line">26595</div></pre></td></tr></table></figure>
<p>在实际开发中，我们经常会对文件进行反复的修改，如果每次修改 git 都要重新生成一个副本，那仓库的实际体积将迅速增大！有没有办法只记录每次提交的变更内容，而不是单纯的将整个文件的状态完全保留下来呢？</p>
<p>事实上 git 是可以这么做的。刚才我们看到的 git 存储对象时所使用的格式被称为“松散（loose）“对象格式。但 git 会时不时将多个对象打包成一个称为 packfile 的二进制文件，以节省空间和提高效率。当版本库中有太多的松散对象时，git 会在我们和远程仓库进行通信（推送或拉取）时自动进行打包操作。</p>
<p>我们也可以通过 <code>git gc</code> 指令手动触发打包行为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git gc</div><div class="line">Counting objects: 15, done.</div><div class="line">Delta compression using up to 8 threads.</div><div class="line">Compressing objects: 100% (12/12), done.</div><div class="line">Writing objects: 100% (15/15), done.</div><div class="line">Total 15 (delta 1), reused 0 (delta 0)</div></pre></td></tr></table></figure>
<p>这时候如果我们再观察 git 数据库的对象，则会发现我们在例子中看到的各个文件的副本都消失了，取而代之的是两个后缀分别为 <code>.idx</code> 和 <code>.pack</code> 的文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ find .git/objects -type f</div><div class="line">.git/objects/pack/pack-fb3f62dbf81ab8480462c2d7edfe36785c090c34.idx</div><div class="line">.git/objects/pack/pack-fb3f62dbf81ab8480462c2d7edfe36785c090c34.pack</div><div class="line">.git/objects/info/packs</div></pre></td></tr></table></figure>
<p>分别观察这两个文件，发现它们的体积都很小：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ du -sh .git/objects/pack/pack-fb3f62dbf81ab8480462c2d7edfe36785c090c3.pack</div><div class="line">8.0K	.git/objects/pack/pack-fb3f62dbf81ab8480462c2d7edfe36785c090c34.pack</div><div class="line"></div><div class="line">$ du -sh .git/objects/pack/pack-fb3f62dbf81ab8480462c2d7edfe36785c090c3.idx</div><div class="line">4.0K	.git/objects/pack/pack-fb3f62dbf81ab8480462c2d7edfe36785c090c34.idx</div></pre></td></tr></table></figure>
<p>这两个文件分别就是 packfile 和它的索引：</p>
<ul>
<li>packfile 包含了刚才从文件系统中移除的所有对象的内容</li>
<li>索引文件包含了包文件的偏移信息</li>
</ul>
<p>我们通过索引文件就可以快速定位任意一个指定对象。观察打包前后的仓库大小，我们发现通过打包对象减少了 2/3 的磁盘占用空间。</p>
<p>git 是如何做到这点的？git 打包对象时，会查找命名及大小相近的文件，并只保存文件不同版本之间的差异内容。我们可以利用 <code>git verify-pack</code> 这个底层命令查看已打包的内容：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">git-example-repo on  master ➜ git verify-pack -v .git/objects/pack/pack-fb3f62dbf81ab8480462c2d7edfe36785c090c34.idx</div><div class="line">b823eae6cbbf9c2109ba3bee65ce6dc15768f585 commit 230 159 12</div><div class="line">5f84f91f1166877d492f63b85ed7883b442b8bea commit 227 158 171</div><div class="line">8fd15dbfbba5fd5b981de38f5177c8029693f4fb commit 231 157 329</div><div class="line">120c03e073cdf409403224c406fdfb022a63e750 commit 175 122 486</div><div class="line">edafe27e250ef26f694b25afce81bdaf96f44eb0 blob   29 36 608</div><div class="line">bdacba00da0ef745a2bdfdee7844ecc97db19cb0 blob   52 54 644</div><div class="line">aa79e3510892b6213cdd6f84aa321f00abb6eb70 blob   26595 6886 698</div><div class="line">a14f60a7108b2693373c6206270f20078e67cf32 tree   67 78 7584</div><div class="line">ce9de001b849100b9405720c93fb5e54eac178dc tree   72 79 7662</div><div class="line">9fcd22f080fe51922392d4a8b1ef368c40193b0d tree   67 77 7741</div><div class="line">8c6b7113372ebc4882180bff942b0ab02439aacc tree   72 78 7818</div><div class="line">2052df913b3f240f0407673b775a554d964<span class="built_in">cd</span>15a blob   9 20 7896 1 aa79e3510892b6213cdd6f84aa321f00abb6eb70</div><div class="line">e05e71a0142e288df830343f06c2e9549511b159 tree   67 78 7916</div><div class="line">ffcee3ab51c6a5903bc8a9ca9378a5672e44ea36 tree   36 47 7994</div><div class="line">490e706c59461270e6f3c0d47356ac84e8c0bc1b tree   37 48 8041</div><div class="line">non delta: 14 objects</div><div class="line">chain length = 1: 1 object</div><div class="line">.git/objects/pack/pack-fb3f62dbf81ab8480462c2d7edfe36785c090c34.pack: ok</div></pre></td></tr></table></figure>
<p>这里的输出内容中，第3列就是 git 打包后对象的体积大小。我们可以留意下关于 <code>patch.js</code> 的两个 blob 对象的记录（读者可以向上对照下 SHA-1 hash 值）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aa79e3510892b6213cdd6f84aa321f00abb6eb70 blob   26595 6886 698</div><div class="line">2052df913b3f240f0407673b775a554d964cd15a blob   9 20 7896 1 aa79e3510892b6213cdd6f84aa321f00abb6eb70</div></pre></td></tr></table></figure>
<p>其中第1行是 <code>patch.js</code> 第2个副本的记录，文件大小没有变化；而第2行中指向 <code>patch.js</code> 的最早的副本，大小只有9个字节，且附带了一个指向最新副本的指针。这里正是 git 通过内部 diff 的方式，将提交本身的变更内容保留了下来（并做了压缩），最终加入到 packfile 中。</p>
<p>那么至此我们可以简单地回答文章开头的问题了：</p>
<ul>
<li><code>.pack</code> 文件是 git 的 packfile，是 git 打包操作后对松散 git 对象的压缩整合，最大限度地减少了磁盘占用的空间</li>
<li><code>.pack</code> 文件庞大的原因，是因为它需要保留整个 git 仓库绝大部分历史提交的信息</li>
</ul>
<p>但问题还是存在的：我们的实习生用了1个小时来下载代码！如何解决这个问题呢？</p>
<h3 id="git-仓库的清理"><a href="#git-仓库的清理" class="headerlink" title="git 仓库的清理"></a>git 仓库的清理</h3><p>如果我们去观察一些已有的开发仓库，通常会发现 <code>.git/objects/pack</code> 里有不止一个 <code>.pack</code> 和 <code>.idx</code> 文件，而且有些 <code>.pack</code> 非常的庞大。事实上，如果某个人在之前向项目添加了一个大小特别大的文件，即使你将这个文件从项目中移除了，每次克隆还是都要强制的下载这个大文件。 之所以会产生这个问题，是因为这个文件在历史中是存在的，它会永远在那里。</p>
<p>所以为了从根本上避免这个问题，我们需要对 git 提交历史上出现过的大文件进行永久的清理。这是一个非常麻烦的事情，读者可以参考以下几篇文章：</p>
<ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D</a></li>
<li><a href="https://stackoverflow.com/questions/11050265/remove-large-pack-file-created-by-git" target="_blank" rel="noopener">https://stackoverflow.com/questions/11050265/remove-large-pack-file-created-by-git</a></li>
<li><a href="https://help.github.com/en/articles/removing-sensitive-data-from-a-repository" target="_blank" rel="noopener">https://help.github.com/en/articles/removing-sensitive-data-from-a-repository</a></li>
</ul>
<p>当然，我也会尽快地在我们的开发仓库上应用一些实践，后续会在这里补充更多的操作方式细节。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git, 2nd Edition</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/45510461" target="_blank" rel="noopener">深入理解 git 实现原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53750883" target="_blank" rel="noopener">放弃理解 git（一）：git 内部原理</a></li>
<li><a href="https://juejin.im/post/5c714d18f265da2d98090503#heading-8" target="_blank" rel="noopener">图解git原理与日常实用指南</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/using-branches/merge-strategy" target="_blank" rel="noopener">git Merge Stretegy Options and Examples</a></li>
<li><a href="https://mincong-h.github.io/2018/04/28/git-index/" target="_blank" rel="noopener">git: Understanding the Index File</a></li>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D</a></li>
<li><a href="https://stackoverflow.com/questions/11050265/remove-large-pack-file-created-by-git" target="_blank" rel="noopener">https://stackoverflow.com/questions/11050265/remove-large-pack-file-created-by-git</a></li>
<li><a href="https://help.github.com/en/articles/removing-sensitive-data-from-a-repository" target="_blank" rel="noopener">https://help.github.com/en/articles/removing-sensitive-data-from-a-repository</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个月前，团队来了个新的实习生。我们让他协助开发一个 Java 服务。第二天发生了一个鬼故事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;实习生花了1个小时来下载 git 工作仓库&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://afantasy.ninja/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>iFrame 那些事</title>
    <link href="http://afantasy.ninja/2018/07/15/dive-into-iframe/"/>
    <id>http://afantasy.ninja/2018/07/15/dive-into-iframe/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2018-07-21T18:14:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>基本上稍有一定开发经历的 Web 开发者都多少会和 <code>&lt;iframe&gt;</code> 打过交道，但在最近连续接触了几个相关的需求之后，我却突然意识到，自己对 iFrame 并不是非常的了解，这就是本文的由来。</p>
<a id="more"></a>
<p>在介绍 iFrame 之前，我们首先来了解一下 <strong>浏览上下文</strong>。</p>
<h2 id="浏览上下文（Browsing-Context）"><a href="#浏览上下文（Browsing-Context）" class="headerlink" title="浏览上下文（Browsing Context）"></a>浏览上下文（Browsing Context）</h2><p>根据 <a href="http://w3c.github.io/html/browsers.html#sec-browsing-contexts" target="_blank" rel="noopener">HTML 规范</a>中的定义：</p>
<blockquote>
<p>一个 <strong>浏览上下文</strong> 是一个浏览器向用户展示文档对象的环境。</p>
</blockquote>
<p>浏览上下文包含以下内容：</p>
<ol>
<li>一个 WindowProxy 对象，它包裹了一个当前窗口对象（Window），在浏览器的 JS 环境中我们只能用 <code>window</code> 关键字来获取到其对应的窗口对象。</li>
<li>一份用户的会话历史记录（<em>Session history</em>），记录了该浏览器上下文展示过的所有文档（Document）对象。</li>
<li>记录一个当前活跃的文档（<em>active document</em>），这个文档就是上下文对应的窗口对象所关联的文档对象（<em>associated Document</em>），即当前打开的文档对象。这个文档对象在窗口对象被创建时被设置，且只有在页面导航发生变化时才会变化。我们可以用 <code>document</code> 全局对象拿到当前打开的文档对象。</li>
</ol>
<p>从类型上，有几种不同的浏览上下文：</p>
<ol>
<li>浏览器的一个 tab 或者一个窗口</li>
<li><code>&lt;iframe&gt;</code></li>
<li>在 <code>&lt;frameset&gt;</code> 元素内的一个 <code>&lt;frame&gt;</code></li>
</ol>
<p>其中 <code>&lt;frameset&gt;</code> 的做法已经过时，并已被移出 Web 标准（取而代之的实现方案是 <code>&lt;iframe&gt;</code>）。</p>
<p>如果从结构上来看，浏览上下文是可嵌套的：文档内的某些元素如 <code>&lt;iframe&gt;</code> 可以实例化一个新的浏览上下文，这些元素被称为 <strong>浏览上下文容器（browsing context container）</strong>，而实例化的浏览上下文则被称为是 <strong>嵌套的浏览上下文（nested browsing context）</strong>；而对于某个嵌套的浏览上下文，其容器所在的文档对应的浏览器上下文，则可以被称为 <strong>父浏览上下文（parent browsing context）</strong>，且一定是唯一的。</p>
<p>对于浏览器的 tab 或者窗口来说，不存在比它更高一级的父上下文，所以它们可以被称为 <strong>顶级浏览上下文（top-level browsing context）</strong>。</p>
<p><img src="/images/browsing_context.png" alt=""></p>
<h2 id="iFrame-由来"><a href="#iFrame-由来" class="headerlink" title="iFrame 由来"></a>iFrame 由来</h2><p>我们现在了解了 <strong>浏览上下文</strong> 的概念，也知道 <code>&lt;iframe&gt;</code> 元素可以在一个文档内创建一个 <strong>嵌套的浏览上下文</strong>，但为什么要有 iFrame 的存在呢？这就要回顾一下 Web 早期的发展历程了。</p>
<p>在很久很久之前（咳咳），使用多窗口页面（frames）来创建网站是一种比较流行的手段，人们将一个大的网站拆分成多个 HTML 页面，每个页面独立的放到一个 <code>&lt;frame&gt;</code> 元素中，再通过 <code>&lt;frameset&gt;</code> 元素将这些 frame 元素包含在一起，开发者甚至可以用 <code>cols</code> 或者 <code>rows</code> 属性来控制每个 frame 页面所占据的位置大小，有点像 table 布局：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 很遗憾 这段 HTML 代码在现代浏览器上已经失效了 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">frameset</span> <span class="attr">cols</span>=<span class="string">"50%,50%"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"https://developer.mozilla.org/en/HTML/Element/frameset"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">frame</span> <span class="attr">src</span>=<span class="string">"https://developer.mozilla.org/en/HTML/Element/frame"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">frameset</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这样做当然不是闲着蛋疼，而是因为当时有充分的证据证明，将一个网页切分成多个小的页面，在当时下载速度还比较慢的时候，是有利于页面加载的，至少可以保证某些页面的内容先加载好并展示出来。但随着时间推移，网速变快之后，这样的做法就显得没有任何必要了。（当然，到了 2010 年后，类似的做法又重新的被搬出来，有兴趣的同学可以搜索一下 bigpipe）</p>
<p>而到了上世纪90年代末期和21世纪初，Java Applets 和 Flash 技术盛行，允许 Web 开发者向页面中嵌入类似视频和动画的高级内容，当时是通过 <code>&lt;object&gt;</code> 和 <code>&lt;embed&gt;</code> 元素来完成的，并确实达到了一些效果，但后续接连冒出了安全性、可访问性、文件大小等问题，加上移动端浏览器不支持此类插件，于是该方案又渐渐被抛弃。</p>
<p>最终，是 <code>&lt;iframe&gt;</code> 元素，作为 HTML4 的标准，成为了事实上的嵌入页面的通用做法，这极大地方便 Web 开发者，可以在页面上嵌入来自第三方站点的内容，如优酷，Youtube 等：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- Youtube: 10 Things I Regret About Node.js - Ryan Dahl - JSConf EU 2018 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">"560"</span> <span class="attr">height</span>=<span class="string">"315"</span> <span class="attr">src</span>=<span class="string">"https://www.youtube.com/embed/M3BM9TB-8yA"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">allow</span>=<span class="string">"autoplay; encrypted-media"</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="iFrame-的特性"><a href="#iFrame-的特性" class="headerlink" title="iFrame 的特性"></a>iFrame 的特性</h2><p>由于 <code>&lt;iframe&gt;</code> 实际上是一个独立的浏览上下文，所以它有以下几个特点：</p>
<ol>
<li>和父文档完全隔离的 CSS 和 JS</li>
<li>同源的 HTTP 文档和其内嵌的 <code>&lt;iframe&gt;</code> 元素可以通过 JS 互相获取到对方的窗口对象，并进行任意的操作。（非同源的窗口间不可以，使用 HTTPS 的协议也不可以）</li>
<li><code>&lt;iframe&gt;</code> 内部发生的页面跳转导航，不会对父浏览上下文（即父窗口）产生任何影响</li>
<li><code>&lt;iframe&gt;</code> 事实上会创建一个新的 Viewport（文章后面会专门讨论）</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 从顶部文档获取 iFrame 文档:</span></div><div class="line">iframeElement.contentWindow.document</div><div class="line"></div><div class="line"><span class="comment">// 从 iFrame 文档获取父文档</span></div><div class="line"><span class="built_in">window</span>.top.document</div></pre></td></tr></table></figure>
<h2 id="iFrame-的安全性"><a href="#iFrame-的安全性" class="headerlink" title="iFrame 的安全性"></a>iFrame 的安全性</h2><p>由于 iFrame 几乎是当前 HTML 标准唯一可以直接引入第三方页面（或者，被第三方页面引入）的方法。如何保证其中的安全性是一个非常重要的问题。</p>
<h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>假设我们在文档内引入了一个 <code>&lt;iframe&gt;</code> 文档。根据 DOM 提供的 API，理论上在主文档的 JS 中，我们可以通过 <code>iframeElement.contentDocument</code> 或 <code>inframeElement.contentWindow</code> 来获取 iFrame 对应的文档对象或窗口，甚至通过操纵这两个对象的方法获取 <code>&lt;iframe&gt;</code> 内文档的 DOM 元素，并进行任意的操作。</p>
<p>但这样的操作是不能被接受的，因为这意味着任何页面都可以通过这样的方式，利用 JS 操纵另一个网站的页面。浏览器通过<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">同源策略（Same-origin Policy）</a>来限制这样的行为。</p>
<p>所谓“同源”，是指两个网站的 <code>协议+域名+端口</code> 是完全一致的，只要有一个不一致，则视作两个地址是非同源的。</p>
<p>当一个主页面尝试用以上的 JS 方法访问其嵌套的非同源 <code>&lt;iframe&gt;</code> 时，浏览器会返回以下错误：</p>
<blockquote>
<p>Uncaught DOMException: Failed to read the ‘contentDocument’ property from ‘HTMLIFrameElement’: Blocked a frame with origin “<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000</a>“ from accessing a cross-origin frame.</p>
<p>Uncaught DOMException: Blocked a frame with origin “<a href="https://xxx.example.com" target="_blank" rel="noopener">https://xxx.example.com</a>“ from accessing a cross-origin frame.<br>    at <anonymous>:1:18</anonymous></p>
</blockquote>
<h4 id="（插播）iFrame-与主文档的通信"><a href="#（插播）iFrame-与主文档的通信" class="headerlink" title="（插播）iFrame 与主文档的通信"></a>（插播）iFrame 与主文档的通信</h4><p>最初 NetScape 提出同源策略时，其出发点是保证主文档并不能随意的操纵第三方的网站，但这也的确给开发者带来了一定的困扰。因为同源策略的检查非常严格，甚至不允许两个一级域名相同的文档间互相直接访问（如 <code>a.example.com</code> 和 <code>b.example.com</code>），但在某些场景下，开发者同时拥有两个域名下的页面，且希望两个页面间可以进行数据通信。</p>
<p>于是在早期，人们提出了若干个解决方案：</p>
<ol>
<li>通过在主页面和 <code>&lt;iframe&gt;</code> 中设置 <code>document.domain</code> 为同一个一级域名，来绕过同源策略的限制</li>
<li>利用 <code>location</code> 的特性，不同域的页面，可以写不可读，让父子页面互相写对方的 location 的哈希部分进行通讯：<ol>
<li>新建iframe，使用iframe访问一个非同源的地址（发请求），参数里带上父页面url；</li>
<li>当页面加载完成后，iframe内脚本设置父页面的url并在哈希部分带上数据；</li>
<li>父页面的脚本循环检查哈希值的变化，如果检查到有值就取值并清空哈希值；</li>
</ol>
</li>
</ol>
<p>而当 <code>window.postMessage</code> 出现后，一切都变成了浮云。<code>postMessage</code> <a href="https://caniuse.com/#search=postMessage" target="_blank" rel="noopener">支持 IE8+ 及所有现代浏览器</a>，且使用方式非常简单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 主 HTML: https://a.example.com/index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"child-iframe"</span> <span class="attr">src</span>=<span class="string">"https://b.example.com/index.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="keyword">var</span> iframeElement = <span class="built_in">document</span>.getElementById(<span class="string">'child-iframe'</span>)</div><div class="line">    iframeElement.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        iframeElement.contentWindow.postMessage(&#123; <span class="attr">data</span>: <span class="number">1</span> &#125;, <span class="string">'*'</span>)</div><div class="line">    &#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 被嵌入的 HTML: https://b.example.com/index.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> origin = event.origin</div><div class="line">        <span class="keyword">var</span> data = event.data</div><div class="line">        <span class="comment">// 1. 根据业务逻辑判断 origin 的合法性</span></div><div class="line">        <span class="comment">// 2. 处理 data</span></div><div class="line">    &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="被引入的困扰"><a href="#被引入的困扰" class="headerlink" title="被引入的困扰"></a>被引入的困扰</h4><p>那么，既然 iFrame 可以允许在一个网页中嵌入任意的一个第三方的页面，那就意味着，我们编写的网页，是完全有可能被任何一个第三方的网站通过 <code>&lt;iframe&gt;</code> 引入的。而这些引入方，很可能带有恶意的攻击目的。</p>
<p><strong>点击劫持（Clickjacking）</strong> 就是一种非常经典的攻击方式，也叫 <em>界面伪装</em>，通过在网页中将部分内容通过隐藏在看似无害的内容（如按钮）下，诱使用户点击。配合 <code>&lt;iframe&gt;</code> 使用的套路非常简单，假设攻击者希望对 Facebook 进行点击劫持：</p>
<ol>
<li>将一个访客诱骗到一个钓鱼页面（方式可以有很多种）</li>
<li>页面本身看上去人畜无害，且带有一些诱导用户点击的内容（比如 <code>点击这里，赚大钱</code>，或者 <code>想寻求一些♂刺激吗？点击这里</code>）</li>
<li>实际上，钓鱼页面将一个 <code>src</code> 指向 Facebook 站点的 <code>&lt;iframe&gt;</code> 嵌入到页面中，且这个 iFrame 元素是透明的，覆盖在诱导用户点击的区域上方（但访客是看不到的）</li>
<li>只要用户尝试去点击，就会事实上点击 <code>&lt;iframe&gt;</code> 中的某个按钮，比如 <code>点赞</code> 等等。</li>
</ol>
<p>就是这么简单的攻击方式，在2009年造成了一次<a href="http://shiflett.org/blog/2009/twitter-dont-click-exploit" target="_blank" rel="noopener">小轰动</a>：在 Twitter 上突然有大量的人开始转发一条 Twiiter：</p>
<blockquote>
<p>Don’t Click: <a href="http://tinyurl.com/amgzs6" target="_blank" rel="noopener">http://tinyurl.com/amgzs6</a></p>
</blockquote>
<p>当访客点入到这个页面时，会发现这个页面里只有简单的一个按钮，上面写着 <code>Don&#39;t Click!</code>，出于好奇心，多数的访客都会尝试点一下这个按钮，而当按钮被点下去的瞬间，用户所使用的 Twitter 账号便会转发相同的一条推。</p>
<p>读者可以戳下<a href="https://javascript.info/article/clickjacking/clickjacking/" target="_blank" rel="noopener">这个例子</a>，查看页面元素感受下具体的攻击方式。</p>
<p>幸亏，浏览器为我们提供了相关机制来避免自己的站点被第三方随意嵌入。通过在页面的返回报头中设置 <code>X-Frame-Options</code>，我们可以控制自己的页面被引入的限制：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X-Frame-Options: DENY           <span class="comment"># 不允许任何站点引用</span></div><div class="line">X-Frame-Options: SAMEORIGIN     <span class="comment"># 仅允许同源站点引用</span></div><div class="line">X-Frame-Options: ALLOW-FROM https://example.com <span class="comment"># 允许某个站点引用</span></div></pre></td></tr></table></figure>
<p>比如说 <code>https://google.com</code> 就设置了同源引用的策略：</p>
<p><img src="/images/google_x_frame_options.png" alt=""></p>
<h2 id="几种使用姿势"><a href="#几种使用姿势" class="headerlink" title="几种使用姿势"></a>几种使用姿势</h2><p>尽管在设计之初，iFrame 可能只是扮演一个嵌入第三方内容的角色，但在 Web 开发的实际发展历程中，有很多功能是凭借 iFrame 实现的。</p>
<h4 id="在线编辑器"><a href="#在线编辑器" class="headerlink" title="在线编辑器"></a>在线编辑器</h4><p>相信很多人有使用过类似 Codepen 或者 JSFiddle 一类的在线编辑器。这类编辑器通常由两部分组成，一部分支持用户在编辑框中编写代码，另一部分实时展示用户写入代码所对应的页面。这个 “实时展示” 的部分就是采用了 <code>&lt;iframe&gt;</code> 元素，其中包裹的 HTML 页面及效果正是使用了用户编写的代码。</p>
<p>读者也许会问，用户在编辑框里编写的 HTML，CSS 和 JS 代码是如何作用于 <code>&lt;iframe&gt;</code> 的？以下以 Codepen 为例子，介绍基本的实现流程。</p>
<p><strong><em>实时更新 HTML 和 JS 代码</em></strong></p>
<p>若用户修改 HTML 或 JS 编辑框内的代码，则拼接出一段 HTML 字符串，并发起一个 POST 请求。POST 请求中还带有一个随机生成的 key：</p>
<figure><img src="/images/codepen_step_1.png"><figcaption>用户输入的 HTML 和 JS 代码都被包含在请求的 <code>html</code> 字符串中</figcaption></figure>

<p>在延迟大约半秒之后 <code>&lt;iframe&gt;</code> 元素的 <code>src</code> 值被修改为对应 key 的一个 URL 地址：</p>
<figure><img src="/images/codepen_step_2.png"><figcaption>注意 iFrame 元素的 <code>id</code> 属性，和上图请求中的 key 参数一样</figcaption></figure>

<p>此处一个合理的猜测是：服务端在接受到 POST 请求后，根据请求中的 key 值生成了一个新的文件目录，同时在该目录下新建一个名为 <code>index.html</code> 的 HTML 文件。这样 <code>&lt;iframe&gt;</code> 在刷新后，所访问的页面就正好是 POST 请求中带上的 HTML 文本。</p>
<p><strong><em>实时更新 CSS 代码</em></strong></p>
<p>若用户修改的是 CSS 代码，页面不会发起类似上述的请求，而是通过 <code>window.postMessage</code> 的方式，同 <code>&lt;iframe&gt;</code> 元素进行跨域通信。以下是 Codepen 的实现代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CSSReload = &#123;</div><div class="line">    <span class="attr">head</span>: <span class="literal">null</span>,</div><div class="line">    <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>._storeHead(),</div><div class="line">        <span class="keyword">this</span>._listenToPostMessages()</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_storeHead</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.head = <span class="built_in">document</span>.head || <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_shouldHandleMessage</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> e.origin.match(<span class="regexp">/codepen/</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_listenToPostMessages</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 监听主窗口（即 Codepen 主页面）中用 window.postMessage 发出的事件</span></div><div class="line">        <span class="keyword">var</span> e = <span class="keyword">this</span>;</div><div class="line">        <span class="built_in">window</span>[<span class="keyword">this</span>._eventMethod()](<span class="keyword">this</span>._messageEvent(), <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 判断是否处理事件</span></div><div class="line">                <span class="keyword">if</span> (!e._shouldHandleMessage(t))</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                <span class="keyword">var</span> s = <span class="built_in">JSON</span>.parse(t.data);</div><div class="line">                <span class="string">"string"</span> == <span class="keyword">typeof</span> s.css &amp;&amp; e._refreshCSS(s)</div><div class="line">            &#125; <span class="keyword">catch</span> (e) &#123;&#125;</div><div class="line">        &#125;, !<span class="number">1</span>)</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_messageEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"attachEvent"</span> === <span class="keyword">this</span>._eventMethod() ? <span class="string">"onmessage"</span> : <span class="string">"message"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_eventMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">window</span>.addEventListener ? <span class="string">"addEventListener"</span> : <span class="string">"attachEvent"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_refreshCSS</span>: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        <span class="comment">// 删除 iFrame 窗口文档中原有的 &lt;style&gt; 样式</span></div><div class="line">        <span class="comment">// 插入新的 &lt;style&gt; 样式</span></div><div class="line">        <span class="keyword">var</span> t = <span class="keyword">this</span>._findPrevCPStyle()</div><div class="line">          , s = <span class="built_in">document</span>.createElement(<span class="string">"style"</span>);</div><div class="line">        s.type = <span class="string">"text/css"</span>,</div><div class="line">        s.className = <span class="string">"cp-pen-styles"</span>,</div><div class="line">        s.styleSheet ? s.styleSheet.cssText = e.css : s.appendChild(<span class="built_in">document</span>.createTextNode(e.css)),</div><div class="line">        <span class="keyword">this</span>.head.appendChild(s),</div><div class="line">        t &amp;&amp; t.parentNode.removeChild(t),</div><div class="line">        <span class="string">"prefixfree"</span> === e.css_prefix &amp;&amp; StyleFix.process()</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">_findPrevCPStyle</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> e = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"style"</span>), t = e.length - <span class="number">1</span>; t &gt;= <span class="number">0</span>; t--)</div><div class="line">            <span class="keyword">if</span> (<span class="string">"cp-pen-styles"</span> === e[t].className)</div><div class="line">                <span class="keyword">return</span> e[t];</div><div class="line">        <span class="keyword">return</span> !<span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">CSSReload.init();</div></pre></td></tr></table></figure>
<p>可能读者会问，既然 <code>&lt;iframe&gt;</code> 窗口和主窗口都是位于同一个主域名（<code>codepen.io</code>）下，为什么不可以尝试用设置 <code>document.domain</code> 的方式，让主窗口可以直接通过 JS 操作 iFrame 呢？理论上这可能是可行的，但由于 Codepen 是全站使用 HTTPS 的（作为一个成熟的网站，你当然 <a href="https://github.com/jasonGeng88/blog/blob/master/201705/https.md" target="_blank" rel="noopener">应该</a> <a href="https://zhuanlan.zhihu.com/p/29022279" target="_blank" rel="noopener">使用</a> <a href="https://en.wikipedia.org/wiki/HTTPS" target="_blank" rel="noopener">HTTPS</a>），浏览器会禁止主窗口和 <code>&lt;iframe&gt;</code> 之间任何可能的 JS 相互调用。</p>
<h4 id="解决跨域请求问题"><a href="#解决跨域请求问题" class="headerlink" title="解决跨域请求问题"></a>解决跨域请求问题</h4><p>这个估计也是很多人初识 iFrame（或者说，实战 iFrame）的实际场景了，由于过程实在是太 hack，以及确实除了 hack 的技巧本身外并没有任何工程价值，所以我做出了一个艰难的决定：</p>
<blockquote>
<p>我不详细讨论这个问题了。</p>
</blockquote>
<p>毕竟在跨域请求方案上，早就有 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">CORS</a> 和 <a href="https://zh.wikipedia.org/zh/JSONP" target="_blank" rel="noopener">JSONP</a> 了，不去使用这种成熟方案，而来纠结 iFrame 的奇技淫巧的，恕我直言都真的是浪费自己的青春…</p>
<p>有兴趣的读者可以看 SegmentFault 上的 <a href="https://segmentfault.com/a/1190000014223524#articleHeader4" target="_blank" rel="noopener">这篇文章</a>，总结的很全面了（话说 SegmentFault 是做的越来越不错了，果然好东西都要靠积累，做时间的朋友啊…）</p>
<p>或者也可以看另一篇博客：<a href="https://wangningbo93.github.io/2017/06/16/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8D%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">浅谈几种跨域的方法</a></p>
<h4 id="Comet-中的永久帧"><a href="#Comet-中的永久帧" class="headerlink" title="Comet 中的永久帧"></a>Comet 中的永久帧</h4><p><strong>Comet</strong> 一词最早是由 Alex Russell（Dojo 库的作者）在 2006 年的一篇博客 <em><a href="http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/" target="_blank" rel="noopener">Comet: Low Latency Data for the Browser</a></em>  中首先提出，描述从服务端向浏览器“推送”数据的一系列手段，包括协议和具体技术实现。</p>
<p>如果从今天的角度来回看”向服务器推送数据“这个诉求，很容易就想到 WebSocket，对吧？但事物是处于不断发展的阶段的…WebSocket 协议在 2011 年才成为标准，浏览器厂商也是在 2010~2011 年之间先后推出了支持该协议的版本。但需求，是一定要 <strong>通过各种手段</strong> 完成的，Comet 就是各种手段的一种统称，也被称为 “Ajax Push”, “Reverse Ajax”, “HTTP Server Push” 等等。</p>
<p>Comet 的实现有若干种具体的手段：</p>
<ol>
<li>长轮询（Long polling）</li>
<li>永久帧（Forever Frame）</li>
<li>XHR 流（XMLHttpRequest Streaming）</li>
</ol>
<p>这里要说的是永久帧的实现。所谓“永久帧”，是指在当前文档内创建一个 <code>&lt;iframe&gt;</code> 元素，其文档所指向的地址会返回一个 HTTP 1.1 的 <a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">trunked 编码</a> 文档。根据 trunked 编码文档的特性，服务器可以将整个文档分成多个部分发送给浏览器端。</p>
<p>通过这种方式，我们可以将 <code>&lt;iframe&gt;</code> 的文档看做是一个不断增加内容的文档，那么只需要在增量文档中生成 <code>&lt;script&gt;</code> 标签调用预定义的回调函数即可。</p>
<p>具体的实现为，首先定义一个生成永久帧的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foreverFrame</span> (<span class="params">url, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</div><div class="line">  <span class="keyword">var</span> randomName = <span class="string">'callback_'</span> + (<span class="built_in">Math</span>.random() + <span class="string">''</span>).substring(<span class="number">2</span>)</div><div class="line">  iframe.style.display = <span class="string">'none'</span></div><div class="line">  iframe.src = url + <span class="string">'?callback=parent.'</span> + randomName</div><div class="line">  <span class="built_in">window</span>[randomName] = callback</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用该函数后，生成的 <code>&lt;iframe&gt;</code> 所对应的文档的返回内容为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">parent.callback_1310442051852272(<span class="string">'hello world'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">parent.callback_1310442051852272(<span class="string">'hello mars'</span>);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 不断的增加中... --&gt;</span></div></pre></td></tr></table></figure>
<p>原理上，只要 <code>&lt;iframe&gt;</code> 元素对应的 trunked 编码的文档一直在输出内容，它就可以是被视作是”永久“的，且可以保证服务端持续地向浏览器输出内容。</p>
<p>但这里也有一个明显的弊端：在 IE 和 Firefox 下，采用这样的方案会让浏览器的进度条一直显示加载中，且 IE 的 tab 图标会不断的转动，表示正在进行加载。 Google 通过采用类型为 <code>htmlfile</code> 的 ActiveXObject 的技巧来解决了这个问题。<a href="https://infrequently.org/2006/02/what-else-is-burried-down-in-the-depths-of-googles-amazing-javascript/" target="_blank" rel="noopener">传送门</a></p>
<p>关于长轮询和 XHR 流的实现，这里不做赘述，有兴趣了解详情的可以阅读 <a href="http://imweb.io/topic/565abde9823633e31839fc0e" target="_blank" rel="noopener">Comet - 服务器推送解决方案</a></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除了以上几个例子，iFrame 还可以实现无刷新文件上传，浏览器多页面间的通信，或者是音乐播放器（同一浏览器多个tab共享一个播放器）等功能，具体可以看知乎上的 <a href="https://www.zhihu.com/question/20653055" target="_blank" rel="noopener">这个回答</a></p>
<h2 id="Viewport-的小麻烦"><a href="#Viewport-的小麻烦" class="headerlink" title="Viewport 的小麻烦"></a>Viewport 的小麻烦</h2><p>当页面被嵌入在 <code>&lt;iframe&gt;</code> 时，页面上的某些元素的定位规则会受到相应的影响。在解释具体的影响之前，首先我们要解释一下包含块（containing block）的概念。</p>
<h4 id="containing-block"><a href="#containing-block" class="headerlink" title="containing block"></a><code>containing block</code></h4><p>对于一个元素来说，它的大小和位置通常受这个元素的 <strong>包含块</strong> 所影响。比如说，如果该元素的 <code>width</code>, <code>height</code>, <code>padding</code>, <code>margin</code> 属性的值是百分比的话，那么在计算这些值的实际大小时，将使用包含块的内容区域的宽度或者宽度来作为计算参考；如果该元素是绝对定位的元素（即 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code>），则元素的偏移属性（<code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>）的值将相对于包含块进行计算，从而直接影响元素所处的位置。</p>
<p>浏览器通过元素的 <code>position</code> 属性值，有不同地指定元素的包含块的策略，具体可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block" target="_blank" rel="noopener">MDN 的文档</a></p>
<h4 id="lt-iframe-gt-gt-Viewport"><a href="#lt-iframe-gt-gt-Viewport" class="headerlink" title="&lt;iframe&gt; =&gt; Viewport"></a><code>&lt;iframe&gt;</code> =&gt; Viewport</h4><p>我们需要说明的是：<code>&lt;iframe&gt;</code> 元素事实上创建了一个新的 Viewport。根据 <a href="https://www.w3.org/TR/CSS21/visudet.html#containing-block-details" target="_blank" rel="noopener">CSS2.1 的规范</a>：</p>
<blockquote>
<p>The containing block in which the root element lives is a rectangle called the <strong>initial containing block</strong>. For continuous media, it has the dimensions of the viewport and is anchored at the canvas origin…</p>
</blockquote>
<p>从这段说明中我们可以得到两个结论：</p>
<ol>
<li>文档的根元素（<code>&lt;html&gt;</code>）就是该文档的初始化包含块（initial containing block）</li>
<li>同时这个元素关联一个 Viewport</li>
</ol>
<p>而 <a href="https://www.w3.org/TR/CSS21/visuren.html#viewport" target="_blank" rel="noopener">关于 Viewport 的规范</a> 则有：</p>
<blockquote>
<p>Useragents for continuous media generally offer users a <strong>viewport</strong> (a window or other viewing area on the screen) through which users consult a document. User agents may change the document’s layout when the viewport is resized (see the initial containing block)</p>
</blockquote>
<p>我们可以简单的将 Viewport 理解为用户查看文档的一个窗口。而对于 <code>&lt;iframe&gt;</code> 这样的嵌入文档，根据规范的说法，这事实上创建了一个新的 Viewport，且由于出现了一个新的文档对象，自然有其独立的初始化包含块（initial containing block）。</p>
<p>P.S：关于 Viewport 的详细介绍，可以查看学弟 @Mactavish 写的 <a href="https://macsalvation.net/2018/05/23/dive-into-viewport/" target="_blank" rel="noopener">这篇文章</a></p>
<p>有了这样的理论基础，我们来看看两个特殊的元素定位问题。</p>
<h4 id="position-fixed"><a href="#position-fixed" class="headerlink" title="position: fixed"></a><code>position: fixed</code></h4><p>相信很多写过自定义弹窗或者 Modal 组件的同学，都会使用 <code>position:fixed</code> 配合相应的偏移属性来实现相对于可视窗口的绝对居中效果。</p>
<p>但如果弹窗的元素是在一个 <code>&lt;iframe&gt;</code> 中，而该 <code>&lt;iframe&gt;</code> 元素又恰好只占用了父文档其中一部分的空间，那么实际上这个弹窗的居中效果是相对于 <code>&lt;iframe&gt;</code> 元素的，比如以下的这个例子，虽然黄色区块已经被设置成了 <code>position: fixed</code>，但显然其显示的位置不会在当前整个页面的正中央。</p>
<p></p><p data-height="320" data-theme-id="0" data-slug-hash="XBpqqv" data-default-tab="css,result" data-user="allenfantasy1018" data-embed-version="2" data-pen-title="XBpqqv" class="codepen">See the Pen <a href="https://codepen.io/allenfantasy1018/pen/XBpqqv/" target="_blank" rel="noopener">XBpqqv</a> by Zeqiu Wu (<a href="https://codepen.io/allenfantasy1018" target="_blank" rel="noopener">@allenfantasy1018</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>（当然，像上述例子的情况实际上是一个双重嵌套 iframe，读者可以打开 devtool 自己查看）</p>
<p>当然，这样的设定是浏览器有意为之的，所以如果确实有必要希望弹窗的位置在整个浏览器窗口的正中间，开发者需要使用 JS 的手段实现，具体做法可以参考 Andy Langton 的 <a href="https://andylangton.co.uk/blog/development/get-viewportwindow-size-width-and-height-javascript" target="_blank" rel="noopener">这篇博客</a></p>
<h4 id="Viewport-percentage-length"><a href="#Viewport-percentage-length" class="headerlink" title="Viewport-percentage length"></a>Viewport-percentage length</h4><p>顾名思义，<strong>Viewport-percentage length</strong> 指和当前 Viewport 相关的长度单位，如 <code>vw</code>, <code>vh</code>, <code>vmin</code>, <code>vmax</code>。根据 <a href="https://www.w3.org/TR/css-values/#viewport-relative-lengths" target="_blank" rel="noopener">CSS 规范</a> 的说法：</p>
<blockquote>
<p>The <em>viewport-percentage lengths</em> are relative to the size of the <strong>initial containing block</strong>. When the height or width of the initial containing block is changed, they are scaled accordingly.</p>
</blockquote>
<p>呵！原来 <code>vh</code> 和 <code>vw</code> 的计算参考系并不是当前浏览器的窗口大小，而是初始化包含块的高度和宽度，那么问题来了：由于 <code>&lt;iframe&gt;</code> 的独立文档会有单独的初始化包含块（就是其文档的 <code>&lt;html&gt;</code> 元素），也就是说：</p>
<p>在 <code>&lt;iframe&gt;</code> 文档中的元素，其 <code>vw</code> 和 <code>vh</code> 等长度单位的计算是相对于 <code>&lt;iframe&gt;</code> 元素的。<a href="https://stackoverflow.com/questions/34057239/css-vh-units-inside-an-iframe/44634369#44634369" target="_blank" rel="noopener">StackOverflow</a> 上也有人就这个问题做了详细的解答。</p>
<h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><p>嗯！这就是所有关于 <code>&lt;iframe&gt;</code> 要讨论的内容了，让我们来简单的回顾一下：</p>
<ul>
<li>一个 iFrame 对应一个独立的浏览上下文（Browsing Context）</li>
<li>iFrame 是出于嵌套第三方页面以丰富页面内容展示的需要而出现的，但围绕它可以实现许多特殊的功能</li>
<li>浏览器通过同源策略避免 iFrame 和主页面间的互相直接调用，但可以利用 <code>window.postMessage</code> 来让 iFrame 和主页面间进行通讯</li>
<li>可以通过 <code>X-Frame-Options</code> 控制页面被嵌套的策略</li>
<li>iFrame 页面元素的样式需要注意相对于 Viewport 的处理</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Browsing_context" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Glossary/Browsing_context</a></li>
<li><a href="https://html.spec.whatwg.org/multipage/browsers.html#windows" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/browsers.html#windows</a></li>
<li><a href="http://w3c.github.io/html/browsers.html#sec-browsing-contexts" target="_blank" rel="noopener">http://w3c.github.io/html/browsers.html#sec-browsing-contexts</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dn705664(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dn705664(v=vs.85).aspx</a></li>
<li><a href="http://netsekure.org/2015/12/06/chromium-internals-documents-windows-browsing-contexts/" target="_blank" rel="noopener">http://netsekure.org/2015/12/06/chromium-internals-documents-windows-browsing-contexts/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frameset" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frameset</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies</a></li>
<li><a href="https://en.wikipedia.org/wiki/HTML_element" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/HTML_element</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sandbox_(computer_security)</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security</a></li>
<li><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/WebSocket</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/HSTS" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Glossary/HSTS</a></li>
<li><a href="https://javascript.info/clickjacking" target="_blank" rel="noopener">https://javascript.info/clickjacking</a></li>
<li><a href="https://blog.mozilla.org/security/2013/12/12/on-the-x-frame-options-security-header/" target="_blank" rel="noopener">https://blog.mozilla.org/security/2013/12/12/on-the-x-frame-options-security-header/</a></li>
<li><a href="https://heycam.github.io/webidl/" target="_blank" rel="noopener">https://heycam.github.io/webidl/</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/web/wa-lo-comet/#N10101" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/wa-lo-comet/#N10101</a></li>
<li><a href="http://imweb.io/topic/565abde9823633e31839fc0e" target="_blank" rel="noopener">http://imweb.io/topic/565abde9823633e31839fc0e</a></li>
<li><a href="https://segmentfault.com/a/1190000014223524" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014223524</a></li>
<li><a href="http://www.fedlab.tech/archives/395.html" target="_blank" rel="noopener">http://www.fedlab.tech/archives/395.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Comet_(programming\)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comet_(programming)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本上稍有一定开发经历的 Web 开发者都多少会和 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 打过交道，但在最近连续接触了几个相关的需求之后，我却突然意识到，自己对 iFrame 并不是非常的了解，这就是本文的由来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="http://afantasy.ninja/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>CSSConf 笔记: Building Scalable Components</title>
    <link href="http://afantasy.ninja/2018/05/25/cssconf-note-scalable-comp/"/>
    <id>http://afantasy.ninja/2018/05/25/cssconf-note-scalable-comp/</id>
    <published>2018-05-24T16:00:00.000Z</published>
    <updated>2018-07-21T18:14:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>原分享地址： <a href="https://zellwk.github.io/scalable-components" target="_blank" rel="noopener">https://zellwk.github.io/scalable-components</a></p>
<p>Zell 用他的博客作为例子解释了如何去构建可伸缩的（Scalable）的组件：在不同尺寸的页面中，一个组件应该有不同的展现形式（大小，内容，内部位置关系等）。</p>
<p>Zell 提出了三个 Scaling 的概念：</p>
<ol>
<li>按比例的（Proportional Scaling）</li>
<li>响应式的（Responsive Scaling）</li>
<li>模块化的（Modular Scaling）</li>
</ol>
<h4 id="Proportional-Scaling"><a href="#Proportional-Scaling" class="headerlink" title="Proportional Scaling"></a>Proportional Scaling</h4><p>在按比例缩放中，组件应当根据以下两个对照值进行伸缩（scale）：</p>
<ul>
<li>font-size</li>
<li>viewport</li>
</ul>
<p>其中我们要使用 <em>相对(字体大小)单位</em>，比如：</p>
<ul>
<li><code>em</code> 相对当前对象内文本的字体大小</li>
<li><code>ch</code> 代表元素所用字体 font 中 “0” 这一字形的宽度（”0”, U+0030）<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/length" target="_blank" rel="noopener">MDN</a></li>
<li><code>%</code> 相对于父容器的 <em>同一属性</em> 的值的大小 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/percentage" target="_blank" rel="noopener">MDN</a></li>
</ul>
<p>在编写同一个组件的不同大小尺寸时，可以将组件公共的 CSS 组织在一起，达到类似 bootstrap 一类框架的风格。也可以利用 Sass @mixin 可以实现更简练的风格：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">mixin</span> button &#123;</div><div class="line">	<span class="attribute">display</span>: inline-block;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">0.5em</span> <span class="number">0.75em</span>;</div><div class="line">  <span class="comment">/* Other common properties */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-class">.button-large</span> &#123;</div><div class="line">  @<span class="keyword">include</span> button;</div><div class="line">  <span class="attribute">font-size</span>: <span class="number">2em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"button-large"</span>&gt;</span>A large button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure>
<p>另外一种控制相对大小的方法是使用相对于视口（viewport）比例的长度单位，如：</p>
<ul>
<li><code>vw</code></li>
<li><code>vh</code></li>
<li><code>vmin</code></li>
<li><code>vmax</code></li>
</ul>
<p>结合 <code>calc</code> 函数，我们可以 <a href="https://zellwk.github.io/scalable-components/demo/rt.html" target="_blank" rel="noopener">实现响应式变动文字大小</a></p>
<p>Mike Riethmuller 在 <a href="https://www.smashingmagazine.com/2016/05/fluid-typography/" target="_blank" rel="noopener">Responsive And Fluid Typography With vh and vw Units</a> 中详细地描述了更加具体的实践；有兴趣的同学可以看看这个 <a href="https://codepen.io/allenfantasy1018/pen/VxNJXw?editors=1100" target="_blank" rel="noopener">Demo</a> 和这个 <a href="https://www.sassmeister.com/gist/7f22e44ace49b5124eec" target="_blank" rel="noopener">Sass Snippet</a></p>
<h4 id="Modular-Scaling"><a href="#Modular-Scaling" class="headerlink" title="Modular Scaling"></a>Modular Scaling</h4><p><em>TODO</em></p>
<h4 id="Responsive-Scaling"><a href="#Responsive-Scaling" class="headerlink" title="Responsive Scaling"></a>Responsive Scaling</h4><p><em>TODO</em></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://stackoverflow.com/questions/29511983/is-the-default-font-size-of-every-browser-16px-why" target="_blank" rel="noopener">Is the default font-size of every browser 16px? Why?</a></li>
<li><a href="https://www.smashingmagazine.com/2014/07/breakpoints-and-the-future-websites/" target="_blank" rel="noopener">Breakpoints And The Future Of Websites</a></li>
<li><a href="https://codepen.io/MadeByMike/pen/VvwqvW" target="_blank" rel="noopener">https://codepen.io/MadeByMike/pen/VvwqvW</a></li>
<li><a href="http://alistapart.com/article/more-meaningful-typography" target="_blank" rel="noopener">http://alistapart.com/article/more-meaningful-typography</a></li>
<li><a href="http://type-scale.com/" target="_blank" rel="noopener">Type Scale</a></li>
<li><a href="http://www.modularscale.com/" target="_blank" rel="noopener">Modular Scale</a></li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>读完 <a href="https://www.smashingmagazine.com/2016/05/fluid-typography/#maintaining-vertical-rhythm" target="_blank" rel="noopener">https://www.smashingmagazine.com/2016/05/fluid-typography/#maintaining-vertical-rhythm</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原分享地址： &lt;a href=&quot;https://zellwk.github.io/scalable-components&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zellwk.github.io/scalable-components
    
    </summary>
    
    
      <category term="CSS" scheme="http://afantasy.ninja/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>谈谈 Observable（上）</title>
    <link href="http://afantasy.ninja/2018/05/13/lets-talk-observable-i/"/>
    <id>http://afantasy.ninja/2018/05/13/lets-talk-observable-i/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>因为工作中的某个 ng2 的项目中使用到了 Observable（具体地说，是 ng2 http 模块中的请求方法的返回结果正是 Observable），所以做一些简单的学习，在此记录。</p>
<p>由于篇幅太大，本篇先讲述 Observable 的基本概念，<del>（如果有时间的话）就继续写更复杂一些的内容</del></p>
<a id="more"></a>
<h3 id="什么是-Observable"><a href="#什么是-Observable" class="headerlink" title="什么是 Observable"></a>什么是 Observable</h3><h4 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h4><p>简单的说：</p>
<blockquote>
<p>Observable 是一个可被订阅的对象，该对象将随着时间推移发送有限或无限个值供其订阅者消费。</p>
</blockquote>
<p>在这个说法中 Observable 有两个特征：</p>
<ol>
<li>它是可被订阅的 (Pub/Sub)</li>
<li>它的值是一个有限/无限的队列</li>
</ol>
<p>以下将分别说明这两点。</p>
<h4 id="对比-EventEmitter"><a href="#对比-EventEmitter" class="headerlink" title="对比 EventEmitter"></a>对比 EventEmitter</h4><p>提到订阅，我们自然会想起经典的 Pub/Sub 模式（也有叫观察者模式），在 JS 中的实现就是 <code>EventEmitter</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in Node.js v9.x</span></div><div class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>)</div><div class="line"><span class="keyword">let</span> ev = <span class="keyword">new</span> EventEmitter()</div><div class="line">ev.on(<span class="string">'foo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`I got you, <span class="subst">$&#123;msg&#125;</span>!`</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">ev.on(<span class="string">'foo'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`I got you too, <span class="subst">$&#123;msg&#125;</span>!`</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 在后续代码的任何位置:</span></div><div class="line">ev.emit(<span class="string">'foo'</span>, <span class="string">'a monster'</span>)</div></pre></td></tr></table></figure>
<p>在上述的代码片段中，我们创建了一个 EventEmitter 对象，并向该对象注册了一个事件和对应的监听函数。在后续的程序代码中，我们可以在任何位置，让 EventEmitter 对象触发（<code>emit</code>）一个事件，从而唤醒该事件关联的监听函数（可以是多个）。浏览器中的 DOM 元素也实现了类似 EventEmitter 的特性。</p>
<p>和 EventEmitter 一样，Observable 可以实现基本的发布订阅：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Observable <span class="keyword">from</span> <span class="string">'rxjs'</span></div><div class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> Observable(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  observer.next(<span class="number">1</span>)</div><div class="line">  observer.next(<span class="number">2</span>)</div><div class="line">&#125;)</div><div class="line">source.subscribe(<span class="function"><span class="params">number</span> =&gt;</span> <span class="built_in">console</span>.log(number))</div></pre></td></tr></table></figure>
<p>而在实际的需求中，我们可能要处理一个 <strong>队列的事件触发</strong>，且队列可能不是有限的（如 IM 消息，弹幕，用户在页面上的操作），我们需要从代码组织层面上提供更加方便的处理方式，这就引出了 Observable。</p>
<p>比如我们用 Observable 处理 WebSocket 数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Observable <span class="keyword">from</span> <span class="string">'rxjs'</span></div><div class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://someurl'</span>)</div><div class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> Observable(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  socket.addEventListener(<span class="string">'message'</span>, e =&gt; &#123;</div><div class="line">    observer.next(e) </div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> socket.close()</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 打印 WebSocket 发送过来的数据</span></div><div class="line"><span class="comment">// 假设接收的数据都为数字, 对其中所有的偶数X输出 "this number is X"</span></div><div class="line"><span class="keyword">let</span> sub = source</div><div class="line">  .filter(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span>)</div><div class="line">  .map(<span class="function"><span class="params">number</span> =&gt;</span> <span class="string">`this number is <span class="subst">$&#123;number&#125;</span>`</span>).subscribe(<span class="function"><span class="params">message</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// 事实上可以对 message 做任何的处理</span></div><div class="line">    <span class="built_in">console</span>.log(message)</div><div class="line">  &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 在代码的任意位置</span></div><div class="line">sub.unsubscribe()</div></pre></td></tr></table></figure>
<p>在例子中我们新建并监听一个 WebSocket 连接，并将收到的信息进行处理。将监听逻辑封装成一个 Observable，让我们可以在后续使用 <code>.map()</code> 等操作符，来对收到的数据进行处理，并最后用 <code>subscribe()</code> 完成订阅。</p>
<h4 id="Stage-1-提案"><a href="#Stage-1-提案" class="headerlink" title="Stage-1 提案"></a>Stage-1 提案</h4><p>Observable 目前是 ECMAScript 的新提案 (<a href="https://github.com/tc39/proposal-observable" target="_blank" rel="noopener">Stage-1</a>)。在 ECMAScript 的提案中，Observable 的定义如下：</p>
<blockquote>
<p>The <strong>Observable</strong> type can be used to model push-based data sources such as DOM events, timer intervals, and sockets. In addition, observables are:</p>
<ul>
<li><em>Compositional</em>: Observables can be composed with higher-order combinators</li>
<li><em>Lazy</em>: Observables do not start emitting data until an <strong>observer</strong> has subscribed.</li>
</ul>
</blockquote>
<p>简单翻译如下：</p>
<blockquote>
<p><strong>Observable</strong> 类型可以用于表示基于推送的数据源模型，例如 DOM 事件，计时器，或者 socket。此外，Observable 还具有（以下特征）：</p>
<ul>
<li><em>可组合的</em>: Observable 可以使用高阶的连接符进行拼接组合</li>
<li><em>惰性</em>: Observable 仅当一个 <strong>observer</strong> 订阅时才会开始发送数据。</li>
</ul>
</blockquote>
<p>文章的后续会解释这两个属性，在这里读者可以先跳过概念部分，或者大概有个印象就可以了。</p>
<p>当前对 Observable 比较流行的实现有 <a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener">RxJS</a>, <a href="https://baconjs.github.io/" target="_blank" rel="noopener">Bacon.js</a>, <a href="https://github.com/zenparsing/zen-observable" target="_blank" rel="noopener">zen-observable</a> 等。接下来本文将基于 RxJS 中的实现来介绍 Observable 的基本概念。</p>
<h3 id="创建和订阅"><a href="#创建和订阅" class="headerlink" title="创建和订阅"></a>创建和订阅</h3><p>有别于固定长度的数组，Observable 的值是随时间发送的一连串的值，像水流一样，所以也有说法称 Observable 是一个流（Stream），为了更好的直观理解所谓的 “流”，首先我们来了解 Observable 的一种表示方法：<em>Marble Diagram</em>。</p>
<h4 id="Marble-Diagram"><a href="#Marble-Diagram" class="headerlink" title="Marble Diagram"></a>Marble Diagram</h4><p>Marble Diagram 由两个部分组成：<strong>timeline</strong> 和 <strong>item</strong>。timeline 表示时间轴，item 表示在时间轴上触发的元素（类型可以是任意的）。下图表示一个事件流先后触发（emit）了三个 item，最后成功结束，出现错误的符号为叉：</p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*brbCs4smjZfqitE0kHSHTQ.png" alt=""></p>
<p>我们也可以用类似 ASCII 的绘画方式来表达 Marble Diagram：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 用 - 表示一小段时间(可以理解为一个时间单位，如秒)，串起来表示一个时间轴，若某个时间中有发送值的话则用具体的值代替</span></div><div class="line">--<span class="number">-3</span>----<span class="number">-2</span>----<span class="number">-1</span>---<span class="number">-0</span>---</div><div class="line"></div><div class="line"><span class="comment">// 小括号代表着 Observable 是同步送值</span></div><div class="line">---(<span class="number">123</span>)----<span class="number">-2</span>----<span class="number">-1</span>---<span class="number">-0</span>---</div><div class="line">  </div><div class="line"><span class="comment">// X 表示有错误发生</span></div><div class="line">-----------------------X</div><div class="line"></div><div class="line"><span class="comment">// | 表示 Observable 结束</span></div><div class="line">-----------------------|</div></pre></td></tr></table></figure>
<p>接下来我们将了解 RxJS 中 Observable 相关的 API，其中将会用 Marble Diagram 的 ASCII 绘画来表示 Observable。如果有不太明白的地方，可以使用 <a href="https://rxviz.com/" target="_blank" rel="noopener">RxViz</a> 将代码实际运行一下，观察其 Marble Diagram 的具体形态。</p>
<h4 id="创建和订阅-1"><a href="#创建和订阅-1" class="headerlink" title="创建和订阅"></a>创建和订阅</h4><p>在上文中我们知道可以用 <code>Observable</code> 构造函数直接初始化一个 Observable 实例；RxJS 还提供了相同效果的静态方法 <code>Observable.create</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> observable = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  observer.next(<span class="string">'Jerry'</span>)</div><div class="line">  observer.next(<span class="string">'Anna'</span>)</div><div class="line">  observer.complete()</div><div class="line">  observer.next(<span class="string">'xxx'</span>) <span class="comment">// don't work</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在创建了 Observable 之后，可以通过 <code>subscribe</code> 方法订阅该 Observable：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(&#123;</div><div class="line">  next (value) &#123;</div><div class="line">    <span class="comment">// 处理 Observable 发出的值</span></div><div class="line">  &#125;,</div><div class="line">  error (err) &#123;</div><div class="line">    <span class="comment">// 当 Observable 出错时执行</span></div><div class="line">  &#125;,</div><div class="line">  complete () &#123;</div><div class="line">    <span class="comment">// 当 Observable 正常结束时执行（状态为 completed）</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 另一种语法:</span></div><div class="line">observable.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// next 方法</span></div><div class="line">&#125;, err =&gt; &#123;</div><div class="line">  <span class="comment">// err 方法</span></div><div class="line">&#125;, () =&gt; &#123;</div><div class="line">  <span class="comment">// complete 方法</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>如上述代码所示，调用 <code>subscribe</code> 方法时我们传入了一个对象，该对象我们可以称为 <strong>观察者（Observer）</strong>。</p>
<p>观察者具有三个方法，每当 Observable 发生事件时便会呼叫观察者相对应的方法：</p>
<ul>
<li><code>next</code>: 每当 Observable 发送新的值，触发该方法</li>
<li><code>complete</code>: 当 Observable 不再获得新的值时，complete 方法就会被触发，该方法被触发后，next 方法将不会再起作用。</li>
<li><code>error</code>: 每当 Observable 内发生错误时，error 方法被触发。</li>
</ul>
<p>可以查看另一个 <a href="https://gist.github.com/allenfantasy/340d1237180440a20551a532dd632ff6#file-basic-js-L10" target="_blank" rel="noopener">观察者的例子</a></p>
<p>和 EventEmitter 不同，Observable 在内部没有一个订阅者清单，订阅 Observable 的行为实际上是执行一个函数，这个函数接收一个 <strong>Observer 对象</strong> 并在函数体内触发 Observer 对象的方法（next, complete, error），也就是说，对于某个 Observable，其在构建时传入的回调函数，必须要在该 Observable 被订阅之后，才会调用执行。可以看一下这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ob = Rx.Observable.create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.warn(<span class="string">'now we start calling observer'</span>)</div><div class="line">  observer.next(<span class="number">1</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 必须要订阅之后才会执行</span></div><div class="line">ob.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.warn(<span class="string">'1st subscribe'</span>, value)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// another subscribe</span></div><div class="line">ob.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.warn(<span class="string">'2nd subscribe'</span>, value)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//=== output:</span></div><div class="line"><span class="comment">// now we start calling observer</span></div><div class="line"><span class="comment">// 1st subscribe 1</span></div><div class="line"><span class="comment">// now we start calling observer                                </span></div><div class="line"><span class="comment">// 2nd subscribe 1</span></div></pre></td></tr></table></figure>
<p>执行这段代码我们会发现，Observable 构造方法的回调函数实际上被调用了两次，这是因为这个 Observable 有两个订阅者，且回调函数是在 subscribe 时才被触发的。 如果我们将代码片段中 <code>subscribe</code> 的语句注释掉，执行时不会有任何输出。</p>
<p>在 RxJS 中，<code>subscribe</code> 方法会返回一个类型为 <code>Subscription</code> 的对象，可以用对象的 <code>unsubscribe</code> 方法可以停止对 observable 对象的监听（订阅）。</p>
<h3 id="Creation-Operator"><a href="#Creation-Operator" class="headerlink" title="Creation Operator"></a>Creation Operator</h3><p>除了用 <code>Observable.create</code> 方法之外，RxJS 还提供了很多便捷的创建 Observable 的 API，我们统称为 <em>creation operator</em>，其中包括：</p>
<ul>
<li><code>of</code>: <code>of(1,2,3,4)</code></li>
<li><code>from</code>: <code>from([1,2,3,4])</code></li>
<li><code>fromEvent</code></li>
<li><code>fromPromise</code></li>
<li><code>never</code>: 永远不会结束但什么都不做的</li>
<li><code>empty</code>: 空的且立刻结束的</li>
<li><code>throw</code>: 抛出错误</li>
<li><code>interval</code></li>
<li><code>timer</code></li>
</ul>
<p>利用这些 operator 我们可以快速实现一些常见的功能，如点击监听事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>)</div><div class="line"></div><div class="line">Rx.Observable.fromEvent(el, <span class="string">'click'</span>).subscribe(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">  <span class="comment">// handle click events...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>或者是数数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 每秒钟在控制台输出一个数字, 从0开始每次+1</span></div><div class="line">Rx.Observable.interval(<span class="number">1000</span>).subscribe(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(number)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 等1秒后送出0, 然后每隔5秒送出一个值(1,2,3,4..)</span></div><div class="line">Rx.Observable.timer(<span class="number">1000</span>, <span class="number">5000</span>).subscribe(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(number)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="Transform-Operator"><a href="#Transform-Operator" class="headerlink" title="Transform Operator"></a>Transform Operator</h3><p>前面提到，Observable 可以发送有限个或无限个值，我们可以将一定时间内 Observable 发出的值看做是一个数组，那么对这些值我们可以应用数组的所有方法如 <code>map()</code>, <code>filter()</code>, <code>pluck()</code> 等。事实上 Observable 确实提供了一系列的操作符（operator），允许我们链式调用。</p>
<p>Observable 本质上就是表示随时间发展而不断发送的一系列的值（流），我们可以像对待数组一样去对 Observable 进行操作，这样的操作方式，我们称为 Transform Operator。Transform Operator 可以分为几类（我的理解）：</p>
<ol>
<li>处理单个流的:<ul>
<li>简单的队列映射: <code>map</code>, <code>pluck</code>, <code>filter</code>, <code>scan</code>, <code>reduce</code>, <code>take</code>, <code>first</code>, <code>distinctUntilChanged</code> …</li>
<li>和时序有关的: <code>debounce</code>, <code>debounceTime</code>, <code>throttle</code>, <code>throttleTime</code></li>
</ul>
</li>
<li>处理多个流之间关系的: <code>merge</code>, <code>concat</code>, <code>combineLatest</code>, <code>zip</code>, <code>withLatestFrom</code></li>
<li>降维的(源 observable 所释放的每个值又是一个 observable): <code>concatAll</code>, <code>megeAll</code>, <code>combineAll</code>, <code>switch</code></li>
<li>映射+降维(源 observable 通过映射生成一个二维的 observable, 然后再降维): <code>concatMap</code>, <code>mergeMap</code>, <code>switchMap</code></li>
<li>其他: <code>catch</code>, <code>every</code>, <code>defaultEmpty</code>, <code>sequenceEqual</code>, <code>delay</code> 等</li>
</ol>
<p>分类方法还有一种是按照 <a href="http://rxmarbles.com/" target="_blank" rel="noopener">RxJS Marbles</a> 中的分类。有兴趣的读者也可以查看。</p>
<p>在介绍具体的 operator 之前，首先我们先看 operator 的运作方式。</p>
<h5 id="operators-运作方式"><a href="#operators-运作方式" class="headerlink" title="operators 运作方式"></a>operators 运作方式</h5><p>和数组的 operators 相比，Observable 的 operators 有两个特点：</p>
<ul>
<li>延迟运算：只有在 observable 被订阅时，operators 才开始对元素进行运算</li>
<li><p>渐进式取值：</p>
<blockquote>
<p>每次的运算是一个元素运算到底，而不是将全部元素运算完再返回</p>
</blockquote>
</li>
</ul>
<p>数组的取值方式：</p>
<p><img src="http://i.giphy.com/l0HlPZeB9OvFu7QwE.gif" alt=""></p>
<p>Observable 的取值方式：</p>
<p><img src="http://i.giphy.com/3o6ZtqrBfUyHvMDQ2c.gif" alt=""></p>
<p>为了理解方便，以下介绍 operator 时会使用 ASCII Marble Diagram。</p>
<h5 id="处理单个流"><a href="#处理单个流" class="headerlink" title="处理单个流"></a>处理单个流</h5><p><strong><code>map</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> source = Rx.Observable.interval(<span class="number">1000</span>)</div><div class="line"><span class="keyword">let</span> newest = source.map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</div><div class="line"></div><div class="line">source: ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---...</div><div class="line">         map(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">2</span>)</div><div class="line">newest: ---<span class="number">-2</span>---<span class="number">-3</span>---<span class="number">-4</span>---<span class="number">-5</span>---...</div></pre></td></tr></table></figure>
<p><strong><code>take</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> example = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>)</div><div class="line"><span class="comment">// TODO subscribe it ..</span></div><div class="line"></div><div class="line">source: ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>---<span class="number">-3</span>---...</div><div class="line">         take(<span class="number">3</span>)</div><div class="line">newest: ---<span class="number">-0</span>---<span class="number">-1</span>---<span class="number">-2</span>|</div></pre></td></tr></table></figure>
<p><strong><code>distinctUntilChanged</code></strong></p>
<p>如果要发送的元素和最后一次发送的元素相同，则过滤掉该元素</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> source = Rx.Observable.from([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>])</div><div class="line"><span class="keyword">let</span> example = source.distinctUntilChanged()</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value) &#125;,</div><div class="line">  <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span>, err) &#125;,</div><div class="line">  <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>) &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Result:</span></div><div class="line"><span class="comment">// a</span></div><div class="line"><span class="comment">// b</span></div><div class="line"><span class="comment">// c</span></div><div class="line"><span class="comment">// b</span></div><div class="line"><span class="comment">// complete</span></div></pre></td></tr></table></figure>
<h5 id="处理多个流之间的关系"><a href="#处理多个流之间的关系" class="headerlink" title="处理多个流之间的关系"></a>处理多个流之间的关系</h5><p><strong><code>merge</code></strong></p>
<p>合并 observable，在时序上两个 observable 同时执行，但当两个 observable 同时触发元素时，被 merge 的 observable 所触发的元素在后面。</p>
<p><code>merge</code> 的逻辑有点像 OR，就是当两个 observable 其中一个被触发时都可以被处理。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> source = Rx.Observable.interval(<span class="number">500</span>).take(<span class="number">3</span>)</div><div class="line"><span class="keyword">let</span> source2 = Rx.Observable.interval(<span class="number">300</span>).take(<span class="number">6</span>)</div><div class="line"><span class="keyword">let</span> example = source.merge(source2)</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</div><div class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</div><div class="line">    <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">/* Marble Diagram</span></div><div class="line">source : ----0----1----2|</div><div class="line">source2: --0-1---2--3--4--5|</div><div class="line">            merge()</div><div class="line">example: --0-(01)--21-3--(24)--5|</div><div class="line">*/</div></pre></td></tr></table></figure>
<p><strong><code>concat</code></strong></p>
<p><code>concat</code> 可以把多个 observable 合并成一个：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">3</span>);</div><div class="line"><span class="keyword">var</span> source2 = Rx.Observable.of(<span class="number">3</span>)</div><div class="line"><span class="keyword">var</span> source3 = Rx.Observable.of(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</div><div class="line"><span class="keyword">var</span> example = source.concat(source2, source3);</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</div><div class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</div><div class="line">    <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div><div class="line"><span class="comment">// 4</span></div><div class="line"><span class="comment">// 5</span></div><div class="line"><span class="comment">// 6</span></div><div class="line"><span class="comment">// complete</span></div><div class="line"></div><div class="line"><span class="comment">/* Marble Diagram</span></div><div class="line">source : ----0----1----2|</div><div class="line">source2: (3)|</div><div class="line">source3: (456)|</div><div class="line">            concat()</div><div class="line">example: ----0----1----2(3456)|</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="降维操作"><a href="#降维操作" class="headerlink" title="降维操作"></a>降维操作</h5><p>和数组类似，Observable 也可能出现类似二维数组这样的 “高维” 情况，即 Observable 中所发出的每项元素又是一个单独 Observable。RxJS 提供了一系列的 API 允许我们将其转换为普通的 “一维 Observable”。</p>
<p><strong><code>concatAll</code></strong></p>
<p>比如对应数组中 <code>concat</code> 操作，RxJS 也有 <code>concatAll</code> operator，会将所有的 Observable “拼接” 起来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obs1 = Rx.Observable.interval(<span class="number">1000</span>).take(<span class="number">5</span>) <span class="comment">// 0, 1, 2, 3, 4</span></div><div class="line"><span class="keyword">let</span> obs2 = Rx.Observable.interval(<span class="number">500</span>).take(<span class="number">2</span>)</div><div class="line"><span class="keyword">let</span> obs3 = Rx.Observable.interval(<span class="number">2000</span>).take(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">let</span> source = Rx.Observable.of(obs1, obs2, obs3)</div><div class="line"></div><div class="line"><span class="keyword">let</span> example = source.concatAll()</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">    next (value) =&gt; &#123; <span class="built_in">console</span>.log(value) &#125;,</div><div class="line">    error (err) =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err) &#125;,</div><div class="line">    complete () =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>) &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">/* Marble Diagram</span></div><div class="line"></div><div class="line">obs1  : ----0----1----2----3----4|</div><div class="line">obs2  : --0--1|</div><div class="line">obs3  : --------0| </div><div class="line">source: (o1,                           o2,        o3)</div><div class="line">          \                             \          \</div><div class="line">           ----0----1----2----3----4|    --0--1|    --------0|</div><div class="line">           </div><div class="line">                       concatAll()</div><div class="line">                       </div><div class="line">example: ----0----1----2----3----4--0--1--------0|</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">let</span> source = Rx.Observable.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).map(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">let</span> req = <span class="keyword">await</span> fetch(<span class="string">`/search?<span class="subst">$&#123;number&#125;</span>`</span>)</div><div class="line">  <span class="keyword">return</span> Rx.Observable.fromPromise(httpReq1)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>观察上面的 Marble Diagram，我们可以发现，<code>concatAll</code> 将 source 中的三个 Observable 按顺序拼接起来依次输出。</p>
<p><strong><code>switch</code></strong></p>
<p>swtich 总是会将返回的 Observable 的 “控制权” 交给原 Observable 中 <strong>最近返回</strong> 的一个 Observable。</p>
<p>尝试理解下这个例子：</p>
<iframe style="width:100%;height:400px;" src="https://stackblitz.com/edit/observable-switch?embed=1"></iframe>

<p>再看看这个例子对应的 <a href="https://rxviz.com/v/7Jag5mwo" target="_blank" rel="noopener">Marble Diagram</a>：</p>
<svg width="562" height="167" style="display: block; font-size: 14px; font-family: Arial, sans-serif; dominant-baseline: central; text-anchor: middle; cursor: default; user-select: none;"><line x1="21" y1="37" x2="21" y2="89" stroke="#767676" stroke-width="1" stroke-dasharray="3,3"/><line x1="153.8031" y1="37" x2="153.8031" y2="141" stroke="#767676" stroke-width="1" stroke-dasharray="3,3"/><g transform="translate(0, 11)"><!-- react-empty: 11 --><g transform="translate(21, 0)"><line x1="0" y1="26" x2="531" y2="26" stroke-width="2" stroke="#000000" style="shape-rendering: crispEdges;"/><path transform="translate(531, 21)" d="M0 0 L10 5 L0 10 z" fill="#000000" style="transition: fill 0.2s ease-in-out;"/><!-- react-empty: 16 --><g><g style="transform: translate(0px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="0" stroke="#000000" fill="#767676"/></g><g style="transform: translate(132.803px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="0" stroke="#000000" fill="#767676"/></g></g><!-- react-empty: 20 --></g></g><g transform="translate(0, 63)"><!-- react-empty: 22 --><g transform="translate(21, 0)"><line x1="0" y1="26" x2="531" y2="26" stroke-width="2" stroke="#767676" style="shape-rendering: crispEdges;"/><path transform="translate(531, 21)" d="M0 0 L10 5 L0 10 z" fill="#767676" style="transition: fill 0.2s ease-in-out;"/><!-- react-empty: 27 --><g><g style="transform: translate(53.2062px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">0</text></g><g style="transform: translate(106.625px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">1</text></g><g style="transform: translate(159.831px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">2</text></g><g style="transform: translate(213.25px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">3</text></g><g style="transform: translate(266.403px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">4</text></g><g style="transform: translate(319.821px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">5</text></g><g style="transform: translate(372.974px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">6</text></g><g style="transform: translate(426.287px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">7</text></g><g style="transform: translate(479.546px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">8</text></g></g><!-- react-empty: 29 --></g></g><g transform="translate(0, 115)"><!-- react-empty: 41 --><g transform="translate(21, 0)"><line x1="132.8031" y1="26" x2="531" y2="26" stroke-width="2" stroke="rgba(118, 118, 118, 0.2)" style="shape-rendering: crispEdges;"/><line x1="132.8031" y1="26" x2="319.662" y2="26" stroke-width="2" stroke="#767676" style="shape-rendering: crispEdges;"/><path transform="translate(531, 21)" d="M0 0 L10 5 L0 10 z" fill="rgba(118, 118, 118, 0.2)" style="transition: fill 0.2s ease-in-out;"/><line x1="319.662" y1="3.5" x2="319.662" y2="48.5" stroke-width="2" stroke="#767676" style="opacity: 1; transition: opacity 0.5s ease-in-out;"/><g><g style="transform: translate(170.132px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">0</text></g><g style="transform: translate(207.568px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">1</text></g><g style="transform: translate(244.844px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">2</text></g><g style="transform: translate(282.226px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">3</text></g><g style="transform: translate(319.45px, 26px) scale(1); transition: transform 0.5s ease-in-out;"><circle cx="0" cy="0" r="15" stroke-width="2" stroke="#767676" fill="#ffffff"/><text x="0" y="0" style="fill: rgb(118, 118, 118); dominant-baseline: central;">4</text></g></g><!-- react-empty: 48 --></g></g><g style="text-anchor: start; dominant-baseline: text-before-edge;"/></svg>

<h5 id="映射-降维"><a href="#映射-降维" class="headerlink" title="映射+降维"></a>映射+降维</h5><p>为了更加方便操作，RxJS 还提供了一些复合 operator，可以同时完成映射（成一个 Observable）和降维的操作。</p>
<p><strong><code>switchMap</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> source = Rx.Observable.fromEvent(<span class="built_in">document</span>.body, <span class="string">'click'</span>);</div><div class="line"></div><div class="line"><span class="comment">// map + switch</span></div><div class="line"><span class="keyword">var</span> example = source.switchMap(</div><div class="line">  <span class="function"><span class="params">e</span> =&gt;</span> Rx.Observable.interval(<span class="number">100</span>).take(<span class="number">3</span>)</div><div class="line">);</div><div class="line">                </div><div class="line">example.subscribe(&#123;</div><div class="line">  <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value); &#125;,</div><div class="line">  <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err); &#125;,</div><div class="line">  <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>); &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">/** Marble Diagram</span></div><div class="line">source : -----------c--c------------------...</div><div class="line">        concatMap(c =&gt; Rx.Observable.interval(100).take(3))</div><div class="line">example: -------------0-1-2-0-1-2---------...</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="其他-operator"><a href="#其他-operator" class="headerlink" title="其他 operator"></a>其他 operator</h5><p><strong><code>catch</code></strong></p>
<p><code>catch</code> 可以处理 observable 处理过程中出现的异常，可以通过返回一个新的 observable 来发送新的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> source = Rx.Observable.from([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="number">2</span>, <span class="string">'...'</span>])</div><div class="line">    .zip(Rx.Observable.interval(<span class="number">500</span>), (x, y) =&gt; x)</div><div class="line"></div><div class="line"><span class="keyword">let</span> example = source</div><div class="line">                .map(<span class="function"><span class="params">x</span> =&gt;</span> x.toUpperCase())</div><div class="line">                .catch(<span class="function"><span class="params">error</span> =&gt;</span> Rx.Observable.of(<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>))</div><div class="line"></div><div class="line">example.subscribe(&#123;</div><div class="line">    <span class="attr">next</span>: <span class="function">(<span class="params">value</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(value) &#125;,</div><div class="line">    <span class="attr">error</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'Error: '</span> + err) &#125;,</div><div class="line">    <span class="attr">complete</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">'complete'</span>) &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这段代码对应的 Marble Diagram 是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">source : ----a----b----c----d----2|</div><div class="line">        map(x =&gt; x.toUpperCase())</div><div class="line">         ----a----b----c----d----X|</div><div class="line">        catch(error =&gt; Rx.Observable.of(&apos;h&apos;))</div><div class="line">example: ----a----b----c----d----h----e----l----l---o|</div></pre></td></tr></table></figure>
<p>可以在 <code>catch</code> 的回调函数中，通过返回一个空的 observable（如：<code>Rx.Observable.empty()</code>）来让原有的 observable 结束。</p>
<h3 id="Practical-Example"><a href="#Practical-Example" class="headerlink" title="Practical Example"></a>Practical Example</h3><p>为了让读者更加直观理解 Observable 的具体使用，来几个例子：这里要鸣谢 “30天精通 RxJS” 教程的作者 @jerryhong，以下例子均出自他的教程。</p>
<ul>
<li><a href="https://jsfiddle.net/c5azpk87/" target="_blank" rel="noopener">拖拽方块</a></li>
<li><a href="https://jsfiddle.net/s6323859/ochbtpk5/3/" target="_blank" rel="noopener">类似 Youku 的滚动视频窗口+可拖拽效果</a></li>
<li><a href="https://jsfiddle.net/s6323859/yf02gt9j/1/" target="_blank" rel="noopener">简单加减</a></li>
<li><a href="https://jsbin.com/quvajux/1/edit?js,console,output" target="_blank" rel="noopener">AutoComplete</a>: 使用了 <code>debounceTime</code>, <code>switchMap</code>, <code>filter</code>, <code>map</code>, <code>fromEvent</code></li>
</ul>
<h3 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h3><p>在了解了 RxJS 和实践了几个例子之后，我们对 Observable 有一个基本的认识：</p>
<ul>
<li>从编程思想上来说，Observable 可以说是 <code>Reactive Programming</code> 和 <code>Functional Programming</code> 两种思想的结合，关于两种思想读者可以自行查阅。</li>
<li>从内容上看，Observable 实现了随时间变化的队列数据的发布订阅。</li>
<li>从使用场景上看，Observable 适合处理需要结合多个事件源（如：DOM事件）的复杂逻辑（应用适合的 operator），也适合处理弹幕，IM 聊天等无限数据流的需求。ng2 中大量的使用了 Observable 来管理其内部的 UI 状态。在下篇中我会提到这部分的内容 <del>（挖了个坑，逃</del></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://medium.com/@jshvarts/read-marble-diagrams-like-a-pro-3d72934d3ef5" target="_blank" rel="noopener">Understanding Marble Diagrams for Reactive Streams</a> 注: 文章中使用的还是 Rx 4.x 的语法</li>
<li><a href="http://rxmarbles.com/" target="_blank" rel="noopener">RxMarbles</a></li>
<li><a href="https://ithelp.ithome.com.tw/users/20103367/ironman/1199" target="_blank" rel="noopener">30天精通 RxJS</a></li>
<li><a href="http://reactivex.io/rxjs/" target="_blank" rel="noopener">rxjs document</a></li>
<li><a href="https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/switchmap.html" target="_blank" rel="noopener">https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/switchmap.html</a></li>
<li><a href="https://medium.com/@w.dave.w/becoming-more-reactive-with-rxjs-flatmap-and-switchmap-ccd3fb7b67fa" target="_blank" rel="noopener">Becoming more reactive with RxJS flatMap and switchMap</a></li>
<li><a href="https://angular.io/guide/observables" target="_blank" rel="noopener">https://angular.io/guide/observables</a></li>
<li><a href="https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3" target="_blank" rel="noopener">https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3</a></li>
<li><a href="https://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.html" target="_blank" rel="noopener">https://blog.thoughtram.io/angular/2016/01/06/taking-advantage-of-observables-in-angular2.html</a></li>
<li><a href="https://gist.github.com/btroncone/a6e4347326749f938510#projecting-data" target="_blank" rel="noopener">Comprehensive Introduction to @ngrx/store</a></li>
<li><a href="https://github.com/ngrx/store" target="_blank" rel="noopener">@ngrx/store</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为工作中的某个 ng2 的项目中使用到了 Observable（具体地说，是 ng2 http 模块中的请求方法的返回结果正是 Observable），所以做一些简单的学习，在此记录。&lt;/p&gt;
&lt;p&gt;由于篇幅太大，本篇先讲述 Observable 的基本概念，&lt;del&gt;（如果有时间的话）就继续写更复杂一些的内容&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>[译文] The TC39 Process</title>
    <link href="http://afantasy.ninja/2018/05/11/translation-the-tc39-process/"/>
    <id>http://afantasy.ninja/2018/05/11/translation-the-tc39-process/</id>
    <published>2018-05-10T16:00:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>提到 ECMAScript 规范制定的流程，目前网络上可以查到的中文资料，绝大多数是翻译于 Axel Rauschmayer 的 <a href="http://2ality.com/2015/11/tc39-process.html" target="_blank" rel="noopener">The TC39 process for ECMAScript features</a>。</p>
<a id="more"></a>
<ul>
<li><a href="https://www.jianshu.com/p/b0877d1fc2a4" target="_blank" rel="noopener">https://www.jianshu.com/p/b0877d1fc2a4</a></li>
<li><a href="https://www.zhihu.com/question/24715618/answer/115283215" target="_blank" rel="noopener">https://www.zhihu.com/question/24715618/answer/115283215</a></li>
</ul>
<p>文章中详细解释 TC39 Process 的一些细节（写于2015年），比较重要的一些点有：</p>
<ul>
<li>在 Draft 阶段，需要满足有两个对该规范的实验性实现，其中一个可以是类似 Babel 的转译器。</li>
<li>在 Candidate 阶段，需要有两个和规范兼容的实现。</li>
</ul>
<p>距离这篇文章成文时间已经过去了3年多，目前的流程规范已经有了新的变化。本文是对 <a href="https://tc39.github.io/process-document/" target="_blank" rel="noopener">The TC39 Process</a> 的全文翻译。以下为正文部分：</p>
<hr>
<p>ECMA TC39 委员会负责发展 ECMAScript 编程语言及编写语言规范。该委员会实行协商一致的原则，并在其觉得合适时酌情对规范进行修改。以下是对规范进行修改的通用流程：</p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><p>（TC39 委员会）通过一个流程来推动对语言的修改，该流程提供了如何（给规范）发展新增特性的指南：从一个点子到完整规范的，且同时具有可被接受的测试和多个具体实现的语言特性。（流程）有5个阶段：一个稻草人（strawman）阶段，和4个“成熟”阶段。TC39 委员会必须对（新特性的）每个阶段都通过验收。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>阶段</strong></th>
<th><strong>目的</strong></th>
<th><strong>准入标准</strong></th>
<th><strong>验收意义</strong></th>
<th><strong>规范的质量</strong></th>
<th><strong>验收后期望的修改</strong></th>
<th><strong>期望的实现方案*</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td> 0</td>
<td><div style="width:70px;">Strawman</div></td>
<td>允许进入规范</td>
<td>无</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
<td></td>
</tr>
<tr>
<td> 1</td>
<td>Proposal</td>
<td><ul style="width:120px"><li>提出这个新增特性的充分理由</li><li>描述解决方案的样子</li><li>确定潜在的挑战</li></ul></td>
<td><ul style="width:180px"><li>确认将会推动该新增特性的”主要负责人”人选（译注：可以理解为主要负责人）</li><li>简要概括问题或需求，以及一个大体上的解决方案形式</li><li>说明性的使用例子</li><li>高级 API</li><li>关于关键算法，抽象形式和语法的讨论</li><li>确认可能的 “cross-cutting” concerns[2] 和在实现中的挑战和复杂性</li></ul></td>
<td><div style="width:100px">委员会期望投入时间来检验问题空间，解决方案和 cross-cutting concerns</div></td>
<td><div style="width:80px;">无</div></td>
<td><div style="width:80px;">大幅度的修改</div></td>
<td><div style="width:105px;">Polyfill / demo</div></td>
</tr>
<tr>
<td>2</td>
<td>Draft</td>
<td>使用标准的规范语言精确表达（该特性）的语法和语义</td>
<td><ul><li>上述标准</li><li>初步的规范文本描述</li></ul></td>
<td>委员会期望该特性进一步发展且最终被标准所包含</td>
<td>草稿: 包含了所有主要语义、语法和 API，同时期望有 TODO、预留位置（placeholders）和编辑方面事务（editorial issues）</td>
<td>增量修改</td>
<td>实验性的方案（Experimental）</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Candidate</td>
<td>表示：进一步的完善需要具体实现方案（译者注：指实现了该特性的库）和用户的反馈</td>
<td><ul><li>上述标准</li><li>完整的规范文本描述</li><li>指定的审核人在当前的规范文本上签字通过</li><li>ECMAScript 编辑在当前规范文本上签字通过</li></ul></td>
<td>当前这个解决方案是完整的，在没有具体实践经验、大规模使用和外部反馈之前，不需要额外的工作。</td>
<td>完整的：所有的语义、语法和 API 都有完整的描述</td>
<td>有限的：仅限于那些基于实践经验，被视作是关键修改的内容</td>
<td>和规范相符合（的具体实现）</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>Finished</td>
<td>表示：该新增特性已经准备好，可以加入到正式的 ECMAScript 标准</td>
<td><ul><li>上述标准</li><li>（关于该特性的）主流使用场景的验收测试代码已经编码完成并合并到 <a href="https://github.com/tc39/test262" target="_blank" rel="noopener">Test262</a></li> 中<li>存在两个兼容规范，且通过验收测试的实现（库或工具）</li><li>显著有效地在实际开发中应用（关于该特性的）实现方案，比如应用两个不同VM（译者注：可能是浏览器和Node.js）提供的API</li><li>已向 <a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">tc39/ecma262</a> 提交了一个带有完整规范文本的 pull request</li><li>ECMAScript 编辑已经在 pull request 上签字通过</li></ul></td>
<td>该特性将在最新一次标准修改时被包含进去</td>
<td>最终版：已经集成了所有根据实践经验反馈的结果</td>
<td>无</td>
<td>正在发布</td>
</tr>
</tbody>
</table>
<p>* 该列并不是必需的，只单纯是一个大体上的期望。</p>
<h3 id="进入流程的输入"><a href="#进入流程的输入" class="headerlink" title="进入流程的输入"></a>进入流程的输入</h3><p>对 ECMAScript 编程语言的发展的意见以任何形式被接受。任何关于规范的修改或增补的讨论、意见提出或提案，在没有作为正式提案提交之前都被认为是 “strawman” (阶段0），不存在任何的验收要求。这样的（意见）提交必须要么来自 TC39 委员会成员提出，或者是来自 ECMA 国际注册的非委员会成员。</p>
<h3 id="规范修订和行程安排"><a href="#规范修订和行程安排" class="headerlink" title="规范修订和行程安排"></a>规范修订和行程安排</h3><p>TC39 将在每年7月向 ECMA General Assembly[1] 提交一份（ECMAScript 的）规范以争取通过。以下是制定一份新的规范修订方案的大约时间线：</p>
<ul>
<li>2月1日：完成 Candidate Draft</li>
<li>2月-3月：60 day royalty-free opt-out period.</li>
<li>3月份TC39会议：stage 4 的提案将被合并（到规范中），最终的语义将被通过，新的规范版本将会从 master 上切出一个分支。从这时候开始，只有校对文字的修改才会被接受。</li>
<li>4月-6月：ECMA CC 和 ECMA GA 复审阶段。</li>
<li>7月：ECMA General Assembly 将通过新的标准。</li>
</ul>
<h3 id="进行中的新增特性的状态"><a href="#进行中的新增特性的状态" class="headerlink" title="进行中的新增特性的状态"></a>进行中的新增特性的状态</h3><p>TC39 将在其 <a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">Github 上</a> 维护一个进行中的新增特性的列表，包括每项特性当前的成熟阶段。</p>
<h3 id="规范文书"><a href="#规范文书" class="headerlink" title="规范文书"></a>规范文书</h3><p>在 “draft” 阶段（第2阶段）及之后的阶段，新增特性的语义，API 和语法必须被描述成对最新发布的 ECMAScript 标准的编辑修改，使用同样的语言和约定。每个阶段中对规范文书质量的期望要求在前文中已有描述。<br>cribed above.</p>
<h3 id="审核者"><a href="#审核者" class="headerlink" title="审核者"></a>审核者</h3><p>任何人都可以是审核者并就一个进行中的新增特性提交反馈。委员会应当在 “draft” 阶段（第2阶段）就确定指定的审核者进行验收工作。这些审核者必须在提案进入 “candidate” 阶段（第3阶段）之前签字同意（该方案）。指定的审核者不可以是新增特性的规范文书的作者，但同时要具备对（该特性）涉及的内容相关的专业知识。指定的审核者必须是由委员会选出，不能由该提案的主要负责人选出。</p>
<p>当审核者被指定后，需要确定一个以第3阶段为目标的会议。在会议开始的两周前，审核者需要将初步意见反馈给提案的主要负责人，以保证可以在会议前有一个来回（的讨论）。如果还没有准备好的话，主要负责人可以将第3阶段目标会议延迟到稍后的一个时间。</p>
<h3 id="呼吁具体实现和反馈"><a href="#呼吁具体实现和反馈" class="headerlink" title="呼吁具体实现和反馈"></a>呼吁具体实现和反馈</h3><p>当一个新增特性被通过到 “candidate”（第3阶段）级别时，意味着委员会认为（对规范的）设计工作已经完成了，需要具体实现、大量的使用和外部反馈才能有进一步的完善。</p>
<h3 id="Test262-测试"><a href="#Test262-测试" class="headerlink" title="Test262 测试"></a>Test262 测试</h3><p>在第三阶段中，将编写 test262 测试并提交 pull request。一旦测试被恰当地审核过，就应该被合并（到主干代码中）以帮助实现规范的开发者在这一阶段提供反馈。（译者注：提供测试的好处时，实现规范的开发者，如Node或者浏览器的开发者可以利用测试来检查其实现是否遵循了提案中的规范细节）</p>
<h3 id="忽略过程"><a href="#忽略过程" class="headerlink" title="忽略过程"></a>忽略过程</h3><p>在合适情况下，委员会在经过考虑后，可能会基于变化的范畴，（在处理某个新特性提案时）忽略上述的流程。</p>
<h3 id="编辑的角色"><a href="#编辑的角色" class="headerlink" title="编辑的角色"></a>编辑的角色</h3><p>对于在进行中的新增特性，很可能有一些规范文本是由（新增特性的提案的）一个主要负责人或者是一个委员会成员编写的，而不是由编辑编写；尽管有时候编辑也可能是某个具体新增功能的主要负责人，需要为其负责。编辑需要负责 ECMAScript 规范的整体结构和连贯性。编辑同时也扮演（向规范作者）提供指导和反馈的角色，以保证一个新增特性的规范在逐渐发展成熟的过程中，其规范文书的质量和完整度也在提升。编辑还需要将通过的 “完成的”（第4阶段）的新增特性规范，整合到整个规范的新修订版本中。</p>
<p>(全文完)</p>
<hr>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><ul>
<li>[1] ECMA General Assembly：ECMA 里最权威的组织，相当于整个协会的控制核心。</li>
<li>[2] <a href="https://en.wikipedia.org/wiki/Cross-cutting_concern" target="_blank" rel="noopener">cross-cutting concern</a>： AOP 中的一个概念, 比较抽象. <a href="https://stackoverflow.com/questions/23700540/cross-cutting-concern-example?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="noopener">SO 上的这个解答</a> 比较生动一些。</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://tc39.github.io/process-document/" target="_blank" rel="noopener">The TC39 Process</a></li>
<li><a href="http://2ality.com/2015/11/tc39-process.html" target="_blank" rel="noopener">The TC39 process for ECMAScript features</a></li>
<li><a href="https://www.jianshu.com/p/b0877d1fc2a4" target="_blank" rel="noopener">[ECMAScript] TC39 process</a></li>
<li><a href="https://www.zhihu.com/question/24715618/answer/115283215" target="_blank" rel="noopener">ECMAScript 6 会重蹈 ECMAScript 4 的覆辙吗？</a></li>
</ul>
<h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>贺老的一个知乎 Live：<a href="https://www.zhihu.com/lives/883307634416054272" target="_blank" rel="noopener">如何学习和实践 ES201X?</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提到 ECMAScript 规范制定的流程，目前网络上可以查到的中文资料，绝大多数是翻译于 Axel Rauschmayer 的 &lt;a href=&quot;http://2ality.com/2015/11/tc39-process.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The TC39 process for ECMAScript features&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
      <category term="Translation" scheme="http://afantasy.ninja/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>co 源码分析</title>
    <link href="http://afantasy.ninja/2018/04/08/co-source-reading/"/>
    <id>http://afantasy.ninja/2018/04/08/co-source-reading/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>心血来潮看了下 co 的代码，两百来行并不算多，简单的做个分析。</p>
<a id="more"></a>
<h3 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h3><p>对于没时间看详解的同学，只需要知道这个事实：</p>
<blockquote>
<p>co 遍历执行一个 generator 函数，并返回了一个 Promise 对象，在 generator 函数执行结束后返回的 Promise 对象的状态将变成 <code>resolved</code>。</p>
</blockquote>
<p>以及：</p>
<blockquote>
<p>Promise 链中，当链中反复在 <code>.then()</code> 方法中返回新的 Promise 对象，且最外围的 Promise 的状态一直保持在 <code>pending</code> 时，会造成内存泄漏的问题。</p>
</blockquote>
<p>又及：</p>
<blockquote>
<p>没事不要乱看规范…真的够烧脑的…2333</p>
</blockquote>
<h3 id="brief"><a href="#brief" class="headerlink" title="brief"></a>brief</h3><p>实际上 co 的代码早已不是寥寥几行了（可能一开始是），但通篇下来其实也就是两百多行的代码，但功能上已经非常完备了。</p>
<p>co 具体做的事情：</p>
<ol>
<li>接受一个 generator 作为输入，输出一个 Promise 对象</li>
<li>遍历整个 generator（即不断的调用 next）<ul>
<li>在遍历结束时（即 next 返回的对象 <code>done: false</code>）进行 resolve，resolve 所持有的值是最后一个 next 输出的 <code>value</code></li>
<li>在遍历过程中出现错误则 reject</li>
</ul>
</li>
<li>仅支持 generator 函数中 yield 非空对象（不支持 primitive types 如 number, string 等），具体查看 co 文档中 <a href="https://github.com/tj/co#yieldables" target="_blank" rel="noopener">Yieldables</a> 部分</li>
</ol>
<p>来看看核心代码（省去了一些无关的注释，实际核心代码只有几十行）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="comment">// co.wrap 的实现（这个我们待会再说）</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  </div><div class="line">  <span class="comment">// 一开始就返回一个 Promise 对象</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="comment">// 如果输入是一个 GeneratorFunction，则先得到其执行后的 Generator 对象</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen.apply(ctx, args);</div><div class="line">    <span class="comment">// 如果 gen 不是一个 Generator，则 Promise 的状态变成 fulfilled，并将 gen 作为返回值</span></div><div class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span> resolve(gen);</div><div class="line"></div><div class="line">    <span class="comment">// 启动遍历 Generator 的过程</span></div><div class="line">    onFulfilled();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// 获取 Generator 中下一个值</span></div><div class="line">        ret = gen.next(res);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="comment">// 在执行过程中出现任何错误, 都直接让外围 Promise 的状态变成 rejected</span></div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 退出 Generator, 并让外围的 Promise 的状态变成 rejected</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ret;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        ret = gen.throw(err);</div><div class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">        <span class="keyword">return</span> reject(e);</div><div class="line">      &#125;</div><div class="line">      next(ret);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 这个是 co 中最关键的函数</span></div><div class="line">    <span class="comment">// 接收一个 Generator 遍历出来的值 &#123; value, done &#125;</span></div><div class="line">    <span class="comment">// 并将 value 作为下一个 .next() 方法的输入</span></div><div class="line">    <span class="comment">// 这里造成的效果是, yield 语句后面跟着的值(即 value)会成为上一个 yield 语句的返回值</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</div><div class="line">      <span class="comment">// 封装成 Promise</span></div><div class="line">      <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</div><div class="line">      <span class="comment">// 继续进行 Generator 的遍历</span></div><div class="line">      <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</div><div class="line">      </div><div class="line">      <span class="comment">// 如果 value 的值的类型不是 Function/Promise/Generator/GeneratorFunction/Array/Object 的话</span></div><div class="line">      <span class="comment">// 则中断整个 Generator 并让 Promise 状态为 rejected</span></div><div class="line">      <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'You may only yield a function, promise, generator, array, or object, '</span></div><div class="line">        + <span class="string">'but the following object was passed: "'</span> + <span class="built_in">String</span>(ret.value) + <span class="string">'"'</span>));</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将输入封装成 Promise</span></div><div class="line"><span class="comment">// 如果输入类型不符, 则返回原类型(返回值肯定不是一个 Promise)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (isPromise(obj)) <span class="keyword">return</span> obj;</div><div class="line">  <span class="keyword">if</span> (isGeneratorFunction(obj) || isGenerator(obj)) <span class="keyword">return</span> co.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> obj) <span class="keyword">return</span> thunkToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) <span class="keyword">return</span> arrayToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">if</span> (isObject(obj)) <span class="keyword">return</span> objectToPromise.call(<span class="keyword">this</span>, obj);</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//=== 以下省略 thunkToPromise, arrayToPromise, objectToPromise 的实现</span></div></pre></td></tr></table></figure>
<p>co 的实现的流程：</p>
<ol>
<li>整个函数返回一个 Promise 对象</li>
<li>将调用 <code>Generator.next</code> 的操作封装在一个函数 onFulfilled 中</li>
<li>将每次 <code>next</code> 返回的值封装成一个新的 Promise 对象，并在其状态变成 <code>fulfilled</code> 时调用 onFulfilled，让 Generator 函数继续执行</li>
<li>当本次 <code>next</code> 返回的 <code>done: true</code> 时，将要返回的 Promise 状态变为 <code>fulfilled</code>，将当前的 value 的值作为 Promise 所持有的值</li>
<li>在出现以下情况时，将要返回的 Promise 的状态变为 <code>rejected</code>：<ol>
<li>Generator 函数执行过程中抛出任何错误</li>
<li>某个 <code>yield</code> 语句中如果有 Promise 对象，而该 Promise 对象的状态为 <code>rejected</code></li>
<li>某个 <code>yield</code> 语句中的值的类型不是 Function/Promise/Generator/GeneratorFunction/Array/Object</li>
</ol>
</li>
</ol>
<p><strong>TODO</strong> 这里的 5.3 是一个令我很不解的地方，为什么要对 yield 关键字后面跟着的值的类型做要求呢？</p>
<p>然后我们再来看 <code>co.wrap</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Wrap the given generator `fn` into a</div><div class="line"> * function that returns a promise.</div><div class="line"> * This is a separate function so that</div><div class="line"> * every `co()` call doesn't create a new,</div><div class="line"> * unnecessary closure.</div><div class="line"> *</div><div class="line"> * @param &#123;GeneratorFunction&#125; fn</div><div class="line"> * @return &#123;Function&#125;</div><div class="line"> * @api public</div><div class="line"> */</div><div class="line">co.wrap = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</div><div class="line">  createPromise.__generatorFunction__ = fn;</div><div class="line">  <span class="keyword">return</span> createPromise;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> co.call(<span class="keyword">this</span>, fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>co.wrap</code> 做的事情是：接受一个 <code>[GeneratorFunction]</code> 函数对象，返回一个 “临时函数” —— 这个 “临时函数” 可以在任何时间被执行并返回一个 Promise：</p>
<blockquote>
<p>  Convert a generator into a regular function that returns a <code>Promise</code>.</p>
</blockquote>
<p>这看上去似乎有些令人摸不着头脑，但正是这个方法构成了 <code>koa</code> 1.x 中处理 middleware 的基础。有兴趣的同学可以看这里的代码：</p>
<ol>
<li><code>koa-compose</code> 中的 compose 方法: <a href="https://github.com/koajs/compose/blob/master/index.js" target="_blank" rel="noopener">https://github.com/koajs/compose/blob/master/index.js</a></li>
<li><code>co.wrap</code> in <code>app.callback</code> in <code>application.js</code> <a href="https://github.com/koajs/koa/blob/v1.x/lib/application.js#L127" target="_blank" rel="noopener">https://github.com/koajs/koa/blob/v1.x/lib/application.js#L127</a></li>
</ol>
<h3 id="Promise-memory-leak"><a href="#Promise-memory-leak" class="headerlink" title="Promise memory leak?"></a>Promise memory leak?</h3><p>在阅读源码过程中，我发现了一段很有趣的注释：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="comment">//...省略代码</span></div><div class="line">  </div><div class="line">  <span class="comment">// we wrap everything in a promise to avoid promise chaining,</span></div><div class="line">  <span class="comment">// which leads to memory leak errors.</span></div><div class="line">  <span class="comment">// see https://github.com/tj/co/issues/180</span></div><div class="line"></div><div class="line">  <span class="comment">//...省略代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是我查看了一下<a href="https://github.com/tj/co/issues/180" target="_blank" rel="noopener">这个 issue</a>，提出 issue 的人认为 co 在某些情况下可能会造成内存泄漏，而具体使用的情况与 Promise 有关。</p>
<p>这个 issue 已经<a href="https://github.com/tj/co/issues/180#issuecomment-68094905" target="_blank" rel="noopener">被修复</a>，具体做法是使用一个 Promise 实例，在所有需要变更状态的情况下都调用该实例所对应的 <code>resolve</code> 和 <code>reject</code> 方法。但我产生了一个新的疑问，就是为什么这样改就可以修复 co 的内存泄漏问题呢？于是我决定继续研究这个 issue。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span> (<span class="params">gen</span>) </span>&#123;</div><div class="line">  <span class="comment">// blah...</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">     <span class="comment">// 在后续的代码中直接调用 resolve 和 reject 方法</span></div><div class="line">     <span class="comment">// 不采用 Promise.resolve, Promise.reject</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个 issue 中，首先有人提出了一段测试代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        setTimeout(resolve, <span class="number">1</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; ++i) &#123;</div><div class="line">        <span class="keyword">yield</span> sleep();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> === <span class="number">0</span>) &#123;</div><div class="line">            global.gc();</div><div class="line">            <span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'finished'</span>)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'caught error: '</span>, err.stack);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>执行这段代码可以观察到明显的内存泄漏的情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123; rss: 17420288, heapTotal: 9620736, heapUsed: 3590768 &#125;</div><div class="line">&#123; rss: 44822528, heapTotal: 49288192, heapUsed: 12972200 &#125;</div><div class="line">&#123; rss: 70955008, heapTotal: 58575616, heapUsed: 21688912 &#125;</div><div class="line">&#123; rss: 80048128, heapTotal: 66831104, heapUsed: 30531560 &#125;</div><div class="line">&#123; rss: 89157632, heapTotal: 76118528, heapUsed: 39490184 &#125;</div><div class="line">&#123; rss: 98275328, heapTotal: 85405952, heapUsed: 48445040 &#125;</div><div class="line">&#123; rss: 107368448, heapTotal: 93661440, heapUsed: 57410024 &#125;</div><div class="line">&#123; rss: 116477952, heapTotal: 102948864, heapUsed: 66365712 &#125;</div><div class="line">&#123; rss: 125591552, heapTotal: 112236288, heapUsed: 75330040 &#125;</div><div class="line">&#123; rss: 134684672, heapTotal: 120491776, heapUsed: 84285144 &#125;</div><div class="line">&#123; rss: 143798272, heapTotal: 129779200, heapUsed: 93250072 &#125;</div><div class="line">&#123; rss: 152907776, heapTotal: 139066624, heapUsed: 102205152 &#125;</div><div class="line">&#123; rss: 162000896, heapTotal: 147322112, heapUsed: 111170352 &#125;</div><div class="line">&#123; rss: 171114496, heapTotal: 156609536, heapUsed: 120125032 &#125;</div></pre></td></tr></table></figure>
<p>而 @fengmk2 利用 <code>heapdump</code> 将内存泄漏的原因 <a href="https://github.com/tj/co/issues/180#issuecomment-68022246" target="_blank" rel="noopener">锁定在了 Promise 上</a>，项目维护者 @jonathanong 也提出了一个和 co 无关的<a href="https://github.com/tj/co/issues/180#issuecomment-68094905" target="_blank" rel="noopener">测试用例</a>来说明 Promise 的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">next()</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">    i++</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">100000</span> === <span class="number">0</span>) &#123;</div><div class="line">      global.gc();</div><div class="line">      <span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line">    &#125;</div><div class="line">    setImmediate(resolve)</div><div class="line">  &#125;).then(next)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123; rss: 142749696, heapTotal: 128759296, heapUsed: 93098624 &#125;</div><div class="line">&#123; rss: 234614784, heapTotal: 218537728, heapUsed: 182771736 &#125;</div><div class="line">&#123; rss: 325664768, heapTotal: 308316160, heapUsed: 272393200 &#125;</div><div class="line">&#123; rss: 416694272, heapTotal: 397062656, heapUsed: 361990640 &#125;</div><div class="line">&#123; rss: 507744256, heapTotal: 486841088, heapUsed: 451476544 &#125;</div><div class="line">&#123; rss: 598794240, heapTotal: 576619520, heapUsed: 541064768 &#125;</div><div class="line">&#123; rss: 688660480, heapTotal: 666397952, heapUsed: 630666888 &#125;</div><div class="line">&#123; rss: 779710464, heapTotal: 756176384, heapUsed: 720264424 &#125;</div><div class="line">&#123; rss: 870760448, heapTotal: 845954816, heapUsed: 809866824 &#125;</div><div class="line">&#123; rss: 961794048, heapTotal: 934701312, heapUsed: 899464696 &#125;</div><div class="line">&#123; rss: 1052844032, heapTotal: 1024479744, heapUsed: 989066688 &#125;</div><div class="line">&#123; rss: 1143898112, heapTotal: 1114258176, heapUsed: 1078667208 &#125;</div><div class="line">&#123; rss: 1234948096, heapTotal: 1204036608, heapUsed: 1168269624 &#125;</div><div class="line">&#123; rss: 1325998080, heapTotal: 1293815040, heapUsed: 1257867232 &#125;</div><div class="line">&#123; rss: 1417052160, heapTotal: 1383593472, heapUsed: 1347469472 &#125;</div></pre></td></tr></table></figure>
<p>在这个 issue 得到修复之后，后续的讨论集中到了 Promise 实现的问题上…</p>
<p>首先是 co 的维护者 @jonathanong 在 Promise A+ 规范上提了 issue: <a href="https://github.com/promises-aplus/promises-spec/issues/179" target="_blank" rel="noopener">chain of never resolved promises create memory leaks</a>，随后贺老 @hax 也提出了<a href="https://github.com/promises-aplus/promises-spec/issues/183" target="_blank" rel="noopener">对规范的疑问</a>，认为控制内存泄漏和控制 Promise 执行顺序之间是无法同时满足的。</p>
<p>在第一个 issue 中，bluebird 的作者 @petkaantonov <a href="https://github.com/promises-aplus/promises-spec/issues/179#issuecomment-68209678" target="_blank" rel="noopener">提到</a>:</p>
<blockquote>
<p>  Well the whole 2.3.2 needs to be redone.</p>
<p>  As far as I can tell we both fixed the memory leak in our implementation by turning <code>promise</code> into a proxy for <code>x</code>: any operation performed on <code>promise</code> will be redirected to <code>x</code>. Any operation already performed on <code>promise</code> are immediately redirected to <code>x</code> (which is possible because both must still be pending at this point).</p>
<p>  This is different from what the spec currently says, <code>promise</code> is now never pending, fulfilled or rejected, it doesn’t have its own state at all. If it had, that means <code>x</code> would need to inform <code>promise</code> when it changed state so that <code>promise</code> can change its state and that means <code>x</code> holding reference to <code>promise</code> which leads to the original leak.</p>
</blockquote>
<p>简单翻译一下：</p>
<blockquote>
<p>  （Promise A+ 规范中的）整个 2.3.2 都需要重新设计。</p>
<p>  据我所知我们（译者注：指的是 <code>then</code> 和 <code>bluebird</code> 的作者）都在我们各自的实现中将 <code>promise</code> 变成了 <code>x</code> 的一个 proxy: 任何对 <code>promise</code> 的操作都会重定向到 <code>x</code>。任何已经在 <code>promise</code> 上进行的操作（译者注：根据 Promise 的规范，<code>promise</code> 必须等待 <code>x</code> 的状态确定之后才知道自己的状态，所以对 <code>promise</code> 的操作如 <code>then</code> 等都必须要等待 <code>x</code> 的状态确定之后才可以调用，所以这里有一个 “延迟” 的情况）会立刻重定向到 <code>x</code> 上（这是可能的，因为在这时两个 promise 对象的状态都是 pending 的。</p>
<p>  这和当前规范中的说法不一致，<code>promise</code> 现在（的状态）永远不会是 pending, fulfilled 或者是 rejected，它根本就没有自己的状态。如果它有的话，那就意味着 <code>x</code> 必须在状态改变时通知 <code>promise</code> ，这样 <code>promise</code> 才可以修改它自身的状态，这就意味着 <code>x</code> 必须要保留对 <code>promise</code> 的引用，这样就导致了最初的（内存）泄漏。</p>
</blockquote>
<p>@petkaantonov 提出：<a href="https://github.com/then/promise/pull/67" target="_blank" rel="noopener">then</a> 和 <a href="https://github.com/petkaantonov/bluebird/commit/8c1edaf0a77a6d46a7527b2873e456d3ff62fab8" target="_blank" rel="noopener">bluebird</a> 的实现都规避了内存泄漏的问题，但实际的做法与 Promise A+ 规范有冲突。</p>
<p>为了彻底理解上述说法，我们需要研究一下 Promise A+ 规范。</p>
<p><strong>Promise A+ spec, 2.3.2:</strong></p>
<p><em><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+ 标准</a></em> 中对于 <code>then</code> 方法有以下规定：</p>
<blockquote>
<p>…<br>2.2.7 <code>then</code> must return a promise [3.3]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise2 = promise1.then(onFulfilled, onRejected);</div></pre></td></tr></table></figure></p>
<p>  2.2.7.1 If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code><br>  …<br>  …<br>  2.3 The Promise Resolution Procedure<br>  The <strong>promise resolution procedure</strong> is an abstract operation taking as input a promise and a value, which we donate as <code>[[Resolve]](promise, x)</code>. If <code>x</code> is a thenable, it attempts to make <code>promise</code> adopt the state of <code>x</code>, under the assumption that <code>x</code> behaves at least somewhat like a promise. Otherwise, it fulfills <code>promise</code> with the value <code>x</code>.<br>  …<br>  2.3.2 If <code>x</code> is a promise, adopt its state [3.4]:<br>  2.3.2.1 If <code>x</code> is pending, <code>promise</code> must remain pending until <code>x</code> is fulfilled or rejected.<br>  2.3.2.2 If/when <code>x</code> is fulfilled, fulfill <code>promise</code> with the same value.<br>  2.3.2.3 If/when <code>x</code> is rejected, reject <code>promise</code> with the same reason.<br>  …..</p>
</blockquote>
<p>这里我尝试翻译一下：</p>
<blockquote>
<p>  …</p>
<p>  2.2.7 <code>then</code> 必须返回一个 Promise 对象 [3.3]</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise2 = promise1.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<blockquote>
<p>  2.2.7.1 如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 返回一个值 x，则运行下面的 <strong>Promise 解析过程</strong>: <code>[[Resolve]](promise2, x)</code></p>
<p>  …</p>
<p>  …</p>
<p>  2.3 Promise 解析过程</p>
<p>  <strong>Promise 解析过程</strong> 是一个抽象的操作，其需输入一个 Promise 和一个值，我们表示为 <code>[[Resolve]](promise, x)</code>，如果 <code>x</code> 是一个 Thenable（注：持有 <code>then</code> 方法的对象），解析过程尝试去让 <code>promise</code> 接受 <code>x</code> 的状态，基于以下假设：<code>x</code> 的表现至少有某些部分像是一个 Promise；否则，解析过程将让 <code>promise</code> 的值变成 <code>fulfilled</code> 且采用 x 的值。</p>
<p>  …</p>
<p>  2.3.2 如果 <code>x</code> 是一个 Promise，则使 <code>promise</code> 接受 <code>x</code> 的状态 [3.4]</p>
<p>  2.3.2.1 如果 <code>x</code> 状态为 <code>pending</code>，则 <code>promise</code> 也将保持为 <code>pending</code> 直到 <code>x</code> 状态变成 <code>fulfilled</code> 或者是 <code>rejected</code></p>
<p>  2.3.2.2 如果/当 <code>x</code> 状态为 <code>fulfilled</code>，则 <code>promise</code> 状态也为 <code>fulfilled</code> 且持有的值与 <code>x</code> 相同</p>
<p>  2.3.2.3 如果/当 <code>x</code> 状态为 <code>rejected</code>，则 <code>promise</code> 状态也为 <code>rejected</code> 且理由(reason) 与 <code>x</code> 相同</p>
</blockquote>
<p>我们再来重新看 bluebird 作者的原话，就不难理解 Promise A+ 规范的问题是什么了：</p>
<blockquote>
<p>  这和当前规范中的说法不一致，<code>promise</code> 现在（的状态）永远不会是 pending, fulfilled 或者是 rejected，它根本就没有自己的状态。如果它有的话，那就意味着 <code>x</code> 必须在状态改变时通知 <code>promise</code> ，这样 <code>promise</code> 才可以修改它自身的状态，<strong>这就意味着 <code>x</code> 必须要保留对 <code>promise</code> 的引用，这样就导致了最初的（内存）泄漏。</strong></p>
</blockquote>
<h4 id="所以，co-是怎么修复内存泄露的？"><a href="#所以，co-是怎么修复内存泄露的？" class="headerlink" title="所以，co 是怎么修复内存泄露的？"></a>所以，co 是怎么修复内存泄露的？</h4><p>回到最初提出的关于 co 的问题，通过 <a href="https://github.com/tj/co/pull/182/files" target="_blank" rel="noopener">diff</a> 我们可以看到，修复的关键在于修改 <code>onFulfilled</code> 和 <code>onRejected</code> 两个方法，让它们不要返回一个新的 Promise，这样就不会触发 Promise 解析过程，也就规避掉了刚才提到的内存泄漏的问题。</p>
<h4 id="Promise-Order"><a href="#Promise-Order" class="headerlink" title="Promise Order ??"></a>Promise Order ??</h4><p>在 <a href="https://github.com/promises-aplus/promises-spec/issues/179#issuecomment-68213192" target="_blank" rel="noopener">promise A+ 规范的 issue</a> 中，@petkaantonov 提出了一个很有趣的例子，然而我没有看懂…我们来看这段代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> resolveA</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// resolveA = resolve</span></div><div class="line">  resolveA = <span class="built_in">arguments</span>[<span class="number">0</span>]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">a.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'first'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> resolveB</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// resolveB = resolve</span></div><div class="line">  resolveB = <span class="built_in">arguments</span>[<span class="number">0</span>]</div><div class="line">&#125;)</div><div class="line"></div><div class="line">b.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'second'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">resolveA(b)</div><div class="line"></div><div class="line">b.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'third'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">resolveB()</div></pre></td></tr></table></figure>
<p>这段代码的输出顺序应该是？</p>
<p>bluebird 作者 <code>@petanntonov</code> 的结论是:</p>
<blockquote>
<p>遵循规范实践的版本(before fix) 和 Q 的实践中, 以上代码的顺序是 second, third, first<br>而 bluebird 修复 memory leak 问题之后的执行顺序是 second, first, third</p>
</blockquote>
<p>然而我想了很久也不是特别明白这里的处理方式…</p>
<h4 id="原生-Promise-实现"><a href="#原生-Promise-实现" class="headerlink" title="原生 Promise 实现?"></a>原生 Promise 实现?</h4><p>我们现在知道，在 Node 及浏览器未能支持 Promise 规范的情况下，根据 Promise A+ 标准实现的第三方 Promise 库，可能会出现内存泄漏。使用 co 的 issue#180 中的<a href="https://github.com/tj/co/issues/180#issue-52777951" target="_blank" rel="noopener">测试代码</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sleep</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</div><div class="line">        setTimeout(resolve, <span class="number">1</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line">co(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; ++i) &#123;</div><div class="line">        <span class="keyword">yield</span> sleep();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (i % <span class="number">10000</span> === <span class="number">0</span>) &#123;</div><div class="line">            global.gc();</div><div class="line">            <span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'finished'</span>)</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'caught error: '</span>, err.stack);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在 Node v8.5.0 环境下测试（执行时需要启用 gc 的选项：<code>node —expose-gc test.js</code>）结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123; rss: 22249472, heapTotal: 10485760, heapUsed: 4095864, external: 13316 &#125;</div><div class="line">&#123; rss: 28135424, heapTotal: 11010048, heapUsed: 4547568, external: 8224 &#125;</div><div class="line">&#123; rss: 28520448, heapTotal: 11010048, heapUsed: 4573504, external: 8224 &#125;</div><div class="line">&#123; rss: 28835840, heapTotal: 11010048, heapUsed: 4540072, external: 8224 &#125;</div><div class="line">&#123; rss: 28966912, heapTotal: 11010048, heapUsed: 4547504, external: 8224 &#125;</div><div class="line">&#123; rss: 29106176, heapTotal: 11534336, heapUsed: 4543120, external: 8224 &#125;</div><div class="line">&#123; rss: 29138944, heapTotal: 11534336, heapUsed: 4550552, external: 8224 &#125;</div><div class="line">&#123; rss: 29282304, heapTotal: 11534336, heapUsed: 4545632, external: 8224 &#125;</div><div class="line">&#123; rss: 29351936, heapTotal: 11534336, heapUsed: 4553064, external: 8224 &#125;</div></pre></td></tr></table></figure>
<p>测试代码使用了 <code>process.memoryUsage()</code> 方法来获得当前 Node 环境下内存使用情况：</p>
<ul>
<li><code>heapTotal</code> 和 <code>heapUsed</code> 指的是 V8 的内存使用情况，其中 <code>heapUsed</code> 指程序执行过程中实际使用的内存</li>
<li><code>external</code> 指 V8 管理的 JS 对象所绑定的 C++ 对象所使用的内存大小</li>
<li><code>rss</code>（Resident Set Size，驻留集）指的是主内存设备（main memory device）所占用的内存空间，其中包括了堆，代码片段和栈调用。</li>
</ul>
<p>可以看到 <code>heapUsed</code> 并没有明显的增长（从第二行日志开始一直维持在 455w 左右波动，并没有明显的递增趋势），那是否意味着 Node 中 Promise 的实现没有问题呢？</p>
<p>由于代码中使用了 co，所以我们需要排除掉 co 的影响，于是使用第二个测试例子，这个例子没有用到 co，是一个纯 Promise 的测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line">next()</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">    i++</div><div class="line">    <span class="keyword">if</span> (i % <span class="number">100000</span> === <span class="number">0</span>) &#123;</div><div class="line">      global.gc();</div><div class="line">      <span class="built_in">console</span>.log(process.memoryUsage());</div><div class="line">    &#125;</div><div class="line">    setImmediate(resolve)</div><div class="line">  &#125;).then(next)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码的思路很清楚，就是通过递归的方式，实现一个 Promise 链：每一个新建的 Promise 对象的 <code>.then</code> 调用中，回调函数里总是会返回一个新的 Promise，这就重现了 Promise A+ 规范中 2.2.7 和 2.3.2 的情况：</p>
<blockquote>
<p>  2.2.7 <code>then</code> must return a Promise [3.3]</p>
<p>  2.2.7.1 If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code></p>
<p>  2.3.2 If <code>x</code> is a promise, adopt its state [3.4]:</p>
</blockquote>
<p>其运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123; rss: 94011392, heapTotal: 79167488, heapUsed: 44926712, external: 8224 &#125;</div><div class="line">&#123; rss: 132673536, heapTotal: 119013376, heapUsed: 86040960, external: 8224 &#125;</div><div class="line">&#123; rss: 181956608, heapTotal: 164102144, heapUsed: 126798032, external: 8224 &#125;</div><div class="line">&#123; rss: 220876800, heapTotal: 202899456, heapUsed: 167640600, external: 8224 &#125;</div><div class="line">&#123; rss: 257863680, heapTotal: 243793920, heapUsed: 208447880, external: 8224 &#125;</div><div class="line">&#123; rss: 303140864, heapTotal: 285212672, heapUsed: 249248816, external: 8224 &#125;</div><div class="line">&#123; rss: 344813568, heapTotal: 326631424, heapUsed: 290051784, external: 8224 &#125;</div><div class="line">&#123; rss: 386400256, heapTotal: 368050176, heapUsed: 330850536, external: 8224 &#125;</div><div class="line">&#123; rss: 432185344, heapTotal: 413663232, heapUsed: 371600120, external: 8224 &#125;</div><div class="line">&#123; rss: 470716416, heapTotal: 451936256, heapUsed: 412433776, external: 8224 &#125;</div><div class="line">&#123; rss: 511557632, heapTotal: 492830720, heapUsed: 453250368, external: 8224 &#125;</div></pre></td></tr></table></figure>
<p>看来，似乎目前 Node v8.5.0 版本内对 Promise 的实现仍然会存在这个问题。嗯，看来编码中要注意了……</p>
<h3 id="更多研究"><a href="#更多研究" class="headerlink" title="更多研究"></a>更多研究</h3><p>哼哧哼哧写完之后才发现，早有人很详细的研究了这个问题，惭愧哪……</p>
<ul>
<li>Maya 大神写的关于 Promise 链的详细研究（太长了，暂时看不动）：<a href="https://github.com/xieranmaya/blog/issues/5" target="_blank" rel="noopener">https://github.com/xieranmaya/blog/issues/5</a></li>
<li>关于 Promise 内存泄漏的问题 by 腾讯 AlloyTeam <a href="http://www.alloyteam.com/2015/05/memory-leak-caused-by-promise/" target="_blank" rel="noopener">http://www.alloyteam.com/2015/05/memory-leak-caused-by-promise/</a></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://github.com/tj/co" target="_blank" rel="noopener">tj/co, The ultimate generator based flow-control goodness for node.js</a></li>
<li><a href="https://github.com/tj/co/issues/180#issuecomment-68094905" target="_blank" rel="noopener">Aggressive Memory Leak, tj/co</a></li>
<li><a href="https://github.com/promises-aplus/promises-spec/issues/179" target="_blank" rel="noopener">chain of never resolved promises create memory leaks, promises-aplus/promises-spec</a></li>
<li><a href="https://github.com/promises-aplus/promises-spec/issues/183" target="_blank" rel="noopener">Which behavior is correct? </a></li>
<li><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise A+</a></li>
<li><a href="https://segmentfault.com/a/1190000002452115" target="_blank" rel="noopener">Promise A+ 规范中文翻译</a></li>
<li><a href="http://www.ituring.com.cn/article/66566" target="_blank" rel="noopener">「翻译」Promises/A+ 规范</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">Generator 函数的语法, ECMAScript6 入门 by 阮一峰</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;心血来潮看了下 co 的代码，两百来行并不算多，简单的做个分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTML - 预解析, async/defer 和 preload</title>
    <link href="http://afantasy.ninja/2018/01/13/speculative-parsing-async-defer-perload/"/>
    <id>http://afantasy.ninja/2018/01/13/speculative-parsing-async-defer-perload/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是关于 @mactavish 学弟在众成翻译上翻译的文章 <a href="http://www.zcfy.cc/article/building-the-dom-faster-speculative-parsing-async-defer-and-preload-x2605-mozilla-hacks-8211-the-web-developer-blog-4224.html" target="_blank" rel="noopener">更快地构建 DOM: 使用预解析, async, defer 以及 preload ★ Mozilla Hacks – the Web developer blog</a> 的阅读笔记。特此感谢。<br><a id="more"></a></p>
<h3 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h3><p>首先我们需要了解浏览器正常的文档解析流程（Parsing）：</p>
<ul>
<li>浏览器引擎的解析器会将 HTML 转换成 DOM（解析，DOM 的构建）</li>
<li>在解析 HTML 字符串的过程中，DOM 节点逐个被添加到树中</li>
<li>在 DOM 中，对象被关联在树中用户捕获标签之间的父子关系</li>
<li>CSS 样式被映射到 <a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model" target="_blank" rel="noopener">CSSOM</a> 上<ul>
<li>CSS 规则会互相覆盖，所以浏览器引擎需要进行复杂计算，以确定 CSS 代码如何应用到 DOM</li>
<li>CSS 可能会阻塞解析：<ul>
<li>当解析器获取一个 <code>&lt;script&gt;</code> 标签时，DOM 将等待 JavaScript 执行完毕后继续构建；</li>
<li>若有 CSS 样式表先于该标签，则该标签的 JavaScript 代码将等待 CSS 下载，解析，且 CSSOM 可以使用时，才会执行</li>
</ul>
</li>
<li>CSS 会阻塞 DOM 的渲染：直到 DOM 和 CSSOM 准备好之前，浏览器什么都不会显示。 <ul>
<li>FOUC - Flash of Unstyled Content: 没有任何样式的页面突然变换成了有样式的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://p0.qhimg.com/t01e10b4f03dd61fc92.png" alt=""></p>
<h5 id="CSSOM"><a href="#CSSOM" class="headerlink" title="CSSOM"></a><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model" target="_blank" rel="noopener">CSSOM</a></h5><blockquote>
<p>CSS Object Model is a set of APIs allowing to manipulate CSS from JavaScript…It allows to read and modify CSS style dynamically.</p>
</blockquote>
<p>一系列的可以操作 CSS 样式的 JS 方法。</p>
<p><code>CSS.supports</code></p>
<p><code>@supports</code> CSS at-rule</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">supports</span> (display: flex) &#123;</div><div class="line">  <span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">supports</span> not (display: flex) &#123;</div><div class="line">  <span class="selector-tag">div</span> &#123;</div><div class="line">    <span class="attribute">float</span>: right;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="keyword">supports</span> (display: flexbox) and (not (display: inline-grid)) &#123;</div><div class="line">  <span class="comment">/* blah ... */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="预解析-Speculative-Parsing"><a href="#预解析-Speculative-Parsing" class="headerlink" title="预解析 Speculative Parsing"></a>预解析 Speculative Parsing</h3><blockquote>
<p>它的概念是：虽然在执行脚本时构建 DOM 是不安全的，但是你仍然可以解析 HTML 来查看其它需要检索的资源。找到的文件会被添加到一个列表里并开始 <strong>在后台并行地下载</strong> 。当脚本执行完毕之后，这些文件很可能已经下载完成了。</p>
</blockquote>
<p><del>说人话：就是会提前的下载 HTML 页面上声明了的脚本…</del></p>
<p><em>下载是并行的，执行是先后的</em>，以这种方式触发的下载请求称为”预测“，因为很有可能脚本还是会改变 HTML 结构，导致预测的浪费（即下载的脚本是无效的，并不会被执行），但这并不常见，所以预解析仍然可以带来很大的性能提升。</p>
<p><img src="https://hacks.mozilla.org/files/2017/09/waterfall-2-bold@2x.png" alt=""></p>
<ul>
<li>预加载的内容：<ul>
<li>脚本</li>
<li>外部 CSS</li>
<li>来自 <code>&lt;img&gt;</code> 标签的图片</li>
<li>Firefox 预加载 video 元素 <code>poster</code> 属性</li>
<li>Chrome/Safari 预加载 <code>@import</code> 内联样式</li>
</ul>
</li>
<li>预加载会受到浏览器并行下载文件的数量限制（HTTP 1.x），如 Chrome 浏览器最多只能并行下载6个文件。</li>
<li>预解析时，浏览器不会执行内联的 JS 代码块。</li>
<li>用 JS 加载不那么重要的内容来避免预解析，这里的意思是说，页面上某些不重要的脚本，相比于其他必需脚本来说，是应该 <strong>迟下载，迟执行</strong> 的，通过用 JS 动态加载它们，它们就不会一开始出现在 HTML 文档的 <code>&lt;script&gt;</code> 标签中，则浏览器的预解析不会处理它们（相对的就会更优先的解析必需脚本）</li>
</ul>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Optimizing_your_pages_for_speculative_parsing" target="_blank" rel="noopener">MDN 的文档</a> 中提到：</p>
<ul>
<li>Firefox 4 及之后的版本的 HTML 解析器支持在预解析时不使用浏览器的主线程，从而可以达到不阻塞正常 DOM 构建和渲染的效果。</li>
<li>尽量确保预加载成功：如果使用了 <code>&lt;base&gt;</code> 元素指定页面加载资源的根地址（base URI），则确保不要用 JS 去加载该元素（注：放到 <code>&lt;head&gt;</code> 标签里就可以了）</li>
<li>避免预解析构建的 DOM 树失效，这里需要避免一些对 <code>document.write</code> 方法的滥用，具体可以看 MDN 文档中 “Avoid losing tree builder output” 一节中列出的几个点</li>
</ul>
<h3 id="defer-和-async"><a href="#defer-和-async" class="headerlink" title="defer 和 async"></a>defer 和 async</h3><ul>
<li><code>defer</code> 和 <code>async</code> 在下载时都不会阻塞 HTML 解析器的执行（解析 DOM）</li>
<li><code>defer</code> 和 <code>async</code> 之间的不同是他们开始执行脚本的时机的不同</li>
<li><p><code>defer</code> 脚本在 HTML 文档解析完全完成之后才开始执行，处在 <code>DOMContentLoaded</code> 事件之前。保证脚本会按照它在 HTML 中出现的顺序执行，且不会阻塞解析</p>
<ul>
<li><p>但根据红宝书的说法，在一个页面中最好只有一个带 <code>defer</code> 的脚本；保险起见，在 <code>DOMContentLoaded</code> 的事件回调中执行实际的业务代码：</p>
<blockquote>
<p>HTML5规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于DOMContentLoaded事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。</p>
</blockquote>
</li>
<li><p>红宝书的说法是有实锤的，在 <a href="https://github.com/h5bp/lazyweb-requests/issues/42#issuecomment-1776866" target="_blank" rel="noopener">这个issue中</a> 有人做了实验确认了 Firefox 在处理 <code>defer</code> 属性脚本时，脚本的代码是在 <code>DOMContentLoaded</code> 事件后才执行的；同时，在 IE&lt;=9 时，<code>defer</code> 脚本的顺序执行也不能保证。</p>
</li>
</ul>
</li>
<li><p><code>async</code> 脚本在它们完成下载后的第一时间执行，它处在 window 的 <code>load</code> 事件之前，有可能（并且很有可能）设置了 async 的脚本不会按照它们在 HTML 中出现的顺序执行，它们可能会中断 DOM 的构建。</p>
<ul>
<li>多个 <code>async</code> 脚本之前的执行顺序不总是它们的出现顺序，而取决于 <strong>哪个文件先完成下载</strong></li>
<li>经典使用场景：不依赖于 DOM 的第三方脚本，例如 Google Analytics</li>
<li><p>引用 <a href="https://css-tricks.com/async-attribute-scripts-bottom/" target="_blank" rel="noopener">CSS Tricks</a> 中的描述：</p>
<blockquote>
<p>If you use the async attribute, you are saying: I don’t want the browser to stop what it’s doing while it’s downloading this script.</p>
</blockquote>
</li>
<li><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#Attributes" target="_blank" rel="noopener">MDN 文档</a> 的说法是：</p>
<blockquote>
<p>Dynamically inserted scripts execute asynchronously by default, so to turn on synchronous execution (i.e. scripts execute in the order they were inserted) set async=false</p>
</blockquote>
</li>
</ul>
</li>
<li>没有 <code>defer</code> 或者 <code>async</code> 属性的脚本，包括行内脚本（inline scripts）会（在 HTML 解析到时）立刻下载并执行，之后浏览器继续解析页面（文档）「注：即阻塞解析」</li>
<li>若同时使用 <code>defer</code> 和 <code>async</code>，则以 <code>async</code> 为准，当浏览器不支持 <code>async</code> 时，回退到 <code>defer</code></li>
<li>兼容性：<ul>
<li><code>defer</code> 在 IE6-9 中的实现有问题（并不按规范实现），<a href="https://caniuse.com/#search=defer" target="_blank" rel="noopener">IE10+ 完整支持</a></li>
<li><code>async</code> <a href="https://caniuse.com/#search=async" target="_blank" rel="noopener">IE10+</a></li>
</ul>
</li>
<li>一张图直观的表达：</li>
</ul>
<p><img src="https://sfault-image.b0.upaiyun.com/28/4a/284aec5bb7f16b3ef4e7482110c5ddbb_articlex" alt=""></p>
<h3 id="preload"><a href="#preload" class="headerlink" title="preload"></a><code>preload</code></h3><p>使用 <code>&lt;link rel=&quot;preload&quot;&gt;</code> 告知浏览器对资源进行预先的加载：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"very_important.js"</span> <span class="attr">as</span>=<span class="string">"script"</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>as</code> 属性的可能的值有：</p>
<ul>
<li>script</li>
<li>style</li>
<li>image</li>
<li>font</li>
<li>audio</li>
<li>video</li>
</ul>
<p>预加载字体需要设置 <code>crossorigin</code> 属性，即使字体在同一个域名下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"font.woff"</span> <span class="attr">as</span>=<span class="string">"font"</span> <span class="attr">crossorigin</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>preload</code> 目前<a href="https://caniuse.com/#search=preload" target="_blank" rel="noopener">仅在部分新版本的 Chrome 和 Firefox 上得到支持。</a></p>
<h3 id="More"><a href="#More" class="headerlink" title="More?"></a>More?</h3><p>其实还有一个问题：如果有一部分 CSS 是在页面所有的 HTML 加载结束之后再被动态插入，此时的 CSSOM 是否会被重新构建？如果同时又有 JS 脚本需要执行，其先后顺序如何？</p>
<p>所以有空的话，顺便也了解下浏览器运作机制呗：</p>
<ul>
<li><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">How Browsers Work: Behind the scenes of modern web browsers</a> (<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">中文版</a>)</li>
<li><a href="https://hacks.mozilla.org/2017/05/quantum-up-close-what-is-a-browser-engine/" target="_blank" rel="noopener">Quantum Up Close: What is a browser engine?</a></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="http://www.zcfy.cc/article/building-the-dom-faster-speculative-parsing-async-defer-and-preload-x2605-mozilla-hacks-8211-the-web-developer-blog-4224.html" target="_blank" rel="noopener">更快地构建 DOM: 使用预解析, async, defer 以及 preload ★ Mozilla Hacks – the Web developer blog</a></li>
<li><a href="https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/" target="_blank" rel="noopener">Building the DOM faster: speculative parsing, async, defer and preload</a></li>
<li><a href="https://github.com/h5bp/lazyweb-requests/issues/42" target="_blank" rel="noopener">script[defer] doesn’t work in IE&lt;=9</a></li>
<li><a href="https://segmentfault.com/a/1190000006778717" target="_blank" rel="noopener">浅谈script标签的defer和async</a></li>
<li><a href="http://levy.work/2017-01-25-script-defer-and-async/" target="_blank" rel="noopener">使用defer或async加载脚本</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Optimizing_your_pages_for_speculative_parsing" target="_blank" rel="noopener">Optimizing your pages for speculative parsing, MDN</a></li>
<li><a href="https://css-tricks.com/thinking-async/" target="_blank" rel="noopener">Thinking Async, CSS Tricks</a></li>
<li><a href="https://css-tricks.com/async-attribute-scripts-bottom/" target="_blank" rel="noopener">Async Attribute and Scripts At The Bottom, CSS Tricks</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model" target="_blank" rel="noopener">CSSOM, MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script" target="_blank" rel="noopener"><code>&lt;script&gt;</code> element, MDN</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是关于 @mactavish 学弟在众成翻译上翻译的文章 &lt;a href=&quot;http://www.zcfy.cc/article/building-the-dom-faster-speculative-parsing-async-defer-and-preload-x2605-mozilla-hacks-8211-the-web-developer-blog-4224.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;更快地构建 DOM: 使用预解析, async, defer 以及 preload ★ Mozilla Hacks – the Web developer blog&lt;/a&gt; 的阅读笔记。特此感谢。&lt;br&gt;
    
    </summary>
    
    
      <category term="Browser" scheme="http://afantasy.ninja/tags/Browser/"/>
    
  </entry>
  
  <entry>
    <title>浅谈时间管理（Time Management）</title>
    <link href="http://afantasy.ninja/2018/01/05/time-management-brief-intro/"/>
    <id>http://afantasy.ninja/2018/01/05/time-management-brief-intro/</id>
    <published>2018-01-05T10:23:00.000Z</published>
    <updated>2018-01-07T08:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这个信息爆炸的时代，作为个人而言，所接触到的信息是前所未有的多；而从学校到职场，随着扮演的角色的变化，每个人工作生活中所要做的事情，只会越来越多；如何去合理地，高效地利用自己的时间，既能很好的完成日常需要做的事情，同时可以兼顾自己的兴趣，个人觉得是一个长期的问题。以下就是我在分答上学习 “时间管理” 课程的简单总结。希望能够通过这些方法论，尝试去提高自己对时间的利用程度；如果可以帮到读者，那就更加好了。<br><a id="more"></a></p>
<p>需要申明的是，以下内容不仅仅局限在工作中的时间，而是指所有的时间（工作，娱乐，生活琐事，…）。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>时间管理是什么？</li>
<li>时间管理具体的方法？</li>
</ul>
<h3 id="时间-ROI"><a href="#时间-ROI" class="headerlink" title="时间 ROI"></a>时间 ROI</h3><p>时间管理，顾名思义就是：对自己的时间进行管理，以达到合理使用的目的。但如何去衡量是否合理使用了时间呢？我们需要引入时间 ROI 的概念。</p>
<p>首先解释下 <a href="https://en.wikipedia.org/wiki/Return_on_investment" target="_blank" rel="noopener">ROI, Return Of Investment</a>，中文叫 ”投资回报率“，维基百科的定义是这样的：</p>
<blockquote>
<p>投资回报率，经济学名词，指投资后所得的收益与成本间的百分比率。</p>
</blockquote>
<p>那么如果放到时间管理的概念上来说，把做某件事情投入的时间看做是成本，而将做这件事情所得到的好处，看做是收益，则时间 ROI 就可以这样定义：</p>
<blockquote>
<p>时间 ROI，指做事情所得的收益和个人花费的时间之间的百分比率</p>
</blockquote>
<p>具体而言，时间 ROI 可以分成三个方面，分别是：做什么事，做事方式和做事效率。</p>
<h5 id="做什么事"><a href="#做什么事" class="headerlink" title="做什么事"></a>做什么事</h5><p><code>做什么事</code> 事实上是一个 0 和 1 的问题 —— 做还是不做？课程中给出了三个原则：</p>
<ol>
<li>多做给自己带来长期回报的、毛利率高的事情</li>
<li>少做「没有长远收益但耗费你现在精力」的事情</li>
<li>拒绝做对自己没有收益的事情</li>
</ol>
<p>是否有一个通用的衡量标准去 <strong>判断事情的收益</strong>？课程中并没有实际给出。我对此的理解是：<strong>不存在通用的一个事实标准，需要自己去建立评价体系</strong>。因为每个人的职业，生活方式，兴趣爱好各不尽相同，对同一个事情的价值的理解也不尽相同，所以如果在生活中运用时间管理，没有人能够替代自己去衡量某件事情的重要性（收益）。</p>
<p>但在工作中，团队内的成员是有共同目标的，在众多要做的事情中，我们必须不断地去思考哪些事情是对我们团队的工作和发展是有利的，特别是从长远角度来说，是有价值的。</p>
<h5 id="做事方式"><a href="#做事方式" class="headerlink" title="做事方式"></a>做事方式</h5><p>在确定了我们要做什么事情之后，接下来我们需要回答的下一个问题是：是否应该由自己去做。有两个基本的原则：</p>
<ul>
<li>专业的事情留给专业的人去做，参考 Steve Jobs 和 Mark Zuckerburg（两者都不会在普通穿着上花很多无谓的时间）</li>
<li>授人以鱼不如授人以渔</li>
</ul>
<p>从这两个原则中，可以衍生出的两个具体做法：</p>
<ul>
<li>学会外包</li>
<li>学会分享和教育（短时间投入对长时间产出）</li>
</ul>
<h5 id="做事效率"><a href="#做事效率" class="headerlink" title="做事效率"></a>做事效率</h5><p>通过 <code>做什么事</code> 和 <code>做事方式</code>，我们可以确定自己需要去做某件事情，那么接下来自然就是做事效率的问题：我们希望由自己完成某些事情时，所需要投入的时间尽可能的少。关于时间投入，课程中提出了一个「二八法则」：</p>
<blockquote>
<p>时间投入的二八法则：20% 的关键任务，决定了 80% 的工作成果</p>
</blockquote>
<p>那么，提高效率的策略是：</p>
<ul>
<li>减少对 80% 非创造性、常规任务的精力投入</li>
<li>增加对 20% 关键任务的精力投入</li>
</ul>
<p>但具体我们有什么方法，可以执行上述的两个策略呢？在下一节中有具体的方法。</p>
<hr>
<h3 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h3><p>接下来是几个具体的措施，可以帮助我们在日常的工作或者生活中帮助自己进行时间管理：</p>
<h5 id="确定关键任务：三件事原则"><a href="#确定关键任务：三件事原则" class="headerlink" title="确定关键任务：三件事原则"></a>确定关键任务：三件事原则</h5><p>关于时间管理，我们需要避免一个误区：</p>
<blockquote>
<p>时间管理追求的不是「效率」而是「效果」– 效率只是代表了做的事情的量的大小，但不总是有用的。</p>
</blockquote>
<p>为了去避免走弯路，做无用功，我们要去将平时工作的任务进行区分：哪些是关键任务？哪些是常规任务？在每周的开始，我们需要去确定本周 <strong>最重要的三件事</strong>，这三件事就是个人（或者团队）最重要的三件事。在工作的时候，我们要专注在这三件事情上。在每周结束之后，我们要对这三件事情去进行一个复盘，总结执行的效果，分析其中的原因。</p>
<p>如何去定义最重要的三件事：</p>
<blockquote>
<p>其他的事情都做了，就这件事没有做，这周是合格的么？</p>
<p>其他的事情都没有做，就做了这件事，这周是合格的么？</p>
</blockquote>
<h5 id="克服拖延症（战拖）"><a href="#克服拖延症（战拖）" class="headerlink" title="克服拖延症（战拖）"></a>克服拖延症（战拖）</h5><p><strong>两分钟原则</strong></p>
<blockquote>
<p>对于一些可以在两分钟之内处理掉的问题，就马上去处理</p>
</blockquote>
<p><strong>奖惩机制</strong></p>
<p>奖惩机制本质上是一种手段，让我们尝试去锻炼自己的意志力。</p>
<p>理性决策/延迟满足 vs. 及时行乐/活在当下</p>
<ul>
<li>游戏：bear vs. monkey<ul>
<li>设置一个心愿单（如：单反，Macbook，去xxx旅游）</li>
<li>设置一个奖励基金，当奖励基金内余额达到了某个心愿所需要的花费，就兑现它</li>
<li>当意识到自己应该去做某件一直在拖延的事情时：<ul>
<li>如果果断去做了：bear+1</li>
<li>如果犯懒了没有去做（想玩游戏，想睡觉…）：monkey+1</li>
<li>bear：+30元</li>
<li>monkey：-30元</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="GTD-Getting-Things-Done"><a href="#GTD-Getting-Things-Done" class="headerlink" title="GTD (Getting Things Done)"></a>GTD (Getting Things Done)</h5><p>外脑记事，大脑做事</p>
<ul>
<li>3个核心概念<ul>
<li>Inbox：收集所有要做的任务（例子：帮老婆采购物品，记录在冰箱的便利贴上）</li>
<li>任务体系：365天 / 52周 / 12月<ul>
<li>每月第一天/每周第一天列好 本月/本周的计划</li>
<li>每天早上用10分钟完成日计划</li>
</ul>
</li>
<li>复盘：每天睡前5分钟做记录</li>
</ul>
</li>
</ul>
<p>四象限法则</p>
<h4 id="SOP-Standard-Operation-Procedure"><a href="#SOP-Standard-Operation-Procedure" class="headerlink" title="SOP (Standard Operation Procedure)"></a>SOP (Standard Operation Procedure)</h4><blockquote>
<p>子曰：超过两次的重复都是不合理的</p>
</blockquote>
<p>在代码上，如果我们发现了有冗余的代码，我们会将重复的代码用函数或者模块封装起来；在日常的工作中，如果有重复的操作流程，我们也应该尽量将流程 <strong>以书面或流程图的形式</strong> 保存下来，以提高工作效率。</p>
<p>其实，推广到文档，也是一样的…</p>
<h5 id="如何保持专注：番茄工作法"><a href="#如何保持专注：番茄工作法" class="headerlink" title="如何保持专注：番茄工作法"></a>如何保持专注：番茄工作法</h5><blockquote>
<p>番茄工作法（英语：Pomodoro Technique）是一种时间管理法方法，在上世纪八十年代由Francesco Cirillo创立。该方法使用一个定时器来分割出一个一般为25分钟的工作时间和5分钟的休息时间，而那些时间段被称为pomodori，为意大利语单词 pomodoro（中文：番茄）之复数。</p>
</blockquote>
<p>番茄工作法的好处：</p>
<ol>
<li>培养专注的习惯</li>
<li>培养休息的习惯</li>
<li>可以作为衡量自己工时的计算单位</li>
</ol>
<p>使用番茄工作法的要点：</p>
<ol>
<li>尽量避免被打断</li>
<li>到点了强制自己休息</li>
<li>休息间隔中不要做 “烧脑” 的事情</li>
</ol>
<h3 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h3><p>这篇文章是「分答」上的 <a href="https://fd.zaih.com/column/800037458495911204?from=search" target="_blank" rel="noopener">时间管理训练营</a> 的其中一部分内容的简单总结，总的来说回答了两个问题：</p>
<ul>
<li>时间管理是什么？</li>
<li>时间管理具体的方法？</li>
</ul>
<p>首先我们引入了「时间 ROI」，用于作为衡量时间管理效果的指标；「时间 ROI」又分为「做什么事」「做事方式」和「做事效率」三个范畴，针对这三个范畴，在日常生活和工作中，我们又有一些方法可以帮助自己提高对时间的利用程度。</p>
<p>以下是一个简单的思维导图：</p>
<p><img src="/images/time-management-mindmap.png" alt=""></p>
<p>本文只是对时间管理课程的一点记录摘要，还有课程的很多地方未能覆盖到，有兴趣的同学可以参加该课程在「分答」上的<a href="https://fd.zaih.com/column/800037740676605230" target="_blank" rel="noopener">第二期</a></p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E4%BD%9C%E6%A5%AD%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">标准作业程序, 维基百科</a></li>
<li><a href="https://en.wikipedia.org/wiki/Return_on_investment" target="_blank" rel="noopener">Return on Investment, Wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95" target="_blank" rel="noopener">番茄工作法, 维基百科</a></li>
<li><a href="https://fd.zaih.com/column/800037458495911204?from=search" target="_blank" rel="noopener">时间管理训练营(第一期), 分答</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这个信息爆炸的时代，作为个人而言，所接触到的信息是前所未有的多；而从学校到职场，随着扮演的角色的变化，每个人工作生活中所要做的事情，只会越来越多；如何去合理地，高效地利用自己的时间，既能很好的完成日常需要做的事情，同时可以兼顾自己的兴趣，个人觉得是一个长期的问题。以下就是我在分答上学习 “时间管理” 课程的简单总结。希望能够通过这些方法论，尝试去提高自己对时间的利用程度；如果可以帮到读者，那就更加好了。&lt;br&gt;
    
    </summary>
    
    
      <category term="LifeHack" scheme="http://afantasy.ninja/tags/LifeHack/"/>
    
  </entry>
  
  <entry>
    <title>Color, the known and unknown</title>
    <link href="http://afantasy.ninja/2017/10/08/color-notes/"/>
    <id>http://afantasy.ninja/2017/10/08/color-notes/</id>
    <published>2017-10-08T08:43:00.000Z</published>
    <updated>2017-10-23T03:24:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>When studying the CSS framework <a href="bluma.io">Bluma</a>, I found that it use a very smart way to determine the text color based on the bg color, utiliizing the <code>color luminance</code> to decide to use black text or white text, which is interesting and I found some interesting facts to note it down.<br><a id="more"></a></p>
<h3 id="Color-Luminance"><a href="#Color-Luminance" class="headerlink" title="Color Luminance"></a>Color Luminance</h3><p>Steven Bradley wrote an great article about <a href="http://vanseodesign.com/web-design/color-luminance/" target="_blank" rel="noopener">color luminance</a>, and here are some details:</p>
<ol>
<li>Our eyes have rods（视杆细胞）and cones（视锥细胞）to perceive light/dark as well as different color information; rods are responsible for seeing in low light and are sensitive to light/dark, while cones are responsible for distinguishing different colors. Moreover we have S-cones (blue), M-cones (green) and L-cones (red) for short, medium and long wavelength. – three primary colors.</li>
<li><code>Luminance</code> is the measurement of the intensity of light that reaches our eye, while <code>brightness</code> and <code>value</code> are only the perception of an object’s luminance. <code>Lightness</code> is the brightness relative to the brightness of a similarly illuminated white.</li>
<li>Our perception of lightness (or brightness) don’t scale linearly with luminance. The perceived luminance is dependent on both light intensity and the specific wavelength of that light (a.k.a type of color).</li>
<li>Every color has its own natural luminance levels.</li>
<li>Saturation also affects luminance. If you reduce the saturation of a pure color to 0% the result is a 50% grey with a 50% value for luminance.</li>
<li>differences between HSL, HSB, and HSV:<ul>
<li>HSB/V is measuring <strong>the amount of light</strong></li>
<li>HSL is measuring <strong>the amount of white</strong></li>
</ul>
</li>
</ol>
<h4 id="Quantitive-Implementation"><a href="#Quantitive-Implementation" class="headerlink" title="Quantitive Implementation"></a>Quantitive Implementation</h4><p>From <a href="http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef" target="_blank" rel="noopener">WCAG’s Definition</a>, the <code>relative luminance</code> is:</p>
<blockquote>
<p>the relative brightness of any point in a colorspace, normalized to 0 for darkest black and 1 for lightest white.</p>
</blockquote>
<p>WCAG also provides the formula for luminance:</p>
<blockquote>
<p>For the sRGB colorspace, the relative luminance of a color is defined as <code>L = 0.2126 * R + 0.7152 * G + 0.0722 * B</code> where R, G and B are defined.</p>
<p>as:</p>
<ul>
<li>if RsRGB &lt;= 0.03928 then R = RsRGB/12.92 else R = ((RsRGB+0.055)/1.055) ^ 2.4</li>
<li>if GsRGB &lt;= 0.03928 then G = GsRGB/12.92 else G = ((GsRGB+0.055)/1.055) ^ 2.4</li>
<li>if BsRGB &lt;= 0.03928 then B = BsRGB/12.92 else B = ((BsRGB+0.055)/1.055) ^ 2.4</li>
</ul>
<p>and RsRGB, GsRGB, and BsRGB are defined as:</p>
<ul>
<li>RsRGB = R8bit / 255</li>
<li>GsRGB = G8bit / 255</li>
<li>BsRGB = B8bit / 255</li>
</ul>
</blockquote>
<p><a href="bluma.io">Bluma</a> strictly implements the spec above by having such Sass function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@function colorLuminance($color)</div><div class="line">  $color-rgb: (&apos;red&apos;: red($color),&apos;green&apos;: green($color),&apos;blue&apos;: blue($color))</div><div class="line">  @each $name, $value in $color-rgb</div><div class="line">    $adjusted: 0</div><div class="line">    $value: $value / 255</div><div class="line">    @if $value &lt; 0.03928</div><div class="line">      $value: $value / 12.92</div><div class="line">    @else</div><div class="line">      $value: ($value + .055) / 1.055</div><div class="line">      $value: powerNumber($value, 2)</div><div class="line">    $color-rgb: map-merge($color-rgb, ($name: $value))</div><div class="line">  @return (map-get($color-rgb, &apos;red&apos;) * .2126) + (map-get($color-rgb, &apos;green&apos;) * .7152) + (map-get($color-rgb, &apos;blue&apos;) * .0722)</div></pre></td></tr></table></figure>
<p>Another similar implementation is documented <a href="https://css-tricks.com/snippets/sass/luminance-color-function/" target="_blank" rel="noopener">here</a></p>
<p><a href="http://www.workwithcolor.com/color-luminance-2233.htm" target="_blank" rel="noopener">Work With Color</a> says: </p>
<blockquote>
<p>Luminance on the other hand is a measure to describe the perceived brightness of a color</p>
<p>Contrast as in the distance of luminance between two colors</p>
<p>Color decisions need to consider luminance / contrast because it is key to usability.<br><a href="http://www.workwithcolor.com/hsl-color-picker-01.htm" target="_blank" rel="noopener">HSL Color Picker</a></p>
</blockquote>
<p>From <a href="https://css-tricks.com/snippets/sass/luminance-color-function/" target="_blank" rel="noopener">CSS Tricks’ Definition</a>:</p>
<blockquote>
<p>To put it simply, the luminance of a color defines whether its brightness. A luminance of 1 means the color is white. On the opposite, a luminance score of 0 means the color is black.</p>
</blockquote>
<p>NOTE: WCAG = Web Content Accessibility Guidelines</p>
<h3 id="This-video-blows-my-mind"><a href="#This-video-blows-my-mind" class="headerlink" title="This video blows my mind"></a>This video blows my mind</h3><iframe width="560" height="315" src="https://www.youtube.com/embed/kVny7BswdqY" frameborder="0" allowfullscreen></iframe>

<p>Notice 3:50 – that is crazy. Remember that our eyes could be cheated.</p>
<h3 id="Color-Models"><a href="#Color-Models" class="headerlink" title="Color Models"></a>Color Models</h3><p><a href="http://colorizer.org/" target="_blank" rel="noopener">Colorizer</a> have listed all common color models.</p>
<hr>
<h4 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h4><p>From <a href="https://en.wikipedia.org/wiki/RGB_color_model" target="_blank" rel="noopener">Wikipedia</a>:</p>
<blockquote>
<p>The <strong>RGB color model</strong> is an addictive color model in which red, green and blue light are added together in various ways to reproduce a broad array of colors.<br>…<br>The RGB color model is <em>addictive</em> in the sense that the three light beams are added together, and their light spectra add, wavelength by wavelength, to make the final color’s spectrum. This is essentially opposite to the <em>subtractive</em> color model that applies to paints, inks, dyes and other substances whose colors depends on <em>reflecting</em> the light under which we see them.<br>…</p>
</blockquote>
<h5 id="why-R-G-B"><a href="#why-R-G-B" class="headerlink" title="why R,G,B"></a>why R,G,B</h5><blockquote>
<p>The choice of primary colors (red, green, blue) is related to the physiology of the human eye; good primaries are stimuli that maximize the difference between the responses of the cone cells of the human retina to light of different wavelengths, and that thereby make a large color triangle.<br>…<br>The difference in the signals received from the three kinds allows the brain to differentiate a wide gamut of different colors.</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/CIExy1931_sRGB_gamut_D65.png/440px-CIExy1931_sRGB_gamut_D65.png" alt=""></p>
<blockquote>
<p>The color triangle represents the range of colors which could be reproduced by additive mixing of non-negative amounts of three primary colors.</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/19646016" target="_blank" rel="noopener">为什么 “红、黄、蓝” 是三原色？而不是其他颜色？</a><br><a href="https://www.zhihu.com/question/23839549" target="_blank" rel="noopener">光的三原色和颜料的三原色不一样吗？为什么？</a></p>
<blockquote>
<p>“原色”的指定并没有唯一的选法，因为就理论上而言，凡是彼此之间无法替代的颜色都可以被选为“原色”，只是目前普遍认定“光的三原色”为红绿蓝。</p>
</blockquote>
<h5 id="numeric-representations"><a href="#numeric-representations" class="headerlink" title="numeric representations"></a>numeric representations</h5><ul>
<li>float</li>
<li>percentage</li>
<li>integer range (0,255) - decimal / hexadecimal</li>
<li>larger integer ranges for each primary color (High-end digital image equipment)</li>
</ul>
<p><strong>[Concept] illuminant</strong></p>
<p>From Wikipedia <a href="https://en.wikipedia.org/wiki/Standard_illuminant#Illuminant_series_D" target="_blank" rel="noopener">Standard Illuminant</a>:</p>
<blockquote>
<p>The International Commission on Illumination (usually abbreviated CIE for its French name) is th body responsible for publishing all of the well-known standard illuminants.</p>
</blockquote>
<p>There are many standards like Illuminant A, B, C … The most common used one is called <strong>Illuminant D</strong>, which:</p>
<blockquote>
<p>… represents phases of daylight, … the D series of illuminants are constructed to represent natural daylight. They are difficult to produce artificially, but are easy to characterized mathematically.</p>
</blockquote>
<h5 id="What-is-white"><a href="#What-is-white" class="headerlink" title="What is white?"></a>What is white?</h5><p><a href="https://en.wikipedia.org/wiki/White_point" target="_blank" rel="noopener">White Point</a></p>
<blockquote>
<p>A white point is a set of tristimulus values (a set of values of 3 primary colors) or chromaticity coordinates that <em>serve to define the color “white”</em> in image capture, encoding, or reproduction. Depending on the application, different definitions of white are needed to give acceptable results.</p>
</blockquote>
<p>SPD = Spectral Power Distribution (光谱能量分布??)</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Illuminant_D65" target="_blank" rel="noopener">D65</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%B8%9B%E8%89%B2%E6%B3%95" target="_blank" rel="noopener">Subtractive color</a></li>
<li><a href="https://en.wikipedia.org/wiki/Chromaticity" target="_blank" rel="noopener">Chromaticity</a></li>
</ul>
<p><code>色度(Colorfulness/Chroma/Saturation)</code>, <code>色相(Hue)</code></p>
<p><em>色度</em> 指的是色彩的纯度，也叫 <em>饱和度</em> 或者 <em>彩度</em>。</p>
<hr>
<h4 id="CMYK"><a href="#CMYK" class="headerlink" title="CMYK"></a>CMYK</h4><p><a href="https://en.wikipedia.org/wiki/CMYK_color_model" target="_blank" rel="noopener">CMYK - Wikipedia</a></p>
<blockquote>
<p>The CMYK color model (process color, four color) is a subtractive color model, used in color printing, and is also used to describe the printing process itself.</p>
</blockquote>
<ul>
<li>C - Cyan</li>
<li>M - Magenta</li>
<li>Y - Yellow</li>
<li>K - Key (black)</li>
</ul>
<h4 id="HSL"><a href="#HSL" class="headerlink" title="HSL"></a>HSL</h4><p><a href="https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4#.E4.BB.8EHSL.E5.88.B0RGB.E7.9A.84.E8.BD.AC.E6.8D.A2" target="_blank" rel="noopener">HSL和HSV色彩空间</a></p>
<blockquote>
<p>HSL和HSV都是一种将RGB色彩模型中的点在圆柱坐标系中的表示法。这两种表示法试图做到比RGB基于笛卡尔坐标系的几何结构更加直观。</p>
</blockquote>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Hsl-hsv_models.svg/800px-Hsl-hsv_models.svg.png" alt=""></p>
<p>Colorizer 使用了圆锥表示 HSL：</p>
<p><img src="http://colorizer.org/img/hsl.png" alt=""></p>
<ul>
<li>Hue（H），色相，是色彩的基本属性，即平时所说的颜色名称</li>
<li>Saturation（S），饱和度，是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0~100% 的数值</li>
<li>Lightness（L），亮度，取 0~100%</li>
</ul>
<h4 id="RGB-gt-HSL"><a href="#RGB-gt-HSL" class="headerlink" title="RGB =&gt; HSL"></a>RGB =&gt; HSL</h4><p><a href="https://www.w3.org/TR/css3-color/#hsl-color" target="_blank" rel="noopener">Algorithm in CSS3 Specification</a></p>
<p><a href="https://stackoverflow.com/a/9493060/1301194" target="_blank" rel="noopener">An JS implementation</a> based on the spec:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Converts an HSL color value to RGB. Conversion formula</div><div class="line"> * adapted from http://en.wikipedia.org/wiki/HSL_color_space.</div><div class="line"> * Assumes h, s, and l are contained in the set [0, 1] and</div><div class="line"> * returns r, g, and b in the set [0, 255].</div><div class="line"> *</div><div class="line"> * @param   &#123;number&#125;  h       The hue</div><div class="line"> * @param   &#123;number&#125;  s       The saturation</div><div class="line"> * @param   &#123;number&#125;  l       The lightness</div><div class="line"> * @return  &#123;Array&#125;           The RGB representation</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hslToRgb</span>(<span class="params">h, s, l</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> r, g, b;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)&#123;</div><div class="line">        r = g = b = l; <span class="comment">// achromatic</span></div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">var</span> hue2rgb = <span class="function"><span class="keyword">function</span> <span class="title">hue2rgb</span>(<span class="params">p, q, t</span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t += <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(t &gt; <span class="number">1</span>) t -= <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(t &lt; <span class="number">1</span>/<span class="number">6</span>) <span class="keyword">return</span> p + (q - p) * <span class="number">6</span> * t;</div><div class="line">            <span class="keyword">if</span>(t &lt; <span class="number">1</span>/<span class="number">2</span>) <span class="keyword">return</span> q;</div><div class="line">            <span class="keyword">if</span>(t &lt; <span class="number">2</span>/<span class="number">3</span>) <span class="keyword">return</span> p + (q - p) * (<span class="number">2</span>/<span class="number">3</span> - t) * <span class="number">6</span>;</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> q = l &lt; <span class="number">0.5</span> ? l * (<span class="number">1</span> + s) : l + s - l * s;</div><div class="line">        <span class="keyword">var</span> p = <span class="number">2</span> * l - q;</div><div class="line">        r = hue2rgb(p, q, h + <span class="number">1</span>/<span class="number">3</span>);</div><div class="line">        g = hue2rgb(p, q, h);</div><div class="line">        b = hue2rgb(p, q, h - <span class="number">1</span>/<span class="number">3</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="built_in">Math</span>.round(r * <span class="number">255</span>), <span class="built_in">Math</span>.round(g * <span class="number">255</span>), <span class="built_in">Math</span>.round(b * <span class="number">255</span>)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="Color-Meaning"><a href="#Color-Meaning" class="headerlink" title="Color Meaning"></a>Color Meaning</h3><p><a href="http://vanseodesign.com/web-design/color-meaning/" target="_blank" rel="noopener">http://vanseodesign.com/web-design/color-meaning/</a></p>
<blockquote>
<p>… there is no substantive evidence that support a universal system of color meaning. It’s not that colors themselves have specific meaning, but rather that <strong>we have culturally assigned meanings to them</strong>.</p>
<p>… it’s important to understand who your target audience is and how your audience attaches meaning to color.</p>
</blockquote>
<ul>
<li><strong>warm colors:</strong> red, orange, yellow – passion, energy, impulsiveness, happiness, coziness and comfort</li>
<li><strong>cool colors:</strong> green, blue, violet – calm, trust, professionalism, also sadness and melancholy</li>
</ul>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul>
<li>HSB/HSV</li>
<li>HSI (Hue, Saturation, Intensity) ???</li>
<li><a href="http://vanseodesign.com/web-design/color-theory/" target="_blank" rel="noopener">Color Theory, The Color Wheel And Color Schemes</a></li>
<li><a href="http://vanseodesign.com/web-design/whitespace/" target="_blank" rel="noopener">Whitespace: Less Is More In Web Design</a></li>
<li><a href="http://vanseodesign.com/web-design/design-basics-repetition/" target="_blank" rel="noopener">Design Basics: Repetition To Create Visual Themes</a></li>
<li><a href="http://www.color-wheel-pro.com/color-theory-basics.html" target="_blank" rel="noopener">Color Theory Basics</a></li>
<li><a href="http://www.tigercolor.com/color-lab/color-theory/color-harmonies.htm" target="_blank" rel="noopener">Basic techniques for combining colors</a></li>
<li><a href="http://therefractedlight.blogspot.jp/2010/06/luminance-is-more-important-than-color.html" target="_blank" rel="noopener">Luminance is More Important than Color, The Refracted Light</a></li>
<li><a href="http://vanseodesign.com/web-design/color-systems-1/" target="_blank" rel="noopener">Color Systems — Part 1</a></li>
<li><a href="http://vanseodesign.com/web-design/color-systems-2/" target="_blank" rel="noopener">Color Systems — Part 2</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;When studying the CSS framework &lt;a href=&quot;bluma.io&quot;&gt;Bluma&lt;/a&gt;, I found that it use a very smart way to determine the text color based on the bg color, utiliizing the &lt;code&gt;color luminance&lt;/code&gt; to decide to use black text or white text, which is interesting and I found some interesting facts to note it down.&lt;br&gt;
    
    </summary>
    
    
      <category term="Color" scheme="http://afantasy.ninja/tags/Color/"/>
    
  </entry>
  
  <entry>
    <title>Electron 使用初体验</title>
    <link href="http://afantasy.ninja/2017/08/21/electron-first-glance/"/>
    <id>http://afantasy.ninja/2017/08/21/electron-first-glance/</id>
    <published>2017-08-20T16:17:00.000Z</published>
    <updated>2017-08-20T16:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Electron 的流水账记录<br><a id="more"></a></p>
<h3 id="上手和使用"><a href="#上手和使用" class="headerlink" title="上手和使用"></a>上手和使用</h3><p>下载 <code>electron-quick-start</code> 仓库到本地，基于该仓库进行开发</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Clone the Quick Start repository</span></div><div class="line">$ git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</div><div class="line"></div><div class="line"><span class="comment"># Go into the repository</span></div><div class="line">$ <span class="built_in">cd</span> electron-quick-start</div><div class="line"></div><div class="line"><span class="comment"># Install the dependencies and run</span></div><div class="line">$ npm install &amp;&amp; npm start</div></pre></td></tr></table></figure>
<p>在 quick start 中，入口文件 <code>main.js</code> 使用了 Electron 的 API 调起了一个 <code>BrowserWindow</code> 的实例，并在这个实例中，打开了一个在本地的 HTML 文件 <code>index.html</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Create the browser window.</span></div><div class="line">  mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;<span class="attr">width</span>: <span class="number">800</span>, <span class="attr">height</span>: <span class="number">600</span>&#125;)</div><div class="line"></div><div class="line">  <span class="comment">// and load the index.html of the app.</span></div><div class="line">  mainWindow.loadURL(url.format(&#123;</div><div class="line">    <span class="attr">pathname</span>: path.join(__dirname, <span class="string">'index.html'</span>),</div><div class="line">    <span class="attr">protocol</span>: <span class="string">'file:'</span>,</div><div class="line">    <span class="attr">slashes</span>: <span class="literal">true</span></div><div class="line">  &#125;))</div><div class="line"></div><div class="line">  <span class="comment">// Open the DevTools.</span></div><div class="line">  <span class="comment">// mainWindow.webContents.openDevTools()</span></div><div class="line"></div><div class="line">  <span class="comment">// Emitted when the window is closed.</span></div><div class="line">  mainWindow.on(<span class="string">'closed'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Dereference the window object, usually you would store windows</span></div><div class="line">    <span class="comment">// in an array if your app supports multi windows, this is the time</span></div><div class="line">    <span class="comment">// when you should delete the corresponding element.</span></div><div class="line">    mainWindow = <span class="literal">null</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来的事情就交给这个 HTML 文件了，你可以根据自己的实际需要随意编写，在 <code>base64-convertor</code> 这个应用中，我需要在前端展示一个 “一键转换” 的功能，所以需要一个输入框和一个输出结果的框，以及一个 “转换” 按钮。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"input"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"convert"</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>转换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"output"</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后我们需要在点击转换按钮时，调用 <code>js-base64</code> 的 API 将用户输入的字符串进行转换。首先在 <code>index.html</code> 里面引入 JS 脚本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 省略... --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 省略... --&gt;</span></div><div class="line">    </div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">        <span class="comment">// You can also require other files to run in this process</span></div><div class="line">        <span class="built_in">require</span>(<span class="string">'./renderer.js'</span>)</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>注意到我们可以直接在页面内使用 <code>require</code> 方法，这个和一般的 Web 网页开发有所不同。在 <code>renderer.js</code> 里面我们编写实际的逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// renderer.js</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Base64 = <span class="built_in">require</span>(<span class="string">'js-base64'</span>).Base64</div><div class="line"></div><div class="line"><span class="keyword">let</span> inputEl = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>)</div><div class="line"><span class="keyword">let</span> outputEl = <span class="built_in">document</span>.getElementById(<span class="string">'output'</span>)</div><div class="line"><span class="keyword">let</span> convertBtn = <span class="built_in">document</span>.getElementById(<span class="string">'convert'</span>)</div><div class="line"></div><div class="line">convertBtn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> val = inputEl.value</div><div class="line">    <span class="keyword">const</span> output = Base64.encode(val) <span class="comment">// 调用 API</span></div><div class="line"></div><div class="line">    outputEl.innerHTML = output</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后就可以了~~</p>
<p><img src="./electron-demo.gif" alt=""></p>
<h3 id="开发查看效果"><a href="#开发查看效果" class="headerlink" title="开发查看效果"></a>开发查看效果</h3><p><code>electron .</code></p>
<h3 id="打包-amp-构建-Installer"><a href="#打包-amp-构建-Installer" class="headerlink" title="打包 &amp; 构建 Installer"></a>打包 &amp; 构建 Installer</h3><p>使用 <a href="https://github.com/electron-userland/electron-packager" target="_blank" rel="noopener">electron-packager</a> 来进行打包，然后对应 MacOS 和 Windows 不同平台，需要用不同的构建 Installer 方法。以下操作都在 MacOS 上执行。</p>
<h4 id="Building-Mac-OS-App"><a href="#Building-Mac-OS-App" class="headerlink" title="Building Mac OS App"></a>Building Mac OS App</h4><p>这里我们使用 <a href="https://github.com/mongodb-js/electron-installer-dmg" target="_blank" rel="noopener">electron-installer-dmg</a> 来构建 MacOS 的 installer，其中参数的含义为：</p>
<ul>
<li><code>asar=true</code>：在打包过程中使用 <a href="https://github.com/electron/asar" target="_blank" rel="noopener">asar</a>，将应用的源代码打包成一个压缩包</li>
<li><code>--overwrite</code>：总是覆写原有路径上的同名文件</li>
<li><code>--platform=darwin</code>：构建 Mac OS 应用（若需要在 Mac Apple Store 上架则需要指明是 <code>mas</code> ）</li>
<li><code>--out=builds</code>：输出到 <code>builds/</code> 目录下</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 打包应用</span></div><div class="line">ELECTRON_MIRROR=<span class="string">"https://npm.taobao.org/mirrors/electron"</span> electron-packager . --overwrite --asar=<span class="literal">true</span> base64-convertor --platform=darwin --out=builds</div><div class="line"></div><div class="line"><span class="comment"># 构建安装包（Installer）</span></div><div class="line">electron-install-dmg --out=installers --overwrite ./builds/base64-convertor-darwin</div></pre></td></tr></table></figure>
<p>值得一提的是，应用的名字不可以超过 27 个字：<a href="https://github.com/LinusU/node-appdmg/issues/48" target="_blank" rel="noopener">https://github.com/LinusU/node-appdmg/issues/48</a></p>
<h4 id="Building-Windows-App"><a href="#Building-Windows-App" class="headerlink" title="Building Windows App"></a>Building Windows App</h4><p>在 Mac OS 系统上构建 Windows 应用，需要的步骤会更繁琐一些。<del>其实我觉得必要性也不是太大</del></p>
<p>本着尝试的态度，还是试了一下整个流程，这里仅列出打包 win32 的操作，win64 的并没有尝试。</p>
<p><strong>准备工作：下载 Wine, Mono</strong></p>
<p>在非 Windows 平台中，需要 <a href="https://github.com/electron/windows-installer/issues/112#issuecomment-229922112" target="_blank" rel="noopener">提前安装 wine 和 mono</a>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew install wine</div><div class="line">brew install mono</div></pre></td></tr></table></figure>
<p><strong>打包应用</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ELECTRON_MIRROR=\<span class="string">"https://npm.taobao.org/mirrors/electron/\" electron-packager . --overwrite --asar=true base64-convertor --platform=win32 --out=builds</span></div></pre></td></tr></table></figure>
<p><strong>构建 Windows Installer</strong></p>
<p>参照了 @crilleengvall 的 electron 教程中 <a href="https://www.christianengvall.se/electron-windows-installer/" target="_blank" rel="noopener">关于 windows installer 的这篇</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node ./create-win32-installer.js</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create-win32-installer.js</span></div><div class="line"><span class="keyword">const</span> createWindowsInstaller = <span class="built_in">require</span>(<span class="string">'electron-winstaller'</span>).createWindowsInstaller</div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInstallerConfig</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> rootPath = path.join(<span class="string">'./'</span>)</div><div class="line">    <span class="keyword">const</span> outPath = path.join(rootPath, <span class="string">'builds'</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> config = &#123; </div><div class="line">        <span class="attr">appDirectory</span>: path.join(outPath, <span class="string">'base64-convertor-win32-x64'</span>),</div><div class="line">        <span class="attr">authors</span>: <span class="string">'Allen Wu'</span>,</div><div class="line">        <span class="attr">noMsi</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">outputDirectory</span>: path.join(rootPath, <span class="string">'installers'</span>),</div><div class="line">        <span class="attr">exe</span>: <span class="string">'base64-convertor.exe'</span>,</div><div class="line">        <span class="attr">setupExe</span>: <span class="string">'base64-convertor-installer.exe'</span>,</div><div class="line">        <span class="attr">setupIcon</span>: path.join(rootPath, <span class="string">'assets'</span>, <span class="string">'icons'</span>, <span class="string">'hiido.ico'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(config)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getInstallerConfig()</div><div class="line">    .then(createWindowsInstaller)</div><div class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</div><div class="line">        <span class="built_in">console</span>.error(err.message || err)</div><div class="line">        process.exit(<span class="number">1</span>)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure>
<p>如果在过程中遇到了 <code>spawn mono ENOENT</code> 的问题，就是没有安装 <code>mono</code> 这个依赖的原因：<a href="https://github.com/electron/windows-installer/issues/112" target="_blank" rel="noopener">https://github.com/electron/windows-installer/issues/112</a></p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>尝试其他 electron 的打包工具，比如：</p>
<ul>
<li><a href="https://github.com/electron-userland/electron-builder" target="_blank" rel="noopener">electron-builder</a></li>
<li><a href="https://github.com/electron-userland/electron-forge" target="_blank" rel="noopener">electron-forge</a></li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.christianengvall.se/electron-packager-tutorial/" target="_blank" rel="noopener">@crilleengvall 的 electron 教程</a></li>
<li><a href="https://github.com/electron/windows-installer" target="_blank" rel="noopener">electron/windows-installer</a></li>
<li><a href="https://github.com/Squirrel/Squirrel.Windows" target="_blank" rel="noopener">Squirrel/Squirrel.Windows</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 Electron 的流水账记录&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
      <category term="Electron" scheme="http://afantasy.ninja/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>网站统计那些事（四）：工程化，模块化与测试</title>
    <link href="http://afantasy.ninja/2017/05/08/user-tracking-iv/"/>
    <id>http://afantasy.ninja/2017/05/08/user-tracking-iv/</id>
    <published>2017-05-08T06:03:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>网站统计系列的第四篇。没有代码。最后一篇了。<br><a id="more"></a></p>
<p>完全没想到我可以就这个话题写四篇又长又臭的文章…万幸这是最后一篇了 —— 简单介绍项目开发的工程化实践以及如何进行测试。</p>
<p>传送门：</p>
<ul>
<li><a href="../user-tracking-i">网站统计那些事（一）：背景与基础概念</a></li>
<li><a href="../user-tracking-ii">网站统计那些事（二）：统计脚本实现（上）</a></li>
<li><a href="../user-tracking-iii">网站统计那些事（三）：统计脚本实现（下）</a></li>
</ul>
<h2 id="工程化-amp-模块化"><a href="#工程化-amp-模块化" class="headerlink" title="工程化 &amp; 模块化"></a>工程化 &amp; 模块化</h2><p>在公司旧统计脚本的项目中，缺乏对整个工程的任务管理。对此，我们在项目中设计了较完整的工程以及开发流程。目录结构如下：</p>
<p><img src="/images/hiidojs-code-structure.png" alt=""></p>
<ul>
<li><code>dist/</code> - 编译得到的生产环境下的脚本</li>
<li><code>src/</code> - 项目源代码</li>
<li><code>doc/</code> - 文档</li>
<li><del><code>mtq/</code> - <em>@deprecated</em> 无用文件</del></li>
<li><del><code>others/</code> - <em>@deprecated</em> 参考用的文件</del></li>
<li><code>test/</code> - 单元测试代码</li>
<li><code>vendor/</code> - 页面测试使用的第三方的测试库</li>
</ul>
<p>由于我们采用了模块化开发，且依赖于 <a href="https://github.com/hotoo/detector" target="_blank" rel="noopener">detector</a>，所以我们采用 webpack 将 <code>src/</code> 中的代码编译到 <code>dist/</code> 中。又由于 <a href="https://github.com/hotoo/detector" target="_blank" rel="noopener">detector</a> 的源码采用 ES6 语法，所以我们加入了 <code>babel-loader</code>，同时为了在 IE8 及以下的版本中顺利通过，我们采用了 babel 提供的 <a href="https://github.com/bkonkle/babel-preset-es2015-loose" target="_blank" rel="noopener">loose-mode</a></p>
<p>开发中使用的任务用 Gulp 管理，采用 ESLint 进行代码检查。</p>
<p>重新审视公司的旧统计脚本的项目，另一个严重的问题就是，各个功能之间的代码全部混在一个文件里，对于后续维护来说非常的痛苦，同时也无法享受到直接引用第三方库的便利。我们采用了 CommonJS 模块化开发的方式。</p>
<p>在接下来的工作中，我们会采用 ES6 语法对代码进行重写，同时考虑用 <a href="https://github.com/lukehoban/es6features#modules" target="_blank" rel="noopener">ES Modules</a> 取代原有的 CommonJS 模式。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>为了保证统计脚本统计结果的准确性，以及具备良好的兼容性，我们在本地架设了完整的测试。</p>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>在 <a href="../user-tracking-ii#3-获取设备信息">获取设备信息</a> 中我们提到过，为了提高代码的可持续维护，建立一套测试机制以及可维护的 userAgent 库是很有必要的。在模块化的基础上，我们使用 <a href="https://mochajs.org/" target="_blank" rel="noopener">Mocha</a> 建立了针对设备信息检测的单元测试。以下是一段真实的测试代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</div><div class="line"><span class="keyword">var</span> osFixtures = <span class="built_in">require</span>(<span class="string">'./fixtures/devices'</span>);</div><div class="line"></div><div class="line">describe(<span class="string">'操作系统'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  _.forEach(osFixtures, <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> desc = f.name + <span class="string">': '</span> + f.key + <span class="string">'|'</span>;</div><div class="line">    <span class="keyword">if</span> (f.key === <span class="string">'linux'</span>) &#123;</div><div class="line">      desc += <span class="string">'[发行版]'</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      desc += <span class="string">'[版本号]'</span>;</div><div class="line">    &#125;</div><div class="line">    describe(desc, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      _.forEach(f.cases, <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</div><div class="line">        it(c[<span class="number">0</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">var</span> ret = detector(c[<span class="number">0</span>]);</div><div class="line">          assert.equal(ret.os, c[<span class="number">1</span>].os);</div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line">    &#125;)</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在测试代码中引用的 <code>./fixtures/devices</code> 就是一个记录了近百条 userAgent 及其真实的设备信息（包括 OS 和浏览器）的 <strong>json 文件</strong></p>
<p>在开发前期，我们从以下几个来源获取 userAgent：</p>
<ul>
<li><a href="http://www.useragentstring.com/pages/useragentstring.php" target="_blank" rel="noopener">UserAgentString</a></li>
<li><a href="http://www.fynas.com/ua" target="_blank" rel="noopener">fynas.com</a></li>
<li><a href="http://www.xuebuyuan.com/885759.html" target="_blank" rel="noopener">各种手机的 User-Agent</a></li>
<li>部分杂牌浏览器：<ul>
<li><a href="http://blog.zsxsoft.com/post/4" target="_blank" rel="noopener">115</a></li>
<li><a href="http://www.cnblogs.com/qq21270/p/3799124.html" target="_blank" rel="noopener">2345</a></li>
<li><a href="https://github.com/hotoo/detector/issues/71" target="_blank" rel="noopener">userAgent string - 其中含百度盒子</a></li>
<li><a href="http://www.webapps-online.com/online-tools/user-agent-strings/dv/browser581791/baidu-spark-browser" target="_blank" rel="noopener">Baidu Spark</a></li>
<li><a href="http://blog.csdn.net/ccclll1990/article/details/17006159" target="_blank" rel="noopener">Baidu Spark II</a></li>
<li><a href="https://www.aqtronix.com/useragents/?Action=ShowAgentDetails&amp;Name=F1Browser+Yunhai+Browser" target="_blank" rel="noopener">Yunhai / F1浏览器</a></li>
<li><a href="http://blog.csdn.net/ccclll1990/article/details/17006159" target="_blank" rel="noopener">海豚浏览器</a></li>
<li><a href="http://liulanmi.com/dl/10230.html/comment-page-2" target="_blank" rel="noopener">旗鱼浏览器</a></li>
<li><a href="https://github.com/hotoo/detector/issues/45" target="_blank" rel="noopener">hotoo/detector: 用户份额大于 0.01% 的客户端 ua 信息</a></li>
</ul>
</li>
</ul>
<p>在系统获取了一批 userAgent 后，我们根据预上线测试阶段所搜集到设备信息为空的请求日志，进行分析后又加入了一批新的 userAgent，而所有在 <code>./test/fixtures</code> 中的测试用例，我们都通过测试的方式进行覆盖并保证其输出是我们预期的结果。</p>
<h4 id="E2E-测试"><a href="#E2E-测试" class="headerlink" title="E2E 测试"></a>E2E 测试</h4><p>由于 ut.js 的实际使用场景将会是线上的各个站点，所以在发布之前，我们必须在本地进行 E2E 测试以保证其基本功能能够顺利进行。以下是 E2E 测试的结构图</p>
<p><img src="/images/hiidojs-e2e-test.png" alt=""></p>
<p>在测试中：</p>
<ul>
<li>我们使用 Express 构建一个简单的 Mock Log Server：<ol>
<li>提供一个 log 的 API 地址供 hiido.js 使用，这个 API 地址在测试时代替了 hiido log 服务器集群，因为我们需要了解实际上报的内容；</li>
<li>提供一个路由加载 E2E 测试用的网页</li>
</ol>
</li>
<li>我们使用多个浏览器 Client 打开测试网页，同时页面上加载了 hiido.js 的代码</li>
<li>根据测试的具体需要，我们 <strong>像真实用户一样操作</strong> 并观察实际上报的数据内容是否符合预期，具体的数据内容由 Mock Log Server 输出到终端或者保存到日志。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站统计系列的第四篇。没有代码。最后一篇了。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
      <category term="User Tracking" scheme="http://afantasy.ninja/tags/User-Tracking/"/>
    
  </entry>
  
  <entry>
    <title>网站统计那些事（三）：统计脚本实现（下）</title>
    <link href="http://afantasy.ninja/2017/05/08/user-tracking-iii/"/>
    <id>http://afantasy.ninja/2017/05/08/user-tracking-iii/</id>
    <published>2017-05-08T06:02:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>网站统计系列的第三篇。坑爹的兼容性。<br><a id="more"></a></p>
<p>本篇将继续讨论统计脚本的具体功能实现：</p>
<ul>
<li><a href="#5-统计停留时长">统计停留时长</a></li>
<li><a href="#6-其他细节">其他细节</a></li>
<li><a href="#7-一些小坑">一些小坑</a></li>
</ul>
<p>传送门：</p>
<ul>
<li><a href="../user-tracking-i">网站统计那些事（一）：背景与基础概念</a></li>
<li><a href="../user-tracking-ii">网站统计那些事（二）：统计脚本实现（上）</a></li>
<li><a href="../user-tracking-iv">网站统计那些事（四）：工程化，模块化与测试</a></li>
</ul>
<h2 id="5-统计停留时长"><a href="#5-统计停留时长" class="headerlink" title="5 统计停留时长"></a>5 统计停留时长</h2><p>在<a href="../user-tracking-i#UV-独立访客数">系列的第一篇</a>中我们提到， <code>PV/UV</code> 可以较模糊地反映单个用户对某个页面的黏度，另一个有效反应用户黏度的值就是用户在该页面上的停留时间。在实际开发中，如何计算用户在页面上的停留时间，成为了一个非常复杂的问题。</p>
<h4 id="方案一：头尾相减"><a href="#方案一：头尾相减" class="headerlink" title="方案一：头尾相减"></a>方案一：头尾相减</h4><p>在计算停留时长时，一个简单的思路是使用 ”头尾相减“，即：<code>停留时长 = T(用户离开页面时间点) - T(用户进入页面时间点)</code></p>
<p>这样乍看没有问题，但如果用户实际上 <strong>并没有在看这个页面呢</strong> ？有趣。</p>
<p>用户是有可能不在看这个页面的：</p>
<ul>
<li>用户打开了另外一个标签页</li>
<li>用户打开了另一个应用（或者浏览器被最小化了）</li>
<li>（移动端）用户将浏览器 app 切到了后台，打开了微信</li>
<li>用户只是单纯的走开了…</li>
</ul>
<p>如果需要获取用户 <strong>真正在浏览</strong> 页面时所花的时间，我们不能够单纯的使用头尾相减的方式，因为在这种情况下，以上几种情况都会导致用户的停留时长高的可怕。</p>
<h4 id="方案二：定时心跳"><a href="#方案二：定时心跳" class="headerlink" title="方案二：定时心跳"></a>方案二：定时心跳</h4><p>针对上述提到的几种用户不在浏览页面的情况，ut.js 采用了定时心跳的方法，具体策略如下（为表述方便，以下简称停留时长为 lifetime）：</p>
<ul>
<li>从用户进入页面时，初始化 lifetime 为 0</li>
<li>初始化后，每一个 tick（一个 rAF 的 loop，如果浏览器不支持 rAF 则默认为每 16.67ms）进行一次心跳，每次心跳给 lifetime 加上这次 tick 的时间</li>
<li>在 <strong>用户不在看页面</strong> 时暂停心跳</li>
<li>在 <strong>用户重新看页面</strong> 时重启心跳</li>
<li>在 <strong>用户离开页面</strong> 时，直接上报 lifetime 的值</li>
</ul>
<p>看上去这样的策略没问题，只要我们知道在 JS 中如何得知用户并不在看当前的页面。</p>
<h4 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h4><p>考虑用户在看另一个标签页或者使用另一个程序的情况，使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" target="_blank" rel="noopener">Page Visibility API</a>：</p>
<blockquote>
<p>The Page Visibility API lets you know when a webpage is visible or in focus.</p>
</blockquote>
<p>在浏览器的页面发生切换的时候，Page Visibility API 会触发一个 <code>visibilitychange</code> 的事件，通过监听这个事件，我们可以动态的控制 lifetime 的心跳：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set the name of the hidden property and the change event for visibility</span></div><div class="line"><span class="keyword">var</span> hidden, visibilityChange;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.hidden !== <span class="string">"undefined"</span>) &#123; <span class="comment">// Opera 12.10 and Firefox 18 and later support</span></div><div class="line">  hidden = <span class="string">"hidden"</span>;</div><div class="line">  visibilityChange = <span class="string">"visibilitychange"</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.msHidden !== <span class="string">"undefined"</span>) &#123;</div><div class="line">  hidden = <span class="string">"msHidden"</span>;</div><div class="line">  visibilityChange = <span class="string">"msvisibilitychange"</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.webkitHidden !== <span class="string">"undefined"</span>) &#123;</div><div class="line">  hidden = <span class="string">"webkitHidden"</span>;</div><div class="line">  visibilityChange = <span class="string">"webkitvisibilitychange"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleVisibilityChange</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>[hidden]) &#123;</div><div class="line">    <span class="comment">// 停止心跳...</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 启动心跳...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Handle page visibility change</span></div><div class="line"><span class="built_in">document</span>.addEventListener(visibilityChange, handleVisibilityChange, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<p>找到这个之后我满心欢喜，直到看到了兼容性部分：</p>
<p><img src="/images/page-visibility-api-compatible-table.png" alt=""></p>
<p>这不得不让我们寻求其他解决方案。</p>
<p><img src="/images/no-fuck-say.jpeg" alt=""></p>
<h4 id="文档的-focus-事件"><a href="#文档的-focus-事件" class="headerlink" title="文档的 focus 事件"></a>文档的 focus 事件</h4><p>我们可以监听网页的 <code>focus</code> 事件，来判断用户当前是否在使用这个标签页。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFocus</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 启动心跳...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onBlur</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 停止心跳...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="string">'onfocusin'</span> <span class="keyword">in</span> <span class="built_in">document</span>) &#123;</div><div class="line">  <span class="built_in">document</span>.onfocusin = onFocus;</div><div class="line">  <span class="built_in">document</span>.onfocusout = onBlur;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="built_in">window</span>.onfocus = onFocus;</div><div class="line">  <span class="built_in">window</span>.onblur = onBlur;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/focusin" target="_blank" rel="noopener">focusin</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/focusout" target="_blank" rel="noopener">focusout</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/focus" target="_blank" rel="noopener">focus</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/blur" target="_blank" rel="noopener">blur</a></li>
</ul>
<p>为什么不直接使用 <code>window.onfocus</code> 或者 <code>window.onblur</code> ? 因为 <a href="http://stackoverflow.com/a/3745804/1301194" target="_blank" rel="noopener">出现了兼容性问题</a>：</p>
<blockquote>
<p>onfocus and onblur are buggy on the window object in IE. The alternative is to use the propagating onfocusin and onfocusout events</p>
</blockquote>
<p>注意，这里不可以使用 <code>document</code> 对象的 focus 和 blur 事件，因为这两个事件是不冒泡的。</p>
<h4 id="如果用户只是单纯的走开了呢…"><a href="#如果用户只是单纯的走开了呢…" class="headerlink" title="如果用户只是单纯的走开了呢…?"></a>如果用户只是单纯的走开了呢…?</h4><p>这里的根本问题是：</p>
<blockquote>
<p>用户所在的页面一直处于 focus 的状态，而我们无法得知用户是否在 <strong>真正浏览</strong> 这个页面。</p>
</blockquote>
<p>为了解决这个问题，我们对用户的行为给出了一个关键假设：</p>
<blockquote>
<p>如果用户一直在浏览某个页面，那么他必须会在一定时间内对这个页面进行一定的操作（不管是何种类型的操作）。</p>
</blockquote>
<p>基于假设，我们设计了以下策略：</p>
<ol>
<li>设置一个变量 <code>inactiveTime</code>，记录用户不活跃的时间，初始值 为 0</li>
<li>在每一次心跳中累积 <code>inactiveTime</code>，增加该次心跳的时间</li>
<li>如果用户在页面上产生了操作（mousemove, click, touchstart），则重置 <code>inactiveTime</code> 为 0</li>
<li>当 <code>inactiveTime</code> 的累计时间超过一个阈值时，停止心跳。</li>
</ol>
<p>这个策略保证了在用户离开设备的一段时间内，单个页面的 lifetime 累积的最大值不会超过我们所设定的阈值。</p>
<p>在 ut.js 中我们将这个阈值设为了 <strong>20s</strong> —— 这个数字是没有科学依据的，仅仅是作者对于用户浏览一个屏幕内页面内容所需时间的一个估计。</p>
<p>这个策略也无法 <strong>精准的估计</strong> lifetime —— 你无法采用某个 JS API 来得知用户是不是看着看着网页然后离开了座位去喝口水。</p>
<h4 id="lifetime-计算的最终实现"><a href="#lifetime-计算的最终实现" class="headerlink" title="lifetime 计算的最终实现"></a>lifetime 计算的最终实现</h4><p>关于 lifetime 的计算到这里就告一段落，ut.js 中最终的实现代码如下（为理解方便做了修改）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// addEvent() 是包装了 `window.addEventListener` 和 `window.attachEvent` 的事件监听函数</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> r = <span class="built_in">window</span>.requestAnimationFrame;</div><div class="line"><span class="keyword">var</span> c = <span class="built_in">window</span>.cancelAnimationFrame;</div><div class="line"><span class="keyword">var</span> h;</div><div class="line"></div><div class="line"><span class="keyword">var</span> lt = <span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> ltStart;</div><div class="line"><span class="keyword">var</span> inActiveTime;</div><div class="line"><span class="keyword">var</span> inActiveThreshold = <span class="number">2E4</span>;</div><div class="line"></div><div class="line"><span class="comment">// 创建一个心跳闭包，负责向 lifetime 增加累计时间</span></div><div class="line"><span class="keyword">var</span> h = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> timer;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">beat</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</div><div class="line">    <span class="keyword">var</span> diff = now - ltStart;</div><div class="line"></div><div class="line">    lt = lt + diff;</div><div class="line">    inActiveTime = inActiveTime + diff;</div><div class="line">    ltStart = now;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (inActiveTime &lt;= inActiveThreshold) &#123;</div><div class="line">      timer = r(beat);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      timer = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">start</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (!timer) &#123;</div><div class="line">        ltStart = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        timer = r(beat);</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">stop</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">if</span> (timer) &#123;</div><div class="line">        c(timer);</div><div class="line">        timer = <span class="literal">null</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFocus</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  h.start()</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onBlur</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  h.stop();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在 PC 端使用 focusin / focusout / focus / blur 事件</span></div><div class="line"><span class="keyword">if</span> (<span class="string">'onfocusin'</span> <span class="keyword">in</span> <span class="built_in">document</span>) &#123;</div><div class="line">  <span class="built_in">document</span>.onfocusin = onFocus;</div><div class="line">  <span class="built_in">document</span>.onfocusout = onBlur;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="built_in">window</span>.onfocus = onFocus;</div><div class="line">  <span class="built_in">window</span>.onblur = onBlur;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在移动端使用 Page Visibility API 检查页面是否 active</span></div><div class="line"><span class="keyword">var</span> prefixes = [<span class="string">''</span>, <span class="string">'webkit'</span>, <span class="string">'moz'</span>, <span class="string">'ms'</span>, <span class="string">'o'</span>];</div><div class="line"><span class="keyword">var</span> pf;</div><div class="line"><span class="keyword">var</span> hiddenKey;</div><div class="line"><span class="keyword">var</span> eventKey;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="comment">/* current env is mobile */</span>) &#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prefixes.length; i++) &#123;</div><div class="line">    pf = prefixes[i];</div><div class="line">    hiddenKey = pf ? (pf + <span class="string">'Hidden'</span>) : <span class="string">'hidden'</span>;</div><div class="line">    <span class="keyword">if</span> (hiddenKey <span class="keyword">in</span> <span class="built_in">document</span>) &#123;</div><div class="line">      eventKey = pf + <span class="string">'visibilitychange'</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (eventKey) &#123;</div><div class="line">    addEvent(<span class="built_in">document</span>, eventKey, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">document</span>[hiddenKey] ? onBlur() : onFocus();</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inActiveTime = <span class="number">0</span>;</div><div class="line">h.start(); <span class="comment">// 开始计算 lifetime</span></div></pre></td></tr></table></figure>
<h4 id="上报-lifetime-数据"><a href="#上报-lifetime-数据" class="headerlink" title="上报 lifetime 数据"></a>上报 lifetime 数据</h4><p>在用户结束对网页的访问时，此时我们需要上报 lifetime 数据。单独采用 <code>onbeforeunload</code> 或者 <code>onunload</code> 都是不可取的，因为两个事件都有浏览器不支持的情况出现：</p>
<ul>
<li><a href="https://www.quirksmode.org/bugreports/archives/2004/11/load_and_unload.html" target="_blank" rel="noopener">Opera not supporting load and unload events</a></li>
<li><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=681636" target="_blank" rel="noopener">Mozilla - window.onunload don’t work when is page is in a popup</a></li>
<li><a href="https://webkit.org/blog/516/webkit-page-cache-ii-the-unload-event/" target="_blank" rel="noopener">onunload not working in Safari…</a></li>
</ul>
<p>…这就很吓人了。为了尽可能的实现兼容，保险的做法是对两个事件同时进行监听，只要有一个事件监听到了就上报 lifetime 的数据。具体代码如下（和实际代码有调整）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> leaveReportSent = <span class="literal">false</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reportLeave</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (leaveReportSent) &#123; <span class="comment">// 如果已经发送过了就不再发送了</span></div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 上报 lifetime 数据...</span></div><div class="line">  <span class="comment">// 上报其他数据...</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  leaveReportSent = <span class="literal">true</span>;</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  reportLeave();</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  reportLeave();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是，还有一个问题…</p>
<h4 id="移动端的上报-页面到底走了没有？"><a href="#移动端的上报-页面到底走了没有？" class="headerlink" title="移动端的上报 - 页面到底走了没有？"></a>移动端的上报 - 页面到底走了没有？</h4><p>出于节省流量等考虑，目前相当一部分的手机浏览器都采用了页面缓存的策略，在这个策略下，访问过的上一个页面的文档内容并不会被销毁（即使看上去用户已经关闭了页面），而是被放置到了浏览器自带的一个页面缓存中（详见 Webkit 团队的 <a href="https://webkit.org/blog/427/webkit-page-cache-i-the-basics/" target="_blank" rel="noopener">这篇博客</a>）。</p>
<p>在这种情况下，页面将永远不会触发 <code>beforeunload</code> 或者 <code>unload</code> 事件，按照原有的策略，我们无法进行 lifetime 的上报。这样的直接影响就是，在移动端我们永远无法得知用户在页面上的停留时间。</p>
<p>解决这个问题的思路有两个：</p>
<ol>
<li>利用 <code>pageshow</code> 和 <code>pagehide</code> 事件，当 <code>pagehide</code> 被触发时，视为用户离开了页面；当 <code>pageshow</code> 触发时，视作用户重新进入了页面</li>
<li>利用 <code>Page Visibility API</code>，在页面隐藏起来时，视为用户离开了页面；否则视作用户重新进入了页面。<a href="https://www.igvita.com/2015/11/20/dont-lose-user-and-app-state-use-page-visibility/" target="_blank" rel="noopener">via Ilya Grigorik</a></li>
</ol>
<p>两种思路在相应事件触发时，都上报 lifetime，并重置所有起始变量。</p>
<p>ut.js 使用了第1种实践，具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// lt - 前文提到的储存 lifetime 的变量</span></div><div class="line"><span class="comment">// reportEnter() - 进入页面时上报信息的方法</span></div><div class="line"><span class="comment">// reportLeave() - 离开页面时上报 lifetime 及其他内容的方法</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> leaveReportSent = <span class="literal">false</span>;</div><div class="line"><span class="keyword">var</span> enterReportSent = <span class="literal">false</span>;</div><div class="line"></div><div class="line">addEvent(<span class="built_in">window</span>, <span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (event.persisted) &#123;</div><div class="line">    <span class="comment">// like a new page, reset all related attributes</span></div><div class="line">    leaveReportSent = <span class="literal">false</span>;</div><div class="line">    enterReportSent = <span class="literal">false</span>;</div><div class="line">    lt = <span class="number">0</span>;</div><div class="line"></div><div class="line">    reportEnter();</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addEvent(<span class="built_in">window</span>, <span class="string">'pagehide'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (event.persisted) &#123;</div><div class="line">    reportLeave();</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="6-其他细节"><a href="#6-其他细节" class="headerlink" title="6 其他细节"></a>6 其他细节</h2><ul>
<li>使用了 <code>try ... catch</code> 进行处理错误捕获</li>
<li>暴露一个 <code>hd()</code> 的全局方法，让业务方使用该方法进行 <strong>自定义的上报</strong> ，这一点和 GA 以及百度统计的实现是类似的。</li>
<li>自定义一个 <code>addEvent()</code> 方法封装了 <code>attachEvent</code> 和 <code>addEventListener</code></li>
<li><strong>防止业务方重复加载执行该脚本</strong>：设置一个全局变量作为判定标识</li>
<li>获取额外的设备信息：<ul>
<li>屏幕颜色深度：<code>window.screen.colorDepth</code></li>
<li>屏幕尺寸：<code>window.screen.width</code>,<code>window.screen.height</code></li>
<li>Flash 版本：<code>window.ActiveXObject</code>（随着 Flash 逐渐被淘汰，考虑去掉这个支持）</li>
<li>Cookie：<code>navigator.cookieEnabled</code></li>
<li>Java 支持：<code>navigator.javaEnabled()</code></li>
<li>系统语言：<code>navigator.language</code></li>
</ul>
</li>
</ul>
<h2 id="7-一些小坑"><a href="#7-一些小坑" class="headerlink" title="7 一些小坑"></a>7 一些小坑</h2><h4 id="IE-中使用-console-对象"><a href="#IE-中使用-console-对象" class="headerlink" title="IE 中使用 console 对象"></a>IE 中使用 <code>console</code> 对象</h4><p>在脚本部署逐步上线使用的过程中，<code>console</code> 对象是调试时的一个重要方法，但当实际上线时，我们惊讶地发现正是 <code>console</code> 引起了一些额外的问题：</p>
<ul>
<li>旧版的 IE 中 <code>window</code> 对象并没有 <code>console</code> 属性，</li>
<li>即便有 <code>console</code> 属性，直接使用 <code>console</code> 关键字并不能生效。</li>
</ul>
<p>当然，解决方案是很简单的，写一个简易的 polyfill 即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.console) &#123;</div><div class="line">  <span class="keyword">var</span> <span class="built_in">console</span> = &#123;&#125;;</div><div class="line">  <span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">  <span class="built_in">console</span>.dir = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</div><div class="line">        <span class="built_in">console</span>.log(i + <span class="string">" "</span>, obj[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  <span class="built_in">window</span>.console = <span class="built_in">console</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.console.dir) &#123;</div><div class="line">  <span class="built_in">window</span>.console.dir = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</div><div class="line">      <span class="built_in">window</span>.console.log(i + <span class="string">" "</span>, obj[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 如果希望在后续的代码中使用 console 关键字</span></div><div class="line"><span class="keyword">var</span> <span class="built_in">console</span> = <span class="built_in">window</span>.console;</div></pre></td></tr></table></figure>
<h4 id="360-浏览器在大部分情况下无法检测"><a href="#360-浏览器在大部分情况下无法检测" class="headerlink" title="360 浏览器在大部分情况下无法检测"></a>360 浏览器在大部分情况下无法检测</h4><ul>
<li>援引 <a href="http://tongji.baidu.com/data/browser" target="_blank" rel="noopener">百度统计</a></li>
</ul>
<blockquote>
<p>奇虎360浏览器份额在2010年10月至2011年3月，和2012年9月以来，两次大幅下降，是因为360浏览器去掉了原本的浏览器特征（User-Agent），而表现为IE等浏览器特征所致。</p>
</blockquote>
<ul>
<li><a href="https://github.com/hotoo/detector/issues/6" target="_blank" rel="noopener">detector 包作者的分析</a></li>
<li><a href="http://bbs.csdn.net/topics/390212770#post-394546176" target="_blank" rel="noopener">某位网友的分析, 指出偏方只能够在 360.cn 上起作用</a></li>
<li>Cnzz 之所以能够检测是因为 360 浏览器内核在 cnzz 的域名下的 userAgent 会带有 360SE/EE 标记，在别的域名下不会…<br>详见 <a href="https://www.zhihu.com/question/20556578/answer/15472681" target="_blank" rel="noopener">知乎上的回答</a></li>
</ul>
<h2 id="RECAP"><a href="#RECAP" class="headerlink" title="RECAP"></a>RECAP</h2><p>到这里我们完成了统计脚本实现细节的归纳。下一篇会着重关注具体的工程化实践，以及如何进行测试以保证质量。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站统计系列的第三篇。坑爹的兼容性。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
      <category term="User Tracking" scheme="http://afantasy.ninja/tags/User-Tracking/"/>
    
  </entry>
  
  <entry>
    <title>网站统计那些事（二）：统计脚本实现（上）</title>
    <link href="http://afantasy.ninja/2017/05/08/user-tracking-ii/"/>
    <id>http://afantasy.ninja/2017/05/08/user-tracking-ii/</id>
    <published>2017-05-08T06:01:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>网站统计系列的第二篇。一箩筐辣鸡代码和絮絮叨叨。<br><a id="more"></a></p>
<p>在这一篇中，我们将详细讨论如何从业务实际需求出发，实现一个网站统计脚本。由于涉及细节众多，将分为上下两篇来详述。<strong>为了表述方便，下文我们用 ut.js 来代指统计脚本。</strong></p>
<p>在 ut.js 的实际开发中，我们参考了相当部分的 GA 和百度统计的代码，在此特别致谢。</p>
<p>传送门：</p>
<ul>
<li><a href="../user-tracking-i">网站统计那些事（一）：背景与基础概念</a></li>
<li><a href="../user-tracking-iii">网站统计那些事（三）：统计脚本实现（下）</a></li>
<li><a href="../user-tracking-iv">网站统计那些事（四）：工程化，模块化与测试</a></li>
</ul>
<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><p>本篇将讨论到的实现要点：</p>
<ul>
<li><a href="#1-获取用户的唯一标识">获取用户的唯一标识</a></li>
<li><a href="#2-如何进行上报">如何进行上报</a></li>
<li><a href="#3-获取设备信息">获取设备信息</a></li>
<li><a href="#4-获取用户点击信息">获取用户点击信息</a></li>
</ul>
<h2 id="1-获取用户的唯一标识"><a href="#1-获取用户的唯一标识" class="headerlink" title="1 获取用户的唯一标识"></a>1 获取用户的唯一标识</h2><p>采用 cookie 加随机数的方法生成。这里值得一提的是关于 cookie 的设定。以 <code>www.baidu.com</code><br> 为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 随机生成的一个 100 年后才过期的，支持 *.baidu.com 的 cookie</span></div><div class="line"><span class="built_in">document</span>.cookie = <span class="string">'ui_token=[generated_random_ui_token]; expires=2117-04-10T07:08:33.000Z; domain=.baidu.com'</span></div></pre></td></tr></table></figure>
<p>注意处理 <code>domain</code> 的值是 <code>.baidu.com</code>，这样可以保证在同域名下的其他二级域名中，根据 ui token 识别同一个用户，对于同一主域名下的多个站点统计，这是关键的一步。而 <code>expires</code> 字段表明了这个 cookie 在足够长的时间内不会过期。</p>
<h2 id="2-如何进行上报"><a href="#2-如何进行上报" class="headerlink" title="2 如何进行上报"></a>2 如何进行上报</h2><p>和已有的几家服务商一样，ut.js 采用了 <code>Image src</code> 的上报方式，具体代码如下（为了方便理解，做了部分修改及添加了注释）:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IP_LIST: 备用服务器的 IP 列表</span></div><div class="line"><span class="comment">// REPORT_URL: 服务器的域名地址</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// 上报数据</span></div><div class="line"><span class="comment">// @param  &#123;String&#125; logType 上报日志的类型</span></div><div class="line"><span class="comment">// @param  &#123;Object&#125; data    上报的数据内容</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">logType, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> queryArr = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</div><div class="line">      queryArr.push(<span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(data[key]));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> queryString = queryArr.join(<span class="string">'&amp;'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">var</span> uniqueId = <span class="string">"log_"</span>+ (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</div><div class="line">    <span class="keyword">var</span> image = <span class="keyword">new</span> Image(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">    <span class="built_in">window</span>[uniqueId] = image;   <span class="comment">// use global pointer to prevent unexpected GC</span></div><div class="line"></div><div class="line">    <span class="comment">// 如果使用服务器的域名地址上报失败，则随机使用一个备用 IP 列表中的服务器进行上报</span></div><div class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> ip = IP_LIST[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * IP_LIST.length)];</div><div class="line">      image.src = <span class="built_in">window</span>.location.protocol + <span class="string">'//'</span> + ip + <span class="string">'/j.gif?act='</span> + logType + <span class="string">'&amp;'</span> + queryString;</div><div class="line">      image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">window</span>[uniqueId] = <span class="literal">null</span>;  <span class="comment">// release global pointer</span></div><div class="line">      &#125;;</div><div class="line">    &#125;;</div><div class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">window</span>[uniqueId] = <span class="literal">null</span>; <span class="comment">// release global pointer</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    image.src = REPORT_URL + <span class="string">'?act='</span> + logType + <span class="string">'&amp;'</span> + queryString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过动态生成一个 <code>Image()</code> 对象的方法的好处在于不会影响用户的正常使用（完全不可知），同时省去了使用 Ajax 的各种麻烦。但为什么要将新建的 Image 对象赋值给一个 <code>window</code> 对象下的属性呢？原因是在于浏览器的垃圾回收机制会积极地回收这个 Image 对象，且回收的时机很可能在 Image 根据 src 的值发起请求之前，这就导致了上报请求并没有发出。</p>
<p>但为什么浏览器垃圾回收会如此的主动呢？这就和具体的站点情况有关：</p>
<blockquote>
<p>因为一个大脚本的运行回产生大量的“垃圾”，浏览器垃圾回收也会相应地更频繁的启动，从而造成LOG数据丢失</p>
</blockquote>
<p>具体的分析和测试可以参考百度开发童鞋的<a href="http://blog.csdn.net/fudesign2008/article/details/6772108" target="_blank" rel="noopener">这篇博客</a></p>
<h2 id="3-获取设备信息"><a href="#3-获取设备信息" class="headerlink" title="3 获取设备信息"></a>3 获取设备信息</h2><p>获取设备信息是 ut.js 的关键 - 新的设备乃至操作系统层出不穷，国内设备厂商及浏览器厂商众多，要写好一个足够好的脚本能够准确判别信息非常不易。这也是开发中的一个痛点。</p>
<p>通过 JS，我们唯一能够获取设备信息的来源就是 <code>navigator.userAgent</code>，所以这里的问题又集中到了两点：</p>
<ol>
<li>能否写出一个有效的检测方法，从 userAgent 准确地获取设备信息（包括：设备类型，型号，操作系统类型及版本，浏览器类型及版本）？</li>
<li>能否有效地建立 userAgent 库，以满足后续的测试及维护？</li>
</ol>
<p>关于第1点，鉴于这是一个非常广泛的需求，所以我们先从 browser detection 相关的第三方库入手：</p>
<ul>
<li><a href="https://github.com/ded/bowser" target="_blank" rel="noopener">ded/bowser</a></li>
<li><a href="https://github.com/3rd-Eden/useragent" target="_blank" rel="noopener">3rd-Eden/useragent</a></li>
<li><a href="https://github.com/piwik/device-detector" target="_blank" rel="noopener">piwik/device-detector</a></li>
<li><a href="https://github.com/hgoebl/mobile-detect.js/blob/master/mobile-detect.js" target="_blank" rel="noopener">mobile-detect.js</a></li>
<li><a href="https://github.com/zsxsoft/useragent.js" target="_blank" rel="noopener">zsxsoft/useragent.js</a></li>
<li><a href="https://github.com/hotoo/detector" target="_blank" rel="noopener">hotoo/detector</a></li>
</ul>
<p>经过了仔细调研之后，最后决定使用 <a href="https://github.com/hotoo/detector" target="_blank" rel="noopener">hotoo/detector</a> 有几个原因：</p>
<ol>
<li>完善的文档，测试和例子</li>
<li>由支付宝的 @闲耘 维护，大厂使用还是有一定保障（只要他们在一直用这个库，那么我们就不用担心这个库被抛弃掉的问题）</li>
<li>符合国情（并没有找到国人写的比这个更好的一个包）</li>
</ol>
<p>具体的做法就是在开发中引入对 <code>detector</code> 的依赖（代码有部分改动，便于阅读）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> detector = <span class="built_in">require</span>(<span class="string">'detector'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOS</span>(<span class="params">ua</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> os = detector.parse(ua).os;</div><div class="line">  <span class="keyword">var</span> osName = os.name;</div><div class="line">  <span class="keyword">var</span> osVer = os.fullVersion;</div><div class="line"></div><div class="line">  <span class="comment">//========================</span></div><div class="line">  <span class="comment">// 特定的一些自定义处理</span></div><div class="line">  <span class="comment">// 修改格式, 补充遗漏部分等</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">//========================</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> osName + <span class="string">'|'</span> + osVer;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBrowser</span>(<span class="params">ua</span>) </span>&#123;</div><div class="line">  <span class="comment">//========================</span></div><div class="line">  <span class="comment">// 对 ua 进行预处理，识别具有明显特征但不在 detector 检测范围内的浏览器 vendor</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">//========================</span></div><div class="line"></div><div class="line">  <span class="keyword">var</span> bs = detector.parse(ua).browser;</div><div class="line">  <span class="keyword">var</span> bsName = bs.name;</div><div class="line">  <span class="keyword">var</span> bsVersion = bs.fullVersion;</div><div class="line"></div><div class="line">  <span class="comment">//========================</span></div><div class="line">  <span class="comment">// 特定的一些自定义处理</span></div><div class="line">  <span class="comment">// 修改格式, 补充遗漏部分等</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="comment">//========================</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> bsName + <span class="string">'|'</span> + bsVer;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 对设备类型的检测类似，不赘述</span></div></pre></td></tr></table></figure>
<p>关于第2点，我们在后续的系列文章中再详述。</p>
<h2 id="4-获取用户点击信息"><a href="#4-获取用户点击信息" class="headerlink" title="4 获取用户点击信息"></a>4 获取用户点击信息</h2><p>为了后续获取数据的方便，以及了解用户在页面上的点击分布，ut.js 监听了用户点击的事件，以获取相应的信息。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// addEvent - 包装了 attachEvent 和 addEventListener 的监听事件函数</span></div><div class="line"><span class="comment">// isLink - 判断某个 DOM 元素是否为 &lt;a&gt; 元素</span></div><div class="line"><span class="comment">// data - 储存用户信息的对象</span></div><div class="line"><span class="comment">// data.ot - 用户离开页面时点击的目标 url</span></div><div class="line"><span class="comment">// data.xy - 用户最后一次点击时的坐标地址</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureLink</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> elem = e.target || e.srcElement;</div><div class="line">  <span class="keyword">if</span> (isLink(elem)) &#123;</div><div class="line">    data.ot = elem.href;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// update the x,y of the last link click</span></div><div class="line">  data.xy = e.clientX + <span class="string">','</span> + e.clientY;</div><div class="line">&#125;</div><div class="line"></div><div class="line">addEvent(<span class="built_in">document</span>, <span class="string">'click'</span>, captureLink, <span class="literal">true</span>);</div></pre></td></tr></table></figure>
<p>在下篇中，我们会集中讨论如何获取 <strong>页面停留时间</strong> 这个复杂的问题，以及其他一些技术实现的要点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站统计系列的第二篇。一箩筐辣鸡代码和絮絮叨叨。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
      <category term="User Tracking" scheme="http://afantasy.ninja/tags/User-Tracking/"/>
    
  </entry>
  
  <entry>
    <title>网站统计那些事（一）：背景与基础概念</title>
    <link href="http://afantasy.ninja/2017/05/08/user-tracking-i/"/>
    <id>http://afantasy.ninja/2017/05/08/user-tracking-i/</id>
    <published>2017-05-08T06:00:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>网站统计系列的第一篇。没有代码的湿货。<br><a id="more"></a></p>
<p>在去年的3-6月，我和另一位同事负责对公司各 Web 站点所使用的统计脚本及管理后台进行改造；本文算作是对这个工程的一个系统的总结。</p>
<p>内容很多，这一篇会先着重讲网站统计的需求背景以及一些基本概念。</p>
<p>传送门：</p>
<ul>
<li><a href="../user-tracking-ii">网站统计那些事（二）：统计脚本实现（上）</a></li>
<li><a href="../user-tracking-iii">网站统计那些事（三）：统计脚本实现（下）</a></li>
<li><a href="../user-tracking-iv">网站统计那些事（四）：工程化，模块化与测试</a></li>
</ul>
<h2 id="网站统计的目的"><a href="#网站统计的目的" class="headerlink" title="网站统计的目的"></a>网站统计的目的</h2><p>关于网站的数据统计，市面上已有 Google Analytics，百度统计，友盟等第三方服务商提供相应的服务。之所以需要自己重新做一个，是出于公司内部的一些定制的需求和指标上的差异。</p>
<p>虽然标题写的是 “网站统计”，但实际上我们所编写的统计脚本，其目标对象应该是所有 Web 的网页，可以是传统的网站站点，也可以是嵌套在 Webview 中的网页，甚至是小程序，以及任何可以自由加载外来 JS 脚本的页面。但为了理解方便，下文中我将使用 “网站统计” 来代指这类统计的需求或内容。</p>
<p>对于网站/网页的运营者来说，通过网站数据他们希望得知的信息有：</p>
<ol>
<li>了解网站/网页的热度（哪个页面访问量大，哪个页面访问量小，页面访问量随着时间的变化）</li>
<li>对访客进行分析（访客的地域分布，使用的设备等）</li>
<li>监控网站自身变化对访客产生的影响<ul>
<li>上线新的版面（观察上线动作前后的数据差异）</li>
<li>对某种功能特性进行 A/B Testing（对两种策略的数据对比）</li>
<li>bla…</li>
</ul>
</li>
<li>访客在页面上的行为（点击，高亮等等）</li>
</ol>
<p>一言蔽之，网站统计的目的就是 <strong><em>为网站运营和开发者提供数据参考</em></strong>。</p>
<h2 id="网站统计如何工作？"><a href="#网站统计如何工作？" class="headerlink" title="网站统计如何工作？"></a>网站统计如何工作？</h2><p><img src="/images/web-stat-process.png" alt=""></p>
<p>上图简要的说明了网站统计过程中的四个步骤：上报（log），数据处理（process），数据存储（store）和数据展示（display）。</p>
<p>首先，我们向业务方提供一份可搜集用户信息并发起上报的 JS 脚本。各个业务方在其产品（网站，移动 App 内嵌的 Webview 页面等）中使用该 JS 脚本。</p>
<p>我们采用了服务器集群来对上报请求进行负载均衡，所收集到的上报请求均以 <strong>日志文件</strong> 的形式储存在集群各机器中。</p>
<p>在数据处理阶段，我们采用定时的 Hive 任务读取各服务器上的日志，进行计算后写入到业务层的 MySQL 中，最终再由 MySQL 向 Web 后台站点提供数据，显示可视化报表。</p>
<p>那么 作为网站运营者所关心的指标又是什么？JS 脚本是如何向服务器发起上报的？具体上报的内容是什么？</p>
<p>我们先来回答第一个问题。这要从网站统计的基本概念开始谈起。</p>
<h2 id="网站统计的基本概念：PV-UV-和-IP"><a href="#网站统计的基本概念：PV-UV-和-IP" class="headerlink" title="网站统计的基本概念：PV, UV 和 IP"></a>网站统计的基本概念：PV, UV 和 IP</h2><p>在整个网站统计中，PV, UV 和 IP 是最核心的三个基本指标。</p>
<h4 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h4><p>PV 顾名思义，是某个网页被访问的次数，<a href="https://en.wikipedia.org/wiki/Page_view" target="_blank" rel="noopener">维基百科</a> 的定义如下：</p>
<blockquote>
<p>A page view (PV) or page impression is a request to load a single HTML file (web page) of an Internet site.</p>
</blockquote>
<p><a href="https://support.google.com/analytics/answer/6086080?hl=en" target="_blank" rel="noopener">Google Analytics</a> 的定义如下：</p>
<blockquote>
<p>An instance of a page being loaded (or reloaded) in a browser. Pageviews is a metric defined as the total number of pages viewed.</p>
</blockquote>
<p><a href="http://tongji.baidu.com/web/help/article?id=253&amp;type=0" target="_blank" rel="noopener">百度统计</a> 对 PV 的定义：</p>
<blockquote>
<p>即通常说的Page View(pv)，用户每打开一个网站页面就被记录1次。用户多次打开同一页面，浏览量值累计。</p>
</blockquote>
<p>从维基百科的定义，可以理解为 PV 是 <strong>某个网页的 url 被请求的次数</strong>；GA 认为这个指标和 <code>loaded</code> 有关 —— 也就是说 <strong>前提条件是页面的加载完成</strong>；百度统计的描述其实非常模糊，并没有声明 “打开一个网站界面” 的关键步骤（时间点）究竟是什么。</p>
<p>如果从直观的效果来讲，个人认为应该等到用户访问的页面完成加载了之后（也就是用户已经看到了页面）再视作一次 PV，可能会更加准确一些。</p>
<p>不过从百度统计的代码上看，其代码的主函数是在 <code>DOMContentLoaded</code> 或 <code>onload</code> 事件（使用两个事件的原因是处于兼容性考虑）触发的回调函数中被唤起的，也就是说其上报策略是在用户看到页面加载的内容后才进行上报。</p>
<h4 id="UV-独立访客数"><a href="#UV-独立访客数" class="headerlink" title="UV - 独立访客数"></a>UV - 独立访客数</h4><p>在查阅 GA 相应文档时，我并没有找到对应 UV 的说法，比较接近的 <a href="https://support.google.com/analytics/answer/3123669" target="_blank" rel="noopener">User-ID Views</a> 是针对已登录用户在含用户系统的站点中的用户访问情况。</p>
<p><a href="http://tongji.baidu.com/web/help/article?id=253&amp;type=0" target="_blank" rel="noopener">百度统计中的定义</a>:</p>
<blockquote>
<p>一天之内您网站的独立访客数(以Cookie为依据)，一天内同一访客多次访问您网站只计算1个访客(uv)。</p>
</blockquote>
<p>这里所提到的 “独立访客数”, 在技术实现上通常是由 JS SDK 生成一个唯一的 ui token 作为用户标识。所以 UV 数据的本质是将一定时间内的用户访问记录，根据 Cookie 所得的 ui token 来进行去重所得到的值，这个值是以 <strong>单个设备上的浏览器</strong> 为准的。</p>
<p>用 PV 数除以 UV 数得到的比值 PV/UV，可以较模糊地反映单个用户对某个页面的黏度。</p>
<h4 id="IP-独立-IP-数"><a href="#IP-独立-IP-数" class="headerlink" title="IP - 独立 IP 数"></a>IP - 独立 IP 数</h4><p>根据访问站点的 IP 对 PV 数据进行去重后得到的数据。从目前的情况来看，所起到的作用是从宏观上让我们对页面的分布广度有一个模糊的了解。</p>
<h4 id="核心指标的计算意义"><a href="#核心指标的计算意义" class="headerlink" title="核心指标的计算意义"></a>核心指标的计算意义</h4><p>值得一提的是，PV/UV/IP 这三个指标，必须要对限定时间内的所有数据进行计算才有意义，比如计算 “2017.5.1-2017.5.7” 的 UV，必须要将这7天的所有访问记录根据 ui token 来进行去重，所得到的数据才是有效的，不能够单纯的将 2017.5.1-2017.5.7 这7天的 UV 进行相加。</p>
<h2 id="运营人员关心的指标"><a href="#运营人员关心的指标" class="headerlink" title="运营人员关心的指标"></a>运营人员关心的指标</h2><p>读者应该能够意识到，其实 PV/UV/IP 的计算其实只需要在上报时带上 ui token 的参数，在服务端就可以根据日志计算出来。通过分析这三个指标，我们已经可以了解网站整体的流量大小。</p>
<p>但我们还需要了解网站用户的构成，以及在不同条件下网站流量的变化和分布，具体包括：</p>
<ol>
<li>网站流量关于时间的分布</li>
<li>网站用户在不同维度下的构成状况，维度包括：<ul>
<li>所在位置（地域分布）</li>
<li>PC端 / 移动端</li>
<li>浏览器</li>
<li>操作系统</li>
<li>手机型号</li>
<li>…</li>
</ul>
</li>
</ol>
<p>其中最核心的是关于时间的分布 - 网站运营者需要了解在一定时间内核心指标的变动，特别是在网站改版或者是进行运营活动的前后。这也是后台数据展示的最基本形式。</p>
<p>而观察用户在不同维度的构成状况，本质上就是计算在某些条件下某个时间点或时间段下的网站流量，如：</p>
<blockquote>
<p>计算2017年5月份广州市使用移动端站点的安卓用户数量变化。</p>
</blockquote>
<p>这就要求我们能够了解每条上报的日志所关联的用户访问的设备信息以及所处地域。所以统计脚本在上报之前，还需要搜集用户请求相关的信息。这一点我们在下一篇博客中会详细讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网站统计系列的第一篇。没有代码的湿货。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
      <category term="User Tracking" scheme="http://afantasy.ninja/tags/User-Tracking/"/>
    
  </entry>
  
  <entry>
    <title>JS Promise Note</title>
    <link href="http://afantasy.ninja/2017/04/20/js-promise-note/"/>
    <id>http://afantasy.ninja/2017/04/20/js-promise-note/</id>
    <published>2017-04-20T09:50:00.000Z</published>
    <updated>2018-05-08T16:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直对 Promise 这个概念感到迷迷糊糊，实在是受不了了，决定系统的过一次相关的知识点。<br><a id="more"></a></p>
<p>以下笔记主要基于著名的 <a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">JavaScript 迷你书(中文版)</a>，感谢原作者 @azu 和翻译者 @liubin!</p>
<p>本文将不定期陆续更新。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>Constructor</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">	<span class="comment">// async processing...</span></div><div class="line">	<span class="comment">// call resolve / reject when done</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>Instance Method</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div><div class="line"><span class="comment">// OR</span></div><div class="line">promise.then(onFulfilled).catch(onRejected)</div></pre></td></tr></table></figure>
<p><strong>Static Method</strong></p>
<p><code>Promise.all()</code>, <code>Promise.resolve()</code>, <code>Promise.reject()</code></p>
<h2 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h2><p>Promise 有三种状态：<code>has-resolution/Fulfilled</code>, <code>has-rejection/Rejected</code>, <code>unresolved/Pending</code></p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><strong><code>Promise.resolve()</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 快速新建一个 Promise 对象, 并第一时间调用 then 方法</span></div><div class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 将 Thenable 转换为 Promise 对象</span></div><div class="line"><span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/json/comment.json'</span>)).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>同理，<strong><code>Promise.reject()</code></strong> 会第一时间返回一个 promise 对象（如果有调用 <code>.catch(onReject)</code> 则会在下一 tick 中执行 <code>onReject</code></p>
<h3 id="使用-Promise-确保异步流程"><a href="#使用-Promise-确保异步流程" class="headerlink" title="使用 Promise 确保异步流程"></a>使用 Promise 确保异步流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReadyPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> readyState = <span class="built_in">document</span>.readyState</div><div class="line">    <span class="keyword">if</span> (readyState === <span class="string">'interactive'</span> || readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">      resolve()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, resolve)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">onReadyPromise().then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM fully loaded and parsed'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'==Starting=='</span>)</div></pre></td></tr></table></figure>
<h3 id="Promise-Chain"><a href="#Promise-Chain" class="headerlink" title="Promise Chain"></a>Promise Chain</h3><p><code>.then</code> 和 <code>.catch</code> 方法可以进行链式调用，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve()</div><div class="line">promise</div><div class="line">	.then(taskA)</div><div class="line">	.then(taskB)</div><div class="line">	.catch(onRejected)</div><div class="line">	.then(finalTask)</div></pre></td></tr></table></figure>
<p>在这个链式调用中，taskA 和 taskB 可以通过两种方式使执行流程经过 onRejected 函数：</p>
<ol>
<li>抛出一个异常</li>
<li>返回一个 <code>rejected</code> 状态的 Promise 对象（推荐使用这个方法）</li>
</ol>
<p>使用第二种方法的理由：</p>
<ol>
<li>更加直观，因为 <code>.catch</code> 方法本来的含义就是在 Promise 对象状态变为 <code>rejected</code> 时执行的回调。</li>
<li>避免 <code>throw</code> 关键字造成的副作用（影响 debug 等）</li>
</ol>
<p>在 <code>then</code> 中注册的回调函数可以通过 <code>return</code> 返回一个值，这个返回值会传给后续的 <code>then</code> 或者 <code>catch</code> 的回调函数</p>
<p>但 <code>then</code> 的结果总是一个新创建的 promise 对象。如果 <code>then</code> 中注册的回调函数的返回值就是一个 Promise 对象，则 <code>then</code> 的结果就是这个对象。</p>
<p>所以我们可以在 <code>then</code> 中返回一个带 <code>reject</code> 状态的 Promise 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> onRejected = <span class="built_in">console</span>.error.bind(<span class="built_in">console</span>)</div><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve()</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'this promise is rejected'</span>))</div><div class="line">&#125;).catch(onRejected)</div></pre></td></tr></table></figure>
<h4 id="Anti-pattern-对同一个对象同时调用-then-方法"><a href="#Anti-pattern-对同一个对象同时调用-then-方法" class="headerlink" title="Anti-pattern: 对同一个对象同时调用 then 方法"></a>Anti-pattern: 对同一个对象同时调用 then 方法</h4><p>显然这样的处理是不能得到预想中的结果的，必须修改成使用 Promise Chain 的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"1: "</span> + value); <span class="comment">// =&gt; 100</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="处理-IE8-下-catch-保留字的问题"><a href="#处理-IE8-下-catch-保留字的问题" class="headerlink" title="处理 IE8 下 catch 保留字的问题"></a>处理 IE8 下 <code>catch</code> 保留字的问题</h3><blockquote>
<p>在ECMAScript 3中保留字是不能作为对象的属性名使用的。而IE8及以下版本都是基于ECMAScript 3实现的，因此不能将 catch 作为属性来使用，也就不能编写类似 promise.catch() 的代码，因此就出现了 identifier not found 这种语法错误了。</p>
</blockquote>
<p><strong>解决方案</strong>: 使用 <code>then</code> 而不使用 <code>catch</code>；如果一定要使用 <code>catch</code> 的话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'message'</span>))</div><div class="line">promise[<span class="string">'catch'</span>](<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><code>Promise.all()</code></h3><p>Promise.all 接收 Promise 对象组成的数组作为参数，两个 promise 对象的初始化会同时进行，当所有的 promise 对象的状态转变为 <code>fulfilled</code> 或者 <code>rejected</code> 之后才会处理 Promise Chain 上的 then 函数，且得到的执行结果的顺序与原 promise 数组的顺序一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerPromisefy</span>(<span class="params">delay</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      resolve(delay)</div><div class="line">    &#125;, delay)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> startDate = <span class="built_in">Date</span>.now()</div><div class="line"></div><div class="line"><span class="comment">// 所有 promise 变为 resolve 后程序退出</span></div><div class="line"><span class="built_in">Promise</span>.all([</div><div class="line">  timerPromisefy(<span class="number">1</span>),</div><div class="line">  timerPromisefy(<span class="number">32</span>),</div><div class="line">  timerPromisefy(<span class="number">64</span>),</div><div class="line">  timerPromisefy(<span class="number">128</span>),</div><div class="line">]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - startDate + <span class="string">'ms'</span>) <span class="comment">// ~128ms</span></div><div class="line">  <span class="built_in">console</span>.log(values) <span class="comment">// [1,32,64,128]</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h3><p><code>race()</code> 方法和 <code>all()</code> 类似，接收一个 promise 对象数组为参数，但区别在于：</p>
<blockquote>
<p>Promise.race 只要有一个 Promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p>
</blockquote>
<p>但 race 胜出的 Promise 对象不会阻止其他 Promise 对象的执行。</p>
<h3 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a><code>.catch()</code></h3><p>最好的理解方法就是将 catch 方法当做是 <code>promise.then(undefined, onRejected)</code>，它们在本质上没有区别。</p>
<h2 id="Test-Promise"><a href="#Test-Promise" class="headerlink" title="Test Promise"></a>Test Promise</h2><ul>
<li>使用 Mocha 对 Promise 进行测试</li>
<li>在 <code>it()</code> 中直接返回 Promise 对象，则不需要使用 <code>done</code></li>
<li>测试 Promise 对象时，应该覆盖 Promise 对象的两种状态（Fulfilled, Rejected），同时检查两种状态时的返回值。满足这样条件的测试叫做可控测试（controllable tests）</li>
</ul>
<p>定义一个叫做 <code>shouldRejected</code> 的函数，用于测试期待返回状态为 <code>onRejected</code> 的 Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldRejected</span> (<span class="params">promise</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">  	<span class="keyword">catch</span> () &#123;</div><div class="line">  	  <span class="keyword">return</span> promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  	    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected promise to be rejected but it was fulfilled'</span>)</div><div class="line">  	  &#125;, (reason) =&gt; &#123;</div><div class="line">  	    fn.call(promise, reason)</div><div class="line">  	  &#125;)</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">it(<span class="string">'should be rejected'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'human error'</span>)</div><div class="line">  <span class="keyword">return</span> showRejected(promise).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</div><div class="line">    assert(error.message === <span class="string">'human error'</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>同理可以写一个 <code>shouldFulfilled</code> 的 helper…</p>
<h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h2><p>一些实现了 Promise 的第三方类库：</p>
<h4 id="Polyfills"><a href="#Polyfills" class="headerlink" title="Polyfills"></a>Polyfills</h4><ul>
<li><a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="noopener">stefanpenner/es6-promise</a></li>
<li><a href="https://github.com/getify/native-promise-only/" target="_blank" rel="noopener">getify/native-promise-only</a></li>
</ul>
<h4 id="Promise-Extensions"><a href="#Promise-Extensions" class="headerlink" title="Promise Extensions"></a>Promise Extensions</h4><ul>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">kriskowal/q</a></li>
<li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener">petkaantonov/bluebird</a></li>
</ul>
<h3 id="Thenable"><a href="#Thenable" class="headerlink" title="Thenable"></a>Thenable</h3><ul>
<li>Thenable 就是一个具有 <code>.then()</code> 方法的一个对象。</li>
<li>通过 <code>Promise.resolve()</code> 可以将一个 Thenable 对象转换为一个标准的 Promise 对象</li>
<li>很多第三方库提供了将 Thenable 对象转换为其实现的 Promise 对象的途径。所以在内部使用 Thenable，便于在不同的 Promise 类库之间进行相互转换。</li>
</ul>
<p>实现一个 Thenable 对象非常简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">	then (resolve, reject) =&gt; &#123;</div><div class="line">		<span class="comment">// call resolve when everything is okay</span></div><div class="line"></div><div class="line">		<span class="comment">// call reject when things go wrong</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Deferred-amp-Promise"><a href="#Deferred-amp-Promise" class="headerlink" title="Deferred &amp; Promise"></a>Deferred &amp; Promise</h3><h4 id="Deferred-和-Promise-的关系"><a href="#Deferred-和-Promise-的关系" class="headerlink" title="Deferred 和 Promise 的关系"></a>Deferred 和 Promise 的关系</h4><p><img src="http://liubin.org/promises-book/Ch4_AdvancedPromises/img/deferred-and-promise.png" alt=""></p>
<ul>
<li>Deferred 拥有 Promise</li>
<li>Deferred 具备对 Promise 状态进行操作的特权方法</li>
</ul>
<h4 id="使用-Promise-实现-Deferred"><a href="#使用-Promise-实现-Deferred" class="headerlink" title="使用 Promise 实现 Deferred"></a>使用 Promise 实现 Deferred</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// using ES5 style</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deferred</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>._resolve = resolve</div><div class="line">		<span class="keyword">this</span>._reject = reject</div><div class="line">	&#125;.bind(<span class="keyword">this</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>._resolve.call(<span class="keyword">this</span>.promise, value)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>._reject.call(<span class="keyword">this</span>.promise, reason)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现一个 getURL 函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</div><div class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</div><div class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</div><div class="line">            deferred.resolve(req.responseText);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">    &#125;;</div><div class="line">    req.send();</div><div class="line">    <span class="keyword">return</span> deferred.promise;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 运行实例</span></div><div class="line"><span class="keyword">var</span> URL = <span class="string">"http://httpbin.org/get"</span>;</div><div class="line">getURL(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).catch(<span class="built_in">console</span>.error.bind(<span class="built_in">console</span>));</div></pre></td></tr></table></figure>
<p>这样写的好处有：</p>
<ul>
<li>减少一层缩进</li>
<li>不需要一开始就将处理流程写成一大段代码，只需要先创建 deferred 对象，在任何时机调用 <code>resolve</code>, <code>reject</code> 方法。</li>
</ul>
<blockquote>
<p>如果说Promise是用来对值进行抽象的话，Deferred则是对处理还没有结束的状态或操作进行抽象化的对象，我们也可以从这一层的区别来理解一下这两者之间的差异。</p>
<p>换句话说，Promise代表了一个对象，这个对象的状态现在还不确定，但是未来一个时间点它的状态要么变为正常值（FulFilled），要么变为异常值（Rejected）；而Deferred对象表示了一个处理还没有结束的这种事实，在它的处理结束的时候，可以通过Promise来取得处理结果。</p>
</blockquote>
<h3 id="实现超时机制-Promise-race"><a href="#实现超时机制-Promise-race" class="headerlink" title="实现超时机制: Promise.race()"></a>实现超时机制: <code>Promise.race()</code></h3><p>以下这段代码实现了一个简单的超时函数，当目标 Promise 中的任务在超过 ms 后未执行完（状态未变更），则由和其竞争的 <code>timeout</code> promise 抛出一个异常，从而调起后续 Promise Chain 中的 catch 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayPromise</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">        setTimeout(resolve, ms);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">promise, ms</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    	<span class="comment">// 也可以用 reject</span></div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Operation timed out after '</span> + ms + <span class="string">' ms'</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise, timeout]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 运行示例</span></div><div class="line"><span class="keyword">var</span> taskPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</div><div class="line">    <span class="comment">// 随便一些什么处理</span></div><div class="line">    <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">2000</span>;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        resolve(delay + <span class="string">"ms"</span>);</div><div class="line">    &#125;, delay);</div><div class="line">&#125;);</div><div class="line">timeoutPromise(taskPromise, <span class="number">1000</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"taskPromise在规定时间内结束 : "</span> + value);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"发生超时"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不过这里还有一个问题，就是如果业务 promise 在执行过程中出现了问题，抛出一个错误（或者调用 reject），那么在 Promise Chain 后续的 catch 函数中，其实我们无法分辨到底是系统超时了还是业务 promise 出现了问题。当然，检查 <code>error.msg</code> 具体的字符串值是可以勉强做到的，但这样的实现非常的不美观。</p>
<p>一种理想的方案是自定义一个 <code>TimeoutError</code> 类型的对象，通过检查 <code>error instanceof TimeoutError</code> 来判断捕获到的错误是否为一个超时错误。</p>
<p>使用 ES6 规范里面的 <code>class</code>, <code>extend</code> 自然是轻轻松松，但也无妨看下在 ES5 下的实现方案。</p>
<h4 id="插播：创建一个继承-Error-的类-TimeoutError"><a href="#插播：创建一个继承-Error-的类-TimeoutError" class="headerlink" title="插播：创建一个继承 Error 的类 TimeoutError"></a>插播：创建一个继承 Error 的类 TimeoutError</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TimeoutError.js</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnFrom</span> (<span class="params">target, source</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.getOwnPropertyNames(source).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">propName</span>) </span>&#123;</div><div class="line">        <span class="built_in">Object</span>.defineProperty(target, propName, <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propName));</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeoutError</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> superInstance = <span class="built_in">Error</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">    copyOwnFrom(<span class="keyword">this</span>, superInstance);</div><div class="line">&#125;</div><div class="line">TimeoutError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</div><div class="line">TimeoutError.prototype.constructor = TimeoutError;</div></pre></td></tr></table></figure>
<p>另一种思路，来源于 CoffeeScript 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> __hasProp = &#123;&#125;.hasOwnProperty</div><div class="line"><span class="keyword">var</span> __extends = <span class="function"><span class="keyword">function</span> (<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">	<span class="comment">// 复制构造器上的属性</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> Parent) &#123;</div><div class="line">		<span class="keyword">if</span> (__hasProp.call(Parent, key)) Child[key] = Parent[key]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 构建原型链</span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">ctor</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = Child &#125;</div><div class="line">	ctor.prototype = Parent.prototype</div><div class="line">	Child.prototype = <span class="keyword">new</span> ctor()</div><div class="line"></div><div class="line">	Child.__super__ = Parent.prototype</div><div class="line"></div><div class="line">	<span class="keyword">return</span> Child</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> TimeoutError = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">TimeoutError</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		_super.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	__extends(TimeoutError, _super)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> TimeoutError</div><div class="line">&#125;)(<span class="built_in">Error</span>)</div></pre></td></tr></table></figure>
<p>在实现了简单的超时之后，我们希望能够在 XHR 超时后取消其请求操作（以免阻塞后面可能的 XHR 请求），需要用到 <code>xhr.abort()</code> 方法。</p>
<p>对上一节中实现的 <code>getURL</code> 函数稍加改进，改成返回一个带 promise 和 abort 方法的对象，配合 <code>timeoutPromise</code> 方法就可以完成整个业务逻辑。</p>
<h3 id="Promise-prototype-done"><a href="#Promise-prototype-done" class="headerlink" title="Promise.prototype.done"></a><code>Promise.prototype.done</code></h3><blockquote>
<p>如果你使用过其他的 Promise 实现类库的话，可能见过用 done 代替 then 的例子。</p>
<p>这些类库都提供了 Promise.prototype.done 方法，使用起来也和 then 一样，但是这个方法并不会返回 Promise 对象。</p>
<p>虽然 ES6 Promises 和 Promises/A+ 等在设计上并没有对 Promise.prototype.done 做出任何规定，但是很多实现类库都提供了该方法的实现。</p>
</blockquote>
<ul>
<li><code>done</code> 不返回 Promise 对象</li>
<li><code>done</code> 发生的异常会直接抛到外面</li>
</ul>
<p><strong>在开发中，如果忘记编写 catch 函数处理 Promise Chain 中运行时错误，那么这些错误会被 “内部消化”，而不会被外部所得知，这样就给 debug 造成了巨大的困难。使用 done 的意义在于避免这样的情况。</strong></p>
<p><strong>在 setTimeout 中抛出一个异常并不会被捕获!!!</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个 error 不会被捕获</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">    <span class="built_in">console</span>.error(error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Promise-amp-method-chain"><a href="#Promise-amp-method-chain" class="headerlink" title="Promise &amp; method chain"></a>Promise &amp; method chain</h3><p>TODO</p>
<h3 id="Promise-amp-sequence"><a href="#Promise-amp-sequence" class="headerlink" title="Promise &amp; sequence"></a>Promise &amp; sequence</h3><p>TODO</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">JavaScript Promise 迷你书</a></li>
</ul>
<hr>
<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-promise-objects" target="_blank" rel="noopener">Promise Objects - ECMAScript Language Specification</a></li>
<li><a href="https://www.w3.org/2001/tag/doc/promises-guide" target="_blank" rel="noopener">Writing Promise - Using Specifications // W3C</a></li>
<li><a href="https://speakerdeck.com/kerrick/javascript-promises-thinking-sync-in-an-async-world" target="_blank" rel="noopener">JavaScript Promises - Thinking Sync in an Async World // Speaker Deck</a></li>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises" target="_blank" rel="noopener">JavaScript Promise // Google Web Developer</a></li>
<li><a href="https://blog.domenic.me/youre-missing-the-point-of-promises/" target="_blank" rel="noopener">You’re Missing the Point of Promises</a></li>
<li><a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="noopener">es6-promise: A polyfill for ES6-style Promises</a></li>
<li><a href="http://taoofcode.net/promise-anti-patterns/" target="_blank" rel="noopener">Promise Anti-patterns</a></li>
<li><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a></li>
<li><a href="https://blog.domenic.me/youre-missing-the-point-of-promises/" target="_blank" rel="noopener">You’re Missing the Point of Promises</a></li>
<li><a href="http://www.infoq.com/cn/news/2011/09/js-promise" target="_blank" rel="noopener">JavaScript 异步编程的 Promise 模式</a></li>
</ul>
<h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><ul>
<li><a href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-semantics" target="_blank" rel="noopener">Promise &amp; Deferred objects in JavaScript Pt.1: Theory and Semantics.</a></li>
<li><a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="noopener">The Deferred Anti-Pattern // petkaantonov/bluebird Wiki</a></li>
<li><a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery" target="_blank" rel="noopener">Coming from jQuery // kriskowal/q Wiki</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直对 Promise 这个概念感到迷迷糊糊，实在是受不了了，决定系统的过一次相关的知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://afantasy.ninja/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>「译」- Drupal 7 中 Video 模块的使用</title>
    <link href="http://afantasy.ninja/2016/02/14/video-module-usage-in-drupal-7/"/>
    <id>http://afantasy.ninja/2016/02/14/video-module-usage-in-drupal-7/</id>
    <published>2016-02-14T11:44:00.000Z</published>
    <updated>2016-02-14T12:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>注1：本文翻译自 Drupal 官网中 Video 模块的文档，并做部分删改，仅供参考。</p>
<p>注2：本文要求读者具备基本的 Drupal 7 知识，如基本架构，模块使用等。</p>
<p>原文:</p>
<ul>
<li><a href="https://www.drupal.org/node/2281571" target="_blank" rel="noopener">Installing and Configuring the Video Module - Drupal 7</a></li>
<li><a href="https://www.drupal.org/documentation/modules/video" target="_blank" rel="noopener">Video: transcoding and playback</a></li>
</ul>
<h3 id="关于-Video-模块"><a href="#关于-Video-模块" class="headerlink" title="关于 Video 模块"></a>关于 Video 模块</h3><p>Video 模块可以将几乎任何视频格式文件 “转码” 为 H.246, Theora, VP8（以及其他众多格式）。它使用 <a href="https://zencoder.com/" target="_blank" rel="noopener">Zencoder</a> 转码云服务或者 <a href="http://ffmpeg.org/" target="_blank" rel="noopener">FFMPEG</a> 这个开源项目（需要运行在你的服务器上）。网站建设者可以通过一个 video 字段将视频上传到节点（nodes）中（video 字段是 Video 模块中自带的），就和文件字段一样。当视频完成转码后，Video 模块将自动为视频创建缩略图，并且将一个视频播放器嵌入到视图层中。Video 模块是高度可配置的，还可以集成到 AWS S3 云存储服务中。</p>
<h3 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h3><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><ul>
<li><p>系统中必须要安装 <strong>Curl</strong>，并且可以通过 PHP 调用。在 phpinfo() 中查看 Curl 的选项，或者在 linux 命令行下执行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ php -i | grep <span class="string">"curl"</span></div></pre></td></tr></table></figure>
<p>如果你看到有输出信息，那么说明配置好了。</p>
</li>
<li>FFMPEG 在 Windows 下只支持有限的 codec，需要做额外的安装配置。</li>
</ul>
<h4 id="依赖的模块"><a href="#依赖的模块" class="headerlink" title="依赖的模块"></a>依赖的模块</h4><ul>
<li><a href="https://drupal.org/project/libraries" target="_blank" rel="noopener">Libraries</a></li>
</ul>
<h4 id="转码器（transcoder）"><a href="#转码器（transcoder）" class="headerlink" title="转码器（transcoder）"></a>转码器（transcoder）</h4><p>Video 模块兼容 FFMPEG 和 Zencoder。根据你选择的转码器你需要做以下配置（必须选择其中一个）：</p>
<ul>
<li><strong>Zencoder</strong><ol>
<li>从 Github 中下载 <a href="https://github.com/zencoder/zencoder-php" target="_blank" rel="noopener">zencoder-php 库</a></li>
<li>将这个库放置到 <em>sites/all/libaries</em> 中</li>
</ol>
</li>
<li><strong>FFMPEG</strong> - 根据你使用的平台下载并安装 FFMPEG（根据平台的不同，下载 FFMPEG 的方式也不同）。<strong>请自行搜索在不同平台下安装的方法。</strong></li>
</ul>
<p>FFMPEG 和 Zencoder 有什么区别么?</p>
<p><strong>FFMPEG</strong> 必须安装在你的服务器上，它的安装会有些复杂。但一旦安装配置好后，FFMPEG 不需要任何额外的花销。但是，视频转码是一个 CPU 密集的操作，所以 FFMPEG 在高流量的单点服务器上，可能不是一个很好的解决方案。同时，在上传的视频文件体积较大或者网站接受大量视频文件时，也不大适合使用 FFMPEG。在以下情况下使用 FFMPEG 比较合适：</p>
<ol>
<li>网站上传视频的频率不高，且视频比较短；</li>
<li>你（开发人员）有时间来研究如何安装编译配置 FFMPEG，但没有钱（购买服务）；</li>
<li>你的服务器能够承载大量的 CPU 计算；</li>
<li>网站的流量不高。</li>
</ol>
<p><strong>Zencoder</strong> 是一个速度快的云转码服务。它可以接受高流量的大视频文件上传且不会让你的服务器变慢。尽管 Zencoder 是一个商业服务（收费），它提供免费的试用账号，该账号由 Video 模块为你轻松建立。使用 Zencoder 的两个不足是你需要为使用服务来付费，同时目前在没有 IP 地址的情况下难以测试 Zencoder。例如，在本地开发时很难测试 Zencoder。在以下情形下你可以考虑使用 Zencoder：</p>
<ol>
<li>你的资金能够负担视频服务的费用，但（开发人员）没有时间来研究 FFMPEG；</li>
<li>你的服务器（网站）需要承受高流量；</li>
<li>你允许网站访问者自由地上传视频到你的网站中；</li>
<li>你希望网站接受大视频上传；</li>
<li>你希望在某一天能在云上存储不限量的视频。</li>
</ol>
<h4 id="配置-Video-模块"><a href="#配置-Video-模块" class="headerlink" title="配置 Video 模块"></a>配置 Video 模块</h4><p>Video 模块包含3个单独的子模块：Video, Video UI 和 Zencoder</p>
<p>配置方法如下：</p>
<ol>
<li>在 <em>admin/modules</em> 中启用 Video 和 Video UI 两个模块</li>
<li>如果使用 Zencoder:<ol>
<li>启用 Zencoder 模块</li>
<li>进入 <em>admin/config/media/video/transcoders</em> 页面</li>
<li>在 Video transcoder 的选项中，选择 Zencoder</li>
<li>输入你的邮箱账号，以获得一个 Zencoder 的试用账号（trial）</li>
<li>保存配置</li>
<li>稍等一会儿，你的账号将被建立，并自动保存到你的 Video 模块信息中。</li>
</ol>
</li>
<li>如果使用 FFMPEG<ol>
<li>在服务器上安装 FFMPEG。具体操作详见 FFMPEG 的 <a href="https://www.ffmpeg.org/download.html" target="_blank" rel="noopener">官网</a></li>
<li>进入 <em>admin/config/media/video/transcoders</em> 页面</li>
<li>在 Video transcoder 的选项中，选择 FFmpeg/avconv</li>
<li>在 <em>Path to FFmpeg or avconv executable</em> 中填入服务器中 FFMPEG 的可执行文件地址（可以用 <code>which ffmpeg</code> 查看）</li>
<li>保存配置</li>
</ol>
</li>
<li>在 <em>admin/config/media/video/presets/add</em> 页面中，添加一个 preset（至少需要一个），并且至少配置以下选项：<ul>
<li>Preset name</li>
<li>Video output extension - 输出格式</li>
<li>Video codec - 视频编码</li>
<li>Audio codec - 音频编码</li>
</ul>
</li>
<li>在 <em>admin/structure/types</em> 中，编辑或添加一个 <em>content type</em></li>
<li>添加一个 video 字段，并选择你之前设定好的 preset</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>现在你可以通过新建一个该 content type 下的 node 来上传视频了。注意，如果你使用的是 Zencoder，请确保你有一个公共的 IP 地址（而不是 localhost）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注1：本文翻译自 Drupal 官网中 Video 模块的文档，并做部分删改，仅供参考。&lt;/p&gt;
&lt;p&gt;注2：本文要求读者具备基本的 Drupal 7 知识，如基本架构，模块使用等。&lt;/p&gt;
&lt;p&gt;原文:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.
    
    </summary>
    
    
      <category term="Drupal" scheme="http://afantasy.ninja/tags/Drupal/"/>
    
      <category term="Translation" scheme="http://afantasy.ninja/tags/Translation/"/>
    
  </entry>
  
  <entry>
    <title>科学上网是神马</title>
    <link href="http://afantasy.ninja/2016/02/09/fuckgfw/"/>
    <id>http://afantasy.ninja/2016/02/09/fuckgfw/</id>
    <published>2016-02-08T16:49:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>努力做一个好的搬运工，解释清楚关于科学上网的事情。<br>这篇文章主要在科普一些基本概念，只是想了解具体翻墙方法的可以戳 <a href="/2016/02/09/break-gfw-fastforward/">这篇文章</a><br>程序员同行就没必要看这篇了，不是干货。<br><a id="more"></a></p>
<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><p>在查阅资料的过程中，发现早有前辈写了很相似的 <a href="https://github.com/XL2014/suixiang/blob/master/2009/05/how-to-break-through-gfw.md" target="_blank" rel="noopener">文章</a> 了，墙裂建议阅读（甚至不看我这篇都可以）。</p>
<p>另外，在一年多以前我有幸现场听了 云梯的 <a href="https://twitter.com/kgen" target="_blank" rel="noopener">@kgen</a> 关于科学上网的演讲，并整理成了一篇 <a href="https://mp.weixin.qq.com/s?__biz=MzA4NjM4NTYxMg==&amp;mid=200088823&amp;idx=1&amp;sn=7051ce10ead42050b19fbe0711c7d564&amp;scene=1&amp;srcid=0112xCzg2tw3GEDLWtYcchAe&amp;key=710a5d99946419d9e394a967a4b10d549851905a7d3ff5e46d188bbecf5ea8c599a97e8bf8e339b8ddf09135e7370a09&amp;ascene=0&amp;uin=MjYyODA0MjQ4Mw%3D%3D&amp;devicetype=iMac+MacBookPro11%2C2+OSX+OSX+10.11.3+build(15D21)&amp;version=11020201&amp;pass_ticket=px%2FKbwHJYExj3Fb52LK%2FlNK4T1Q7IOubUmdFgDsYhcXx9BtQCsMI3oIxktwDz3MB" target="_blank" rel="noopener">文章</a></p>
<p>所以本文仅仅做个简单的科普和介绍，并尽量搬运我觉得关于「科学上网」的一些有用的资料，以做日后参考。</p>
<p>毕竟世界上有很多事情更值得我们去做，我们只关心最快速度的搞定墙。</p>
<h1 id="what"><a href="#what" class="headerlink" title="what"></a>what</h1><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p>「科学上网」的定义：</p>
<blockquote>
<p>通过某种技术/非技术手段，摆脱 GFW 的束缚，自由浏览国外所有网站的行为。</p>
</blockquote>
<p>为了避免有朋友（比如，传统行业/年龄比较大的）还不大了解科学上网，这里稍微解释一下。</p>
<p>现在我们当中的大部分人的生活，和三家目前国内的互联网的 BIG 3 息息相关：</p>
<ul>
<li>B 百度（搜索，贴吧，地图…）</li>
<li>A 阿里巴巴（淘宝，支付宝…）</li>
<li>T 腾讯（微信，QQ…）</li>
</ul>
<p>事实上很多我们所熟悉的品牌（携程，去哪儿，滴滴）也或多或少带有 BAT 的痕迹（或收购或持股），可以说这三家巨头已经深入了我们生活的很多方面了。</p>
<p>所以大家应该对国内的很多著名的网站不会陌生（如果有上网的话），但是对国外的网站大家又知道多少呢？未必可知。这时候可能就会有人说：</p>
<blockquote>
<p>我不关心国外的网站，反正我也不需要上这些网站。</p>
</blockquote>
<p>那其实这篇文章对你就用处不大了，有点可惜…</p>
<p>假设我们现在要访问一些国外的网站。问题来了：有些国外的网站，对于我们来说，是无法直接访问到的，比如我刚才提到的：</p>
<ul>
<li><a href="http://twitter.com/" target="_blank" rel="noopener">Twitter</a></li>
<li><a href="http://facebook.com/" target="_blank" rel="noopener">Facebook</a></li>
<li><a href="https://www.google.com" target="_blank" rel="noopener">Google</a></li>
</ul>
<p>读者可以试一下能不能打开。如果不能，说明你遇到了一个叫做「墙」的东西。摆脱「墙」的限制，愉快的访问国外的网站，就是「科学上网」。</p>
<p>这里有一个新名词叫「墙」，需要先解释一下。</p>
<h2 id="墙（a-k-a-GFW）"><a href="#墙（a-k-a-GFW）" class="headerlink" title="墙（a.k.a GFW）"></a>墙（a.k.a GFW）</h2><p>稍微科普一下为什么会有墙。</p>
<ol>
<li>目前全世界的网络是互相联通的，包括我国的网络。但是我国的网络连接全世界的网络，是通过对外的国际出口完成的。大家可以这么理解：我们和各个网站间的联系是水管，而国际出口是某个总闸。</li>
<li>由于相关法规的规定，有关部门似乎希望控制我们能够访问的国外网站（换言之，不希望我们访问某些网站）<del>不要问我为什么，我还是想愉快的活下去的</del></li>
<li>通过某些技术手段，有关部门的技术团队在总闸上加上了智能开关，于是「墙」就出现了。在计算机术语中，Fire Wall（防火墙）指隔离某些访问的软件工具，所以「墙」也被称作 Great Fire Wall，简称 GFW.</li>
</ol>
<p>关于「墙」具体的实现原理，可以看看 <a href="http://www.xvping.cn/archives/435" target="_blank" rel="noopener">这篇</a>，或者 <a href="https://zh.wikipedia.org/wiki/GFW" target="_blank" rel="noopener">维基百科</a></p>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p><del><strong>其实 Why 是应该放在 What 前面的，因为没有 Why 就需要知道 What；但是不知道 What 又如何谈 Why 呢？ – 矛盾啊</strong></del></p>
<p>Q：为什么要进行「科学上网」？<br>A：因为在以下情况中，可能需要访问国外的网站：</p>
<ol>
<li>对于学生：<ul>
<li>写毕业论文要引用文献（Google Scholar）</li>
<li>文科同学需要查看国外新闻时事</li>
<li>理工科同学需要查看国外文档资料</li>
<li>出过国的童鞋（你们懂的）</li>
</ul>
</li>
<li>对于某些工种（如程序员），工作时也需要查阅国外的文档/…</li>
<li>对于所有人<ul>
<li>需要使用国外的服务，比如 Facebook/Twitter/Instagram/…</li>
<li>同上，比如 Google Play… =.=||</li>
</ul>
</li>
</ol>
<p>甚至有时候，连看英超直播都要看国外的网站啊~！！<del>（因为不想付费给乐视，逃</del></p>
<p>如果你确实不需要「科学上网」，那其实这篇文章对你就没什么用了。实在抱歉x2…</p>
<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>本来打算在这里写一下如何来「科学上网」，不过发现这是一个很大的 topic，所以还是单独写一篇文来解释吧。戳 <a href="/2016/02/09/break-gfw-fastforward/">这里</a></p>
<p>感觉这篇完了也没有啥干货，真是抱歉 orz…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;努力做一个好的搬运工，解释清楚关于科学上网的事情。&lt;br&gt;这篇文章主要在科普一些基本概念，只是想了解具体翻墙方法的可以戳 &lt;a href=&quot;/2016/02/09/break-gfw-fastforward/&quot;&gt;这篇文章&lt;/a&gt;&lt;br&gt;程序员同行就没必要看这篇了，不是干货。&lt;br&gt;
    
    </summary>
    
    
      <category term="LifeHack" scheme="http://afantasy.ninja/tags/LifeHack/"/>
    
  </entry>
  
  <entry>
    <title>科学上网之快速过关</title>
    <link href="http://afantasy.ninja/2016/02/09/break-gfw-fastforward/"/>
    <id>http://afantasy.ninja/2016/02/09/break-gfw-fastforward/</id>
    <published>2016-02-08T16:49:00.000Z</published>
    <updated>2016-07-10T08:28:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文旨在提供快速科学上网的通关方法。<br>废话少说，立刻开始。<br><a id="more"></a></p>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><p>科学上网的方式有若干种：</p>
<ul>
<li>VPN</li>
<li>Shadowsocks（又称 ss 或影梭）</li>
<li>Lantern（蓝灯）</li>
<li>GoAgent</li>
<li>改 hosts</li>
</ul>
<p>我自己比较喜欢用前两个方法。Lantern 我没有用过，GoAgent 不稳定而且局限程度比较大。</p>
<p>稍微做一个简单的比较表格吧</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>平台</th>
<th>费用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>VPN</td>
<td>全平台</td>
<td>一百多到几百不等</td>
<td>不易被封杀</td>
</tr>
<tr>
<td>Shadowsocks</td>
<td>全平台</td>
<td>每月10-20美元(自建)/80-100元(付费服务)</td>
<td>iOS 待研究;也不易被封杀</td>
</tr>
<tr>
<td>Lantern</td>
<td>全平台</td>
<td><strong>据说免费</strong></td>
<td>不要相信我那个“据说”</td>
</tr>
<tr>
<td>GoAgent</td>
<td>PC</td>
<td>这个是真免费</td>
<td>移动端存疑;只能用在浏览器上</td>
</tr>
<tr>
<td>改 hosts</td>
<td>PC</td>
<td>这个也免费</td>
<td>移动端我没试过;猫捉老鼠</td>
</tr>
</tbody>
</table>
<p>关于各种方法的具体优劣，Annie Wu 写了一篇很不错的 <a href="https://mp.weixin.qq.com/s?__biz=MzAwOTU3MDMwNg==&amp;mid=402146885&amp;idx=1&amp;sn=b8b69ca32f4b49fbe42f1effa39e095d&amp;scene=1&amp;srcid=01130kK0bCb7pKtQwV2Vfpq8&amp;key=710a5d99946419d9a313aac034600058a65e11dd5741d34c5ac15fc11b7ed24df3e5a616096eaaff56b058df8903ca4b&amp;ascene=0&amp;uin=MjYyODA0MjQ4Mw%3D%3D&amp;devicetype=iMac+MacBookPro11%2C2+OSX+OSX+10.11.3+build(15D21)&amp;version=11020201&amp;pass_ticket=px%2FKbwHJYExj3Fb52LK%2FlNK4T1Q7IOubUmdFgDsYhcXx9BtQCsMI3oIxktwDz3MB" target="_blank" rel="noopener">比较文章</a>，这里我只对比较熟悉的 VPN 和 Shadowsocks 进行详述。</p>
<h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><p><a href="https://zh.wikipedia.org/zh/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF" target="_blank" rel="noopener">VPN</a> 是一种简单的全局翻墙方式。特殊的国情造就了大量的 VPN 服务。</p>
<p>需要注意的是，VPN 是一种全局的翻墙方式，所以如果你希望同时访问国内外两边的网站（比如，看 youtube 同时看 youku），那你需要留意 VPN 厂商是否提供了智能分流的方式。否则要频繁切换也是很烦躁的。</p>
<p>电脑和移动端操作系统都预装了 VPN 客户端，相比别的翻墙操作更简单，适合不折腾人士。</p>
<p>以下列举我了解的 VPN 服务：</p>
<ul>
<li><a href="https://www.ytpub.com/" target="_blank" rel="noopener">云梯</a> - 这个是去年我在用的方式，不过半年前我换成了 Shadowsocks 了。需要注意的是云梯有很多假冒者，请小心分辨<ul>
<li>优点：国内可以访问，有完善的各平台教程，有智能分流，客服不错（提交工单就会回复），价格还算亲民<del>（真不是打广告）</del></li>
<li>缺点：部分地区网络无法访问（其实这个是所有 VPN 都可能有的问题）</li>
</ul>
</li>
<li><a href="https://www.astrill.com/" target="_blank" rel="noopener">Astrill</a> - 这个是很多老外喜欢用的 VPN<ul>
<li>优点：据老外和 Annie 说好，比较稳。支付方式多。</li>
<li>缺点：贵。而且好像网站本身也要翻墙上，有点鸡生蛋蛋生鸡的感觉。</li>
</ul>
</li>
<li>红杏<ul>
<li>据 Annie 说是死了。Sad story.</li>
<li>刚搜索了一下，现在也有叫「红杏」的服务（不全是 VPN），但真假莫辩：<ul>
<li><a href="http://www.yizhihongxing.com/" target="_blank" rel="noopener">一枝红杏</a></li>
<li><a href="http://www.hongxingchajian.com/" target="_blank" rel="noopener">红杏</a></li>
</ul>
</li>
<li>然后我又搜索了一下，发现官方有 <a href="http://help.honx.in/hc/kb/article/49540/" target="_blank" rel="noopener">解释这个问题</a>，敬请大家不要上当。</li>
</ul>
</li>
</ul>
<p>其他没用过的我就不提了。或者大家如果有找到好的也可以用。</p>
<h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><p>江湖人称 ss 或影梭。也是一种可全局翻墙的方式（原理与 VPN 不同，使用 Socks 协议）</p>
<p>Shadowsocks 分两个部分：Server &amp; Client</p>
<p>Server 指服务器端，Client 指客户端（你的设备），两端通过 Socks 协议沟通，由于协议本身并不是普通的 HTTP 协议，所以更难被墙。</p>
<p>在服务器端有两种方式可以实现：自建（用 VPS）</p>
<h2 id="自建"><a href="#自建" class="headerlink" title="自建"></a>自建</h2><p>推荐阅读 Shadowsocks 的 <strong><a href="https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">官方文档</a></strong></p>
<p>当然也可以参考这些教程：</p>
<ul>
<li>For linux: <a href="https://xiaoxiao.im/2014/06/02/shadowsocks.html" target="_blank" rel="noopener">安装配置 Shadowsocks</a></li>
<li><a href="http://jerryzou.com/posts/shadowsocks-with-digitalocean/" target="_blank" rel="noopener">使用 Digital Ocean 和 Shadowsocks 来科学上网</a></li>
</ul>
<p>至于 VPS 的选择方面，有几个选项：</p>
<ul>
<li>Vultr - 这个有很多朋友推荐，目前在用这个</li>
<li><a href="https://www.conoha.jp/zh" target="_blank" rel="noopener">Conoha</a> - 据说国内速度很不错哦（但是我没用过。特别鸣谢某18岁骚年的推荐。</li>
<li>Linode</li>
<li>Digital Ocean</li>
</ul>
<p>当然你也可以用你喜欢的 VPS 架设。</p>
<h2 id="使用服务"><a href="#使用服务" class="headerlink" title="使用服务"></a>使用服务</h2><p>作为程序员我是自己搭建的，所以没买过这种服务。</p>
<p>Annie 推荐的是 <a href="https://shadowsocks.com/" target="_blank" rel="noopener">这个</a>，有兴趣的同学可以试试。（不行不要打我）</p>
<h2 id="客户端的问题"><a href="#客户端的问题" class="headerlink" title="客户端的问题"></a>客户端的问题</h2><p>这里有一个比较完整的 <a href="https://shadowsocks.com/client.html" target="_blank" rel="noopener">列表</a></p>
<h3 id="Mac-下的使用"><a href="#Mac-下的使用" class="headerlink" title="Mac 下的使用"></a>Mac 下的使用</h3><p>由于我自己用的是 Mac，所以只能整理出 Mac 下的教程了。<br>Windows 和 Linux 的用户实在抱歉。</p>
<ul>
<li><a href="https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">Windows 教程</a></li>
<li><a href="http://jerryzou.com/posts/shadowsocks-with-digitalocean/" target="_blank" rel="noopener">Linux 教程</a></li>
</ul>
<p>具体步骤：</p>
<ol>
<li>购买或在服务器上自建好 Shadowsocks 服务。</li>
<li><p><a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-%E5%B8%AE%E5%8A%A9" target="_blank" rel="noopener">下载安装 Shadowsocks OS X</a></p>
<p>貌似 Shadowsocks OS X 的那个下载链接…是被墙的嗯。<a href="http://pan.baidu.com/s/1skb1yQp" target="_blank" rel="noopener">百度盘链接</a></p>
</li>
<li><p>配置：打开 Shadowsocks OS X，这时屏幕顶部任务栏会有一个纸飞机的图案。点击之后选择「服务器」-「服务器设定」，然后会出现以下窗口：</p>
<p><img src="http://7xjvtw.com1.z0.glb.clouddn.com/ss-mac-os-x.png" alt=""></p>
<p>地址栏填服务商提供的（或者自建的）IP 和端口；填写密码和备注。</p>
</li>
<li><p>配置好后点击纸飞机：「打开 Shadowsocks」，并切换到自动代理模式；</p>
</li>
<li>用 Chrome 浏览器，并在浏览器上安装 SwitchyOmega 插件，并把插件调整为 <code>auto switch</code> 模式</li>
<li>尽情的上网吧。</li>
</ol>
<h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><p>之前我错过了<del>大名鼎鼎</del>死贵死贵的 Surge, 有点遗憾。今天在群里看到有童鞋推荐 Shadowrocket，亲测非常方便好用，在这里补充一下：</p>
<ol>
<li>在 AppStore 搜索 <code>Shadowrocket</code> 并下载（6RMB，相比 68 的 Surge 算是很良心的价格了）</li>
<li>跟着 <a href="https://ii-i.org/archives/859" target="_blank" rel="noopener">这篇教程</a> 往下做，最方便的方法就是在电脑端（如果你在电脑上已经配置了 shadowsocks 的话）生成二维码，然后直接扫描一下就可以了。</li>
<li>（选做）配置自动模式（On Demand）点击 Settings - On Demand，将 <code>On Demand</code> 的选项卡打开即可。</li>
</ol>
<h1 id="那你在用什么"><a href="#那你在用什么" class="headerlink" title="那你在用什么?"></a>那你在用什么?</h1><ul>
<li>Mac 上用 ShadowsocksX （非常完美）</li>
<li><del>iOS 上用云梯 VPN。我用的是移动 4G，只能说时灵时不灵吧。</del> iOS: long live Shadowrocket!!!</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://www.jianshu.com/collection/b6b16295fc83" target="_blank" rel="noopener">科学上网专题 - 简书</a> - <del>话说简书这么干，我告诉你，吃枣药丸啊</del></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwOTU3MDMwNg==&amp;mid=402146885&amp;idx=1&amp;sn=b8b69ca32f4b49fbe42f1effa39e095d&amp;scene=1&amp;srcid=01130kK0bCb7pKtQwV2Vfpq8&amp;key=710a5d99946419d9a313aac034600058a65e11dd5741d34c5ac15fc11b7ed24df3e5a616096eaaff56b058df8903ca4b&amp;ascene=0&amp;uin=MjYyODA0MjQ4Mw%3D%3D&amp;devicetype=iMac+MacBookPro11%2C2+OSX+OSX+10.11.3+build(15D21)&amp;version=11020201&amp;pass_ticket=px%2FKbwHJYExj3Fb52LK%2FlNK4T1Q7IOubUmdFgDsYhcXx9BtQCsMI3oIxktwDz3MB" target="_blank" rel="noopener">V＊P＊N使用大全丨当我想看看世界的时候，我要做些什么。</a> - Annie 的呕心沥血之作</li>
<li><a href="http://jerryzou.com/posts/shadowsocks-with-digitalocean/" target="_blank" rel="noopener">使用 Digital Ocean 和 Shadowsocks 来科学上网</a> - 很全面的翻墙教程</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文旨在提供快速科学上网的通关方法。&lt;br&gt;废话少说，立刻开始。&lt;br&gt;
    
    </summary>
    
    
      <category term="LifeHack" scheme="http://afantasy.ninja/tags/LifeHack/"/>
    
  </entry>
  
  <entry>
    <title>当提技术问题前我在想什么</title>
    <link href="http://afantasy.ninja/2016/02/09/what-i-am-thinking-before-asking-questions/"/>
    <id>http://afantasy.ninja/2016/02/09/what-i-am-thinking-before-asking-questions/</id>
    <published>2016-02-08T16:00:00.000Z</published>
    <updated>2018-07-21T18:39:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候提一个问题的姿势，比提什么问题更加重要。<br><a id="more"></a><br>注: 本文最早是发在一个学习论坛上的 <a href="http://bbs.sike.io/t/topic/1385" target="_blank" rel="noopener">帖子</a>。后有所删改。</p>
<h1 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h1><p>本文的论点1：在你用尽浑身解数之前，请不要轻易发问题。<br>本文的论点2：请用心问一个问题。</p>
<p>如果对其中的论点有异议的，欢迎留言反驳。也欢迎点击左（Win用户右）上角的叉叉。</p>
<h1 id="在我遇到一个坑时"><a href="#在我遇到一个坑时" class="headerlink" title="在我遇到一个坑时"></a>在我遇到一个坑时</h1><p>其实我经常遇到坑，而且经常自己坑自己。<del>之所以没有让其他人耻笑的原因只是我没有告诉别人（逃</del></p>
<p>自己给自己挖坑的情况包括但不限于：</p>
<ol>
<li>Typo</li>
<li>没保存</li>
<li>没刷新</li>
<li>没重启</li>
<li>没脑子（对的，搞了半天，想错了</li>
</ol>
<p>其实我觉得前4点已经占了 95% 以上的情况。可能我不是一个老司机，所以智商比较捉急（逃</p>
<p>因为跳了太多（自己的）坑，所以当我遇到一个”坑”时，我的反应是（按先后顺序排列）:</p>
<ol>
<li>这是我自己挖的么？</li>
<li>我有没有重启/刷新/保存？</li>
<li>Debug</li>
</ol>
<p>下文将讨论解决问题的流程。</p>
<h1 id="1-Debug"><a href="#1-Debug" class="headerlink" title="1. Debug"></a>1. Debug</h1><p>这个问题太大，随便选门语言框架的 debug 话题就可以扯很久。我对 debug 的理解是：</p>
<ol>
<li>搜集并分析 log</li>
<li>工具</li>
<li>其他方法</li>
</ol>
<p>前两点我相信大家会懂。如果不懂的话可以看下一章（嗯，其实下一章没有提工具，哈哈哈哈哈）。其他方法包括但不限于：</p>
<ul>
<li>二分排除法</li>
<li>断点</li>
<li>Print</li>
</ul>
<h1 id="2-搜索"><a href="#2-搜索" class="headerlink" title="2. 搜索"></a>2. 搜索</h1><blockquote>
<p>xxx 是什么? </p>
</blockquote>
<p>这是我在论坛/群组里见过的最多的问题。康忙，现在是一个互联网时代。</p>
<p>你不需要别人告诉你这是什么，网络上你能找到关于一个名词的一切。</p>
<p>但是这里会有三个问题：搜索渠道、搜索内容和搜索技巧。</p>
<h2 id="搜索渠道"><a href="#搜索渠道" class="headerlink" title="搜索渠道"></a>搜索渠道</h2><p>首先，请谷歌。（抛开某度难看的吃相，在百度上搜技术问题简直就是慢性自杀<br>如果无法谷歌，请尽最大努力来进行翻墙。<br>如果连翻墙都没有办法（比如，你家的运营商是个渣渣），那用 <a href="http://cn.bing.com/" target="_blank" rel="noopener">必应</a> 也还行。</p>
<h2 id="搜索内容"><a href="#搜索内容" class="headerlink" title="搜索内容"></a>搜索内容</h2><ol>
<li>报错日志的关键字，越具体越精确越好。举例：<code>error</code> 是一个很泛的词，而 <code>unexpected token &lt;</code> 或者 <code>permission denied</code> 是一个比较精确的描述。</li>
<li>加上你使用的语言/框架/库 作为限定范围，别找 JavaScript 的错误跑 Java 去了。</li>
</ol>
<h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><ol>
<li>请用英语搜索（尝试用一切方法用英语描述你的问题）。我并没有崇洋媚外的意思，但是我个人认为，在目前比较流行的技术（比如，React）上，国外的速度还是要比国内快一点点的。国内的大牛作品，也多少建立在阅读（或翻译）国外博客/代码等等之上的。况且我们还有大 Stackoverflow。</li>
<li>如果遵循了第一点，你会摸索到很多第2方法，比如直接上 Stackoverflow, 直接上 Github，直接查源码，直接订阅博客, etc.</li>
</ol>
<p>这方面其实我也不是很出色（可能是因为我的问题用关键字就已经能查到了），所以推荐 @cee 同学的 <a href="http://blog.cee.moe/secrets-that-a-programmer-should-know.html" target="_blank" rel="noopener">一篇文章</a>，里面有详细的描述。</p>
<p>Have fun searching!</p>
<h1 id="3-如果还没有搞定（如果你看到这里）"><a href="#3-如果还没有搞定（如果你看到这里）" class="headerlink" title="3. 如果还没有搞定（如果你看到这里）"></a>3. 如果还没有搞定（如果你看到这里）</h1><p>请再次检查这是不是自己挖的坑。<br>或者把椅子拉后一点，喝口水，认真检查一次报错日志，理一理思路。<br>尝试一下用 <a href="https://zh.wikipedia.org/zh/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95" target="_blank" rel="noopener">小黄鸭调试法</a>。<br>准备问问题。</p>
<h1 id="4-问一个高质量的问题。"><a href="#4-问一个高质量的问题。" class="headerlink" title="4. 问一个高质量的问题。"></a>4. 问一个高质量的问题。</h1><p>在说这个之前，我要搬出伟大的 Eric Raymond 的 <a href="http://doc.zengrong.net/smart-questions/cn.html" target="_blank" rel="noopener">「提问的智慧」</a></p>
<p>如果你看完了，你就会说：早知道我就直接看这个了，还要听你胡扯！（如果你没看完，可以看完再回来说这句话）</p>
<p>但是我还是想说下我的看法。这是我对自己提的问题的要求：</p>
<ol>
<li>要有一个详细的，具体的标题。一目了然，方便导航，方便搜索，方便老司机带你飞；</li>
<li>记录你在问之前做过的 debug，排除杂音；</li>
<li>在解决之后修改题目，标记为【已解决】，再补一个解决方案；</li>
<li>要懂得 say thankyou</li>
</ol>
<p>而一个好的提问究竟是怎样的呢? 我找到了一个挺不错的 <a href="https://ruby-china.org/topics/27890" target="_blank" rel="noopener">栗子</a>。</p>
<p>有一个童鞋提出，问问题只是“顺便问”，这样能省下自己的时间。我想让大家一起思考的问题是：假如你是一个老司机，很会指路，如果让你重复的指很多次一样的道，话过三巡也会腻烦的吧？</p>
<h1 id="Why-the-fuck"><a href="#Why-the-fuck" class="headerlink" title="Why the fuck"></a>Why the fuck</h1><p>我觉得还是会有童鞋说：“我很急，我需要一个快速的答案！” 我的理解是：</p>
<ol>
<li><p>你没有安排好你的时间。非要到死线前才来要求生产力，是一种上了茅坑不冲屎，再上同样的茅坑屎还在的行为。</p>
<blockquote>
<p>Since you didn’t debug by yourself, you never know what the hell is behind the scene.</p>
</blockquote>
</li>
<li><p>你很懒，懒到让别人帮你买单。</p>
</li>
</ol>
<p>Q.E.D</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候提一个问题的姿势，比提什么问题更加重要。&lt;br&gt;
    
    </summary>
    
    
      <category term="LifeHack" scheme="http://afantasy.ninja/tags/LifeHack/"/>
    
  </entry>
  
  <entry>
    <title>[译] 如何在 Drupal 7 中构建模块</title>
    <link href="http://afantasy.ninja/2016/02/05/how-to-create-a-module-in-drupal-7/"/>
    <id>http://afantasy.ninja/2016/02/05/how-to-create-a-module-in-drupal-7/</id>
    <published>2016-02-04T16:00:00.000Z</published>
    <updated>2018-07-21T14:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>注1：本文翻译自 Drupal 官方网站关于构建模块的<a href="https://www.drupal.org/developing/modules/7" title="Drupal 7 模块指南" target="_blank" rel="noopener">指南</a>，结合实际操作有部分修改和简化。</p>
<p>注2：阅读本文需要对 Drupal 有基本的了解：知道如何使用 Drupal 的管理后台，以及安装模块。</p>
<h3 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h3><h4 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h4><ol>
<li>给模块取个名字。模块名建议用 “下划线+小写“ 的方式，以避免不必要的问题，比如 my_custom_module</li>
<li>创建一个文件夹作为模块的文件夹</li>
<li>在文件夹中新建两个 php 文件，分别是 <code>my_custom_module.module</code> 和 <code>my_custom_module.info</code>。module 文件是该模块的主文件入口，info 文件是该模块的定义，记录关于该模块的元信息。</li>
<li><p>初始化 <code>my_custom_module.info</code> 文件。info 文件的通用模板为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name = My Custom Module</div><div class="line">description = A description of what your module does</div><div class="line">core = 7.x</div></pre></td></tr></table></figure>
<p>这里的 name 和 description 会显示在网站后台的模块管理界面中，作为模块的名字和介绍。关于 info 文件的详细介绍可以参考相应的 <a href="http://drupal.org/node/542202" title="info 文件的介绍" target="_blank" rel="noopener">Drupal 文档</a>.</p>
</li>
<li><p>初始化 <code>my_custom_module.module</code> 文件。在没有添加任何功能前，先在文件中加入一行 php 的开头标签（不需要结尾，如果加入结尾标签可能会导致一些运行问题）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// my_custom_module.module</span></div><div class="line"><span class="meta">&lt;?php</span></div></pre></td></tr></table></figure>
</li>
<li><p>将模块的整个文件夹放入 <code>sites/all/modules</code> 文件夹中</p>
</li>
<li>这时在 Drupal 的管理后台中，你应该能够看到一个名字为 “My Custom Module” 的模块。启用它并保存配置。</li>
</ol>
<h4 id="实现第一个钩子"><a href="#实现第一个钩子" class="headerlink" title="实现第一个钩子"></a><a href="https://www.drupal.org/node/1095546" title="Drupal 7 模块指南 - 钩子函数" target="_blank" rel="noopener">实现第一个钩子</a></h4><p>接下来我们要利用通过 “钩子函数”（hooks） 来在模块中实现某些特定的功能。钩子函数的命名方式为：<code>{module_name}_{function_name}</code>，其中 <code>module_name</code> 是模块的名字，而 <code>function_name</code> 是预定义的钩子函数的后缀。Drupal 会调用这些钩子函数，并传入相应的特定数据。</p>
<p>为了便于展示，我们来实现一个简单的钩子：<a href="hook_help-doc"><code>hook_help</code></a>，这个钩子可以让我们向使用者提供关于这个模块的帮助信息。要实现这个函数，我们就要用模块名字来取代钩子命名中的 “hook”，也就是实现一个叫做 <code>my_custom_module_help</code> 的函数，代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_custom_module_help</span><span class="params">($path, $arg)</span> </span>&#123;</div><div class="line">  <span class="keyword">switch</span>($path) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"admin/help#my_custom_module"</span>:</div><div class="line">      <span class="keyword">return</span> <span class="string">"&lt;p&gt;Do something&lt;/p&gt;"</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个钩子函数接受两个参数：</p>
<ul>
<li><code>$path</code> 参数是用户查看模块帮助时所在的位置，即当前所处的 url 地址，这个参数可以是通配符</li>
<li><code>$arg</code> 当 <code>$path</code> 为通配符时的匹配参数</li>
</ul>
<p>在这个例子中我们仅匹配特定的路径，所以仅使用 <code>$path</code> 参数（更多用法可以直接查看 Drupal 的<a href="https://api.drupal.org/api/drupal/modules%21system%21system.api.php/function/hook_help/7" title="hook_help 钩子的文档" target="_blank" rel="noopener">文档</a>）。</p>
<h4 id="检查钩子是否正确工作"><a href="#检查钩子是否正确工作" class="headerlink" title="检查钩子是否正确工作"></a>检查钩子是否正确工作</h4><p>在模块管理界面查看 “My Custom Module” 这个模块，这时应该能够看到一个 “help” 的链接（首先要确保启用了 Help 这个核心模块），点击进入模块的帮助页面，查看钩子函数返回的文字内容。</p>
<p>如果没有看到该链接，尝试先禁用模块，再重新启用。</p>
<p>到这里为止，我们就顺利的搭建模块了！实现钩子函数是模块最常用的使用方法。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="https://www.drupal.org/developing/modules/7" title="Drupal 7 模块指南" target="_blank" rel="noopener">Drupal 7 模块指南</a></li>
<li><a href="https://www.drupal.org/node/1095546" title="Drupal 7 模块指南 - 钩子函数" target="_blank" rel="noopener">Drupal 7 模块指南 - 钩子函数</a></li>
<li><a href="http://drupal.org/node/542202" title="info 文件的介绍" target="_blank" rel="noopener">Drupal 7 模块的 info 文件</a></li>
<li><a href="https://api.drupal.org/api/drupal/modules%21system%21system.api.php/function/hook_help/7" title="hook_help 钩子的文档" target="_blank" rel="noopener">Drupal 7 hook_help 函数</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注1：本文翻译自 Drupal 官方网站关于构建模块的&lt;a href=&quot;https://www.drupal.org/developing/modules/7&quot; title=&quot;Drupal 7 模块指南&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;指南&lt;
    
    </summary>
    
    
      <category term="Drupal" scheme="http://afantasy.ninja/tags/Drupal/"/>
    
      <category term="Translation" scheme="http://afantasy.ninja/tags/Translation/"/>
    
  </entry>
  
</feed>
