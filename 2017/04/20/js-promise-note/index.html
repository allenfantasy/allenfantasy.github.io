<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JS Promise Note · A Fantasy Ninja</title><meta name="description" content="JS Promise Note - Allen"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://github.com/allenfantasy" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">JS Promise Note</h1><div class="post-meta"><span class="post-time">2017年4月20日</span><span class="taglist"><a href="/tags/JavaScript" class="tag">JavaScript</a></span></div><div class="post-content"><p>一直对 Promise 这个概念感到迷迷糊糊，实在是受不了了，决定系统的过一次相关的知识点。<br><a id="more"></a></p>
<p>以下笔记主要基于著名的 <a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">JavaScript 迷你书(中文版)</a>，感谢原作者 @azu 和翻译者 @liubin!</p>
<p>本文将不定期陆续更新。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>Constructor</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">	<span class="comment">// async processing...</span></div><div class="line">	<span class="comment">// call resolve / reject when done</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><strong>Instance Method</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div><div class="line"><span class="comment">// OR</span></div><div class="line">promise.then(onFulfilled).catch(onRejected)</div></pre></td></tr></table></figure>
<p><strong>Static Method</strong></p>
<p><code>Promise.all()</code>, <code>Promise.resolve()</code>, <code>Promise.reject()</code></p>
<h2 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h2><p>Promise 有三种状态：<code>has-resolution/Fulfilled</code>, <code>has-rejection/Rejected</code>, <code>unresolved/Pending</code></p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><strong><code>Promise.resolve()</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 快速新建一个 Promise 对象, 并第一时间调用 then 方法</span></div><div class="line"><span class="built_in">Promise</span>.resolve(<span class="number">42</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 将 Thenable 转换为 Promise 对象</span></div><div class="line"><span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/json/comment.json'</span>)).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(value)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>同理，<strong><code>Promise.reject()</code></strong> 会第一时间返回一个 promise 对象（如果有调用 <code>.catch(onReject)</code> 则会在下一 tick 中执行 <code>onReject</code></p>
<h3 id="使用-Promise-确保异步流程"><a href="#使用-Promise-确保异步流程" class="headerlink" title="使用 Promise 确保异步流程"></a>使用 Promise 确保异步流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReadyPromise</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> readyState = <span class="built_in">document</span>.readyState</div><div class="line">    <span class="keyword">if</span> (readyState === <span class="string">'interactive'</span> || readyState === <span class="string">'complete'</span>) &#123;</div><div class="line">      resolve()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, resolve)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">onReadyPromise().then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM fully loaded and parsed'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'==Starting=='</span>)</div></pre></td></tr></table></figure>
<h3 id="Promise-Chain"><a href="#Promise-Chain" class="headerlink" title="Promise Chain"></a>Promise Chain</h3><p><code>.then</code> 和 <code>.catch</code> 方法可以进行链式调用，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve()</div><div class="line">promise</div><div class="line">	.then(taskA)</div><div class="line">	.then(taskB)</div><div class="line">	.catch(onRejected)</div><div class="line">	.then(finalTask)</div></pre></td></tr></table></figure>
<p>在这个链式调用中，taskA 和 taskB 可以通过两种方式使执行流程经过 onRejected 函数：</p>
<ol>
<li>抛出一个异常</li>
<li>返回一个 <code>rejected</code> 状态的 Promise 对象（推荐使用这个方法）</li>
</ol>
<p>使用第二种方法的理由：</p>
<ol>
<li>更加直观，因为 <code>.catch</code> 方法本来的含义就是在 Promise 对象状态变为 <code>rejected</code> 时执行的回调。</li>
<li>避免 <code>throw</code> 关键字造成的副作用（影响 debug 等）</li>
</ol>
<p>在 <code>then</code> 中注册的回调函数可以通过 <code>return</code> 返回一个值，这个返回值会传给后续的 <code>then</code> 或者 <code>catch</code> 的回调函数</p>
<p>但 <code>then</code> 的结果总是一个新创建的 promise 对象。如果 <code>then</code> 中注册的回调函数的返回值就是一个 Promise 对象，则 <code>then</code> 的结果就是这个对象。</p>
<p>所以我们可以在 <code>then</code> 中返回一个带 <code>reject</code> 状态的 Promise 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> onRejected = <span class="built_in">console</span>.error.bind(<span class="built_in">console</span>)</div><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve()</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'this promise is rejected'</span>))</div><div class="line">&#125;).catch(onRejected)</div></pre></td></tr></table></figure>
<h4 id="Anti-pattern-对同一个对象同时调用-then-方法"><a href="#Anti-pattern-对同一个对象同时调用-then-方法" class="headerlink" title="Anti-pattern: 对同一个对象同时调用 then 方法"></a>Anti-pattern: 对同一个对象同时调用 then 方法</h4><p>显然这样的处理是不能得到预想中的结果的，必须修改成使用 Promise Chain 的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> aPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</div><div class="line">&#125;);</div><div class="line">aPromise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"1: "</span> + value); <span class="comment">// =&gt; 100</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="处理-IE8-下-catch-保留字的问题"><a href="#处理-IE8-下-catch-保留字的问题" class="headerlink" title="处理 IE8 下 catch 保留字的问题"></a>处理 IE8 下 <code>catch</code> 保留字的问题</h3><blockquote>
<p>在ECMAScript 3中保留字是不能作为对象的属性名使用的。而IE8及以下版本都是基于ECMAScript 3实现的，因此不能将 catch 作为属性来使用，也就不能编写类似 promise.catch() 的代码，因此就出现了 identifier not found 这种语法错误了。</p>
</blockquote>
<p><strong>解决方案</strong>: 使用 <code>then</code> 而不使用 <code>catch</code>；如果一定要使用 <code>catch</code> 的话：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'message'</span>))</div><div class="line">promise[<span class="string">'catch'</span>](<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a><code>Promise.all()</code></h3><p>Promise.all 接收 Promise 对象组成的数组作为参数，两个 promise 对象的初始化会同时进行，当所有的 promise 对象的状态转变为 <code>fulfilled</code> 或者 <code>rejected</code> 之后才会处理 Promise Chain 上的 then 函数，且得到的执行结果的顺序与原 promise 数组的顺序一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerPromisefy</span>(<span class="params">delay</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      resolve(delay)</div><div class="line">    &#125;, delay)</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> startDate = <span class="built_in">Date</span>.now()</div><div class="line"></div><div class="line"><span class="comment">// 所有 promise 变为 resolve 后程序退出</span></div><div class="line"><span class="built_in">Promise</span>.all([</div><div class="line">  timerPromisefy(<span class="number">1</span>),</div><div class="line">  timerPromisefy(<span class="number">32</span>),</div><div class="line">  timerPromisefy(<span class="number">64</span>),</div><div class="line">  timerPromisefy(<span class="number">128</span>),</div><div class="line">]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - startDate + <span class="string">'ms'</span>) <span class="comment">// ~128ms</span></div><div class="line">  <span class="built_in">console</span>.log(values) <span class="comment">// [1,32,64,128]</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h3><p><code>race()</code> 方法和 <code>all()</code> 类似，接收一个 promise 对象数组为参数，但区别在于：</p>
<blockquote>
<p>Promise.race 只要有一个 Promise 对象进入 FulFilled 或者 Rejected 状态的话，就会继续进行后面的处理。</p>
</blockquote>
<p>但 race 胜出的 Promise 对象不会阻止其他 Promise 对象的执行。</p>
<h3 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a><code>.catch()</code></h3><p>最好的理解方法就是将 catch 方法当做是 <code>promise.then(undefined, onRejected)</code>，它们在本质上没有区别。</p>
<h2 id="Test-Promise"><a href="#Test-Promise" class="headerlink" title="Test Promise"></a>Test Promise</h2><ul>
<li>使用 Mocha 对 Promise 进行测试</li>
<li>在 <code>it()</code> 中直接返回 Promise 对象，则不需要使用 <code>done</code></li>
<li>测试 Promise 对象时，应该覆盖 Promise 对象的两种状态（Fulfilled, Rejected），同时检查两种状态时的返回值。满足这样条件的测试叫做可控测试（controllable tests）</li>
</ul>
<p>定义一个叫做 <code>shouldRejected</code> 的函数，用于测试期待返回状态为 <code>onRejected</code> 的 Promise：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldRejected</span> (<span class="params">promise</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">  	<span class="keyword">catch</span> () &#123;</div><div class="line">  	  <span class="keyword">return</span> promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  	    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected promise to be rejected but it was fulfilled'</span>)</div><div class="line">  	  &#125;, (reason) =&gt; &#123;</div><div class="line">  	    fn.call(promise, reason)</div><div class="line">  	  &#125;)</div><div class="line">  	&#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">it(<span class="string">'should be rejected'</span>, () =&gt; &#123;</div><div class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'human error'</span>)</div><div class="line">  <span class="keyword">return</span> showRejected(promise).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</div><div class="line">    assert(error.message === <span class="string">'human error'</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>同理可以写一个 <code>shouldFulfilled</code> 的 helper…</p>
<h2 id="Advanced"><a href="#Advanced" class="headerlink" title="Advanced"></a>Advanced</h2><p>一些实现了 Promise 的第三方类库：</p>
<h4 id="Polyfills"><a href="#Polyfills" class="headerlink" title="Polyfills"></a>Polyfills</h4><ul>
<li><a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="noopener">stefanpenner/es6-promise</a></li>
<li><a href="https://github.com/getify/native-promise-only/" target="_blank" rel="noopener">getify/native-promise-only</a></li>
</ul>
<h4 id="Promise-Extensions"><a href="#Promise-Extensions" class="headerlink" title="Promise Extensions"></a>Promise Extensions</h4><ul>
<li><a href="https://github.com/kriskowal/q" target="_blank" rel="noopener">kriskowal/q</a></li>
<li><a href="https://github.com/petkaantonov/bluebird" target="_blank" rel="noopener">petkaantonov/bluebird</a></li>
</ul>
<h3 id="Thenable"><a href="#Thenable" class="headerlink" title="Thenable"></a>Thenable</h3><ul>
<li>Thenable 就是一个具有 <code>.then()</code> 方法的一个对象。</li>
<li>通过 <code>Promise.resolve()</code> 可以将一个 Thenable 对象转换为一个标准的 Promise 对象</li>
<li>很多第三方库提供了将 Thenable 对象转换为其实现的 Promise 对象的途径。所以在内部使用 Thenable，便于在不同的 Promise 类库之间进行相互转换。</li>
</ul>
<p>实现一个 Thenable 对象非常简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">	then (resolve, reject) =&gt; &#123;</div><div class="line">		<span class="comment">// call resolve when everything is okay</span></div><div class="line"></div><div class="line">		<span class="comment">// call reject when things go wrong</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Deferred-amp-Promise"><a href="#Deferred-amp-Promise" class="headerlink" title="Deferred &amp; Promise"></a>Deferred &amp; Promise</h3><h4 id="Deferred-和-Promise-的关系"><a href="#Deferred-和-Promise-的关系" class="headerlink" title="Deferred 和 Promise 的关系"></a>Deferred 和 Promise 的关系</h4><p><img src="http://liubin.org/promises-book/Ch4_AdvancedPromises/img/deferred-and-promise.png" alt=""></p>
<ul>
<li>Deferred 拥有 Promise</li>
<li>Deferred 具备对 Promise 状态进行操作的特权方法</li>
</ul>
<h4 id="使用-Promise-实现-Deferred"><a href="#使用-Promise-实现-Deferred" class="headerlink" title="使用 Promise 实现 Deferred"></a>使用 Promise 实现 Deferred</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// using ES5 style</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Deferred</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">		<span class="keyword">this</span>._resolve = resolve</div><div class="line">		<span class="keyword">this</span>._reject = reject</div><div class="line">	&#125;.bind(<span class="keyword">this</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>._resolve.call(<span class="keyword">this</span>.promise, value)</div><div class="line">&#125;</div><div class="line"></div><div class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>._reject.call(<span class="keyword">this</span>.promise, reason)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 实现一个 getURL 函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</div><div class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</div><div class="line">    req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</div><div class="line">            deferred.resolve(req.responseText);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        deferred.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</div><div class="line">    &#125;;</div><div class="line">    req.send();</div><div class="line">    <span class="keyword">return</span> deferred.promise;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 运行实例</span></div><div class="line"><span class="keyword">var</span> URL = <span class="string">"http://httpbin.org/get"</span>;</div><div class="line">getURL(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).catch(<span class="built_in">console</span>.error.bind(<span class="built_in">console</span>));</div></pre></td></tr></table></figure>
<p>这样写的好处有：</p>
<ul>
<li>减少一层缩进</li>
<li>不需要一开始就将处理流程写成一大段代码，只需要先创建 deferred 对象，在任何时机调用 <code>resolve</code>, <code>reject</code> 方法。</li>
</ul>
<blockquote>
<p>如果说Promise是用来对值进行抽象的话，Deferred则是对处理还没有结束的状态或操作进行抽象化的对象，我们也可以从这一层的区别来理解一下这两者之间的差异。</p>
<p>换句话说，Promise代表了一个对象，这个对象的状态现在还不确定，但是未来一个时间点它的状态要么变为正常值（FulFilled），要么变为异常值（Rejected）；而Deferred对象表示了一个处理还没有结束的这种事实，在它的处理结束的时候，可以通过Promise来取得处理结果。</p>
</blockquote>
<h3 id="实现超时机制-Promise-race"><a href="#实现超时机制-Promise-race" class="headerlink" title="实现超时机制: Promise.race()"></a>实现超时机制: <code>Promise.race()</code></h3><p>以下这段代码实现了一个简单的超时函数，当目标 Promise 中的任务在超过 ms 后未执行完（状态未变更），则由和其竞争的 <code>timeout</code> promise 抛出一个异常，从而调起后续 Promise Chain 中的 catch 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayPromise</span>(<span class="params">ms</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</div><div class="line">        setTimeout(resolve, ms);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">promise, ms</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    	<span class="comment">// 也可以用 reject</span></div><div class="line">    	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Operation timed out after '</span> + ms + <span class="string">' ms'</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise, timeout]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 运行示例</span></div><div class="line"><span class="keyword">var</span> taskPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</div><div class="line">    <span class="comment">// 随便一些什么处理</span></div><div class="line">    <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">2000</span>;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        resolve(delay + <span class="string">"ms"</span>);</div><div class="line">    &#125;, delay);</div><div class="line">&#125;);</div><div class="line">timeoutPromise(taskPromise, <span class="number">1000</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"taskPromise在规定时间内结束 : "</span> + value);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"发生超时"</span>, error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>不过这里还有一个问题，就是如果业务 promise 在执行过程中出现了问题，抛出一个错误（或者调用 reject），那么在 Promise Chain 后续的 catch 函数中，其实我们无法分辨到底是系统超时了还是业务 promise 出现了问题。当然，检查 <code>error.msg</code> 具体的字符串值是可以勉强做到的，但这样的实现非常的不美观。</p>
<p>一种理想的方案是自定义一个 <code>TimeoutError</code> 类型的对象，通过检查 <code>error instanceof TimeoutError</code> 来判断捕获到的错误是否为一个超时错误。</p>
<p>使用 ES6 规范里面的 <code>class</code>, <code>extend</code> 自然是轻轻松松，但也无妨看下在 ES5 下的实现方案。</p>
<h4 id="插播：创建一个继承-Error-的类-TimeoutError"><a href="#插播：创建一个继承-Error-的类-TimeoutError" class="headerlink" title="插播：创建一个继承 Error 的类 TimeoutError"></a>插播：创建一个继承 Error 的类 TimeoutError</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// TimeoutError.js</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnFrom</span> (<span class="params">target, source</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.getOwnPropertyNames(source).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">propName</span>) </span>&#123;</div><div class="line">        <span class="built_in">Object</span>.defineProperty(target, propName, <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propName));</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> target;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeoutError</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> superInstance = <span class="built_in">Error</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">    copyOwnFrom(<span class="keyword">this</span>, superInstance);</div><div class="line">&#125;</div><div class="line">TimeoutError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</div><div class="line">TimeoutError.prototype.constructor = TimeoutError;</div></pre></td></tr></table></figure>
<p>另一种思路，来源于 CoffeeScript 的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> __hasProp = &#123;&#125;.hasOwnProperty</div><div class="line"><span class="keyword">var</span> __extends = <span class="function"><span class="keyword">function</span> (<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">	<span class="comment">// 复制构造器上的属性</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> Parent) &#123;</div><div class="line">		<span class="keyword">if</span> (__hasProp.call(Parent, key)) Child[key] = Parent[key]</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 构建原型链</span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">ctor</span>(<span class="params"></span>) </span>&#123; <span class="keyword">this</span>.constructor = Child &#125;</div><div class="line">	ctor.prototype = Parent.prototype</div><div class="line">	Child.prototype = <span class="keyword">new</span> ctor()</div><div class="line"></div><div class="line">	Child.__super__ = Parent.prototype</div><div class="line"></div><div class="line">	<span class="keyword">return</span> Child</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> TimeoutError = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">TimeoutError</span> (<span class="params"></span>) </span>&#123;</div><div class="line">		_super.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	__extends(TimeoutError, _super)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> TimeoutError</div><div class="line">&#125;)(<span class="built_in">Error</span>)</div></pre></td></tr></table></figure>
<p>在实现了简单的超时之后，我们希望能够在 XHR 超时后取消其请求操作（以免阻塞后面可能的 XHR 请求），需要用到 <code>xhr.abort()</code> 方法。</p>
<p>对上一节中实现的 <code>getURL</code> 函数稍加改进，改成返回一个带 promise 和 abort 方法的对象，配合 <code>timeoutPromise</code> 方法就可以完成整个业务逻辑。</p>
<h3 id="Promise-prototype-done"><a href="#Promise-prototype-done" class="headerlink" title="Promise.prototype.done"></a><code>Promise.prototype.done</code></h3><blockquote>
<p>如果你使用过其他的 Promise 实现类库的话，可能见过用 done 代替 then 的例子。</p>
<p>这些类库都提供了 Promise.prototype.done 方法，使用起来也和 then 一样，但是这个方法并不会返回 Promise 对象。</p>
<p>虽然 ES6 Promises 和 Promises/A+ 等在设计上并没有对 Promise.prototype.done 做出任何规定，但是很多实现类库都提供了该方法的实现。</p>
</blockquote>
<ul>
<li><code>done</code> 不返回 Promise 对象</li>
<li><code>done</code> 发生的异常会直接抛到外面</li>
</ul>
<p><strong>在开发中，如果忘记编写 catch 函数处理 Promise Chain 中运行时错误，那么这些错误会被 “内部消化”，而不会被外部所得知，这样就给 debug 造成了巨大的困难。使用 done 的意义在于避免这样的情况。</strong></p>
<p><strong>在 setTimeout 中抛出一个异常并不会被捕获!!!</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个 error 不会被捕获</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (error) &#123;</div><div class="line">    <span class="built_in">console</span>.error(error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Promise-amp-method-chain"><a href="#Promise-amp-method-chain" class="headerlink" title="Promise &amp; method chain"></a>Promise &amp; method chain</h3><p>TODO</p>
<h3 id="Promise-amp-sequence"><a href="#Promise-amp-sequence" class="headerlink" title="Promise &amp; sequence"></a>Promise &amp; sequence</h3><p>TODO</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li><a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">JavaScript Promise 迷你书</a></li>
</ul>
<hr>
<ul>
<li><a href="https://tc39.github.io/ecma262/#sec-promise-objects" target="_blank" rel="noopener">Promise Objects - ECMAScript Language Specification</a></li>
<li><a href="https://www.w3.org/2001/tag/doc/promises-guide" target="_blank" rel="noopener">Writing Promise - Using Specifications // W3C</a></li>
<li><a href="https://speakerdeck.com/kerrick/javascript-promises-thinking-sync-in-an-async-world" target="_blank" rel="noopener">JavaScript Promises - Thinking Sync in an Async World // Speaker Deck</a></li>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises" target="_blank" rel="noopener">JavaScript Promise // Google Web Developer</a></li>
<li><a href="https://blog.domenic.me/youre-missing-the-point-of-promises/" target="_blank" rel="noopener">You’re Missing the Point of Promises</a></li>
<li><a href="https://github.com/stefanpenner/es6-promise" target="_blank" rel="noopener">es6-promise: A polyfill for ES6-style Promises</a></li>
<li><a href="http://taoofcode.net/promise-anti-patterns/" target="_blank" rel="noopener">Promise Anti-patterns</a></li>
<li><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a></li>
<li><a href="https://blog.domenic.me/youre-missing-the-point-of-promises/" target="_blank" rel="noopener">You’re Missing the Point of Promises</a></li>
<li><a href="http://www.infoq.com/cn/news/2011/09/js-promise" target="_blank" rel="noopener">JavaScript 异步编程的 Promise 模式</a></li>
</ul>
<h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><ul>
<li><a href="http://blog.mediumequalsmessage.com/promise-deferred-objects-in-javascript-pt1-theory-and-semantics" target="_blank" rel="noopener">Promise &amp; Deferred objects in JavaScript Pt.1: Theory and Semantics.</a></li>
<li><a href="https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern" target="_blank" rel="noopener">The Deferred Anti-Pattern // petkaantonov/bluebird Wiki</a></li>
<li><a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery" target="_blank" rel="noopener">Coming from jQuery // kriskowal/q Wiki</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2017/05/08/user-tracking-i/" class="prev">上一篇</a><a href="/2016/02/14/video-module-usage-in-drupal-7/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
    this.page.url = 'http://afantasy.ninja/2017/04/20/js-promise-note/';
    // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = '2017/04/20/js-promise-note/';
    // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://afantasy-ninja.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the<a href="https://disqus.com/?ref_noscript">comments powered by Disqus</a></noscript><script id="dsq-count-scr" src="//afantasy-ninja.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2019 <a href="http://afantasy.ninja">Allen</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://s22.cnzz.com/z_stat.php?id=1261988857&amp;web_id=1261988857"></script><script>document.querySelector('[title="站长统计"]').style.display = 'none'</script></body></html>